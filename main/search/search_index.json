{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ledger theme for MkDocs","text":"<p>This site is both a documentation and a showcase for this theme.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Just follow the following steps.</p>"},{"location":"#installation","title":"Installation","text":"<p>Just install <code>mkdocs-ledger</code> from the GemFury repository (this requires credentials). Properly chose the extra depending on what you want to document:</p> <pre><code># Basic installation\npip install mkdocs-ledger\n# Installation with docstring support\npip install mkdocs-ledger[docstrings]\n# Installation with `click` documentation support\npip install mkdocs-ledger[click]\n# Installation with all features\npip install mkdocs-ledger[docstrings,click]\n</code></pre>"},{"location":"#configure-mkdocs","title":"Configure mkdocs","text":"<p>Just use the <code>ledger</code> theme in your <code>mkdocs.yml</code> configuration:</p> <pre><code>theme: ledger\n</code></pre> <p>For docstrings support, use the <code>mkdocstrings</code> plugin (<code>material/search</code> needs to be added too). For click support, use the <code>mkdocs-click</code> markdown plugin.</p> <pre><code>theme: ledger\n\nmarkdown_extensions:\n  - mkdocs-click\n\nplugins:\n  - material/search\n  - mkdocstrings\n</code></pre>"},{"location":"#references","title":"References","text":"<p>This theme is based on MkDocs and some extensions so please consult upstream documentations:</p> <ul> <li>MkDocs: the documentation engine</li> <li>Material for MkDocs: the base theme</li> <li>mkdocsstrings: docstrings support</li> <li>mkdocs-click: automatic documentation for Python Click</li> </ul>"},{"location":"#showcase","title":"Showcase","text":""},{"location":"#demo-pages","title":"Demo pages","text":"<p>The following pages are just here to showcase supported features:</p> <ul> <li>docstrings: showcase docstrings support</li> <li>OpenAPI: showcase OpenAPI documentation based on <code>redoc</code>/<code>RedocLy</code></li> <li>Click: showcase <code>click</code> automatic documentation</li> <li>Mermaid: showcase <code>mermaid.js</code> diagrams integration</li> </ul> <p>They are using fake or demo data, most of the time took form their feature official website. If you are hacking this theme, don't hesitarte to use those pages to see the result. If you add support for a specific feature, please add a page showcasing it.</p> <p>Light/Dark mode</p> <p>This theme comes with support for both light and dark mode so don't forget to try both.</p> <p>The toggle button (/) is in the top header on the right.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#build","title":"\ud83d\udce6 Build","text":"<ul> <li>copier: update to <code>python.copier==0.6.0</code></li> </ul>"},{"location":"changelog/#013-2023-06-28","title":"\ud83d\ude80 0.1.3 (2023-06-28)","text":""},{"location":"changelog/#012-2023-06-28","title":"\ud83d\ude80 0.1.2 (2023-06-28)","text":""},{"location":"changelog/#011-2023-06-28","title":"\ud83d\ude80 0.1.1 (2023-06-28)","text":""},{"location":"changelog/#build_1","title":"\ud83d\udce6 Build","text":"<ul> <li>commitizen: merge prereleases in changelog on bump</li> <li>commitizen: update changelog on bump and pin major to zero until stable</li> </ul>"},{"location":"changelog/#010-2023-06-28","title":"\ud83d\ude80 0.1.0 (2023-06-28)","text":""},{"location":"changelog/#new-features","title":"\ud83d\udcab New features","text":"<ul> <li>Initial import</li> </ul>"},{"location":"changelog/#build_2","title":"\ud83d\udce6 Build","text":"<ul> <li>dev: fix <code>setuptools</code> being silently required</li> <li>apply the <code>python.copier</code> template (partially)</li> </ul>"},{"location":"cli/","title":"Click","text":"<p>This demo site shows the rendering of the MkDocs CLI itself through <code>mkdocs-click</code>.</p>"},{"location":"cli/#cli","title":"cli","text":"<p>MkDocs - Project documentation with Markdown.</p> <p>Usage:</p> <pre><code>cli [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  -V, --version         Show the version and exit.\n  -q, --quiet           Silence warnings\n  -v, --verbose         Enable verbose output\n  --color / --no-color  Force enable or disable color and wrapping for the\n                        output. Default is auto-detect.\n  --help                Show this message and exit.\n</code></pre>"},{"location":"cli/#build","title":"build","text":"<p>Build the MkDocs documentation.</p> <p>Usage:</p> <pre><code>cli build [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --clean / --dirty           Remove old files from the site_dir before\n                                  building (the default).\n  -f, --config-file FILENAME      Provide a specific MkDocs config. This can\n                                  be a file name, or '-' to read from stdin.\n  -s, --strict / --no-strict      Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -d, --site-dir PATH             The directory to output the result of the\n                                  documentation build.\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#get-deps","title":"get-deps","text":"<p>Show required PyPI packages inferred from plugins in mkdocs.yml.</p> <p>Usage:</p> <pre><code>cli get-deps [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -v, --verbose               Enable verbose output\n  -f, --config-file FILENAME  Provide a specific MkDocs config. This can be a\n                              file name, or '-' to read from stdin.\n  -p, --projects-file TEXT    URL or local path of the registry file that\n                              declares all known MkDocs-related projects.\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"cli/#gh-deploy","title":"gh-deploy","text":"<p>Deploy your documentation to GitHub Pages.</p> <p>Usage:</p> <pre><code>cli gh-deploy [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --clean / --dirty           Remove old files from the site_dir before\n                                  building (the default).\n  -m, --message TEXT              A commit message to use when committing to\n                                  the GitHub Pages remote branch. Commit {sha}\n                                  and MkDocs {version} are available as\n                                  expansions\n  -b, --remote-branch TEXT        The remote branch to commit to for GitHub\n                                  Pages. This overrides the value specified in\n                                  config\n  -r, --remote-name TEXT          The remote name to commit to for GitHub\n                                  Pages. This overrides the value specified in\n                                  config\n  --force                         Force the push to the repository.\n  --no-history                    Replace the whole Git history with one new\n                                  commit.\n  --ignore-version                Ignore check that build is not being\n                                  deployed with an older version of MkDocs.\n  --shell                         Use the shell when invoking Git.\n  -f, --config-file FILENAME      Provide a specific MkDocs config. This can\n                                  be a file name, or '-' to read from stdin.\n  -s, --strict / --no-strict      Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -d, --site-dir PATH             The directory to output the result of the\n                                  documentation build.\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#new","title":"new","text":"<p>Create a new MkDocs project.</p> <p>Usage:</p> <pre><code>cli new [OPTIONS] PROJECT_DIRECTORY\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet    Silence warnings\n  -v, --verbose  Enable verbose output\n  --help         Show this message and exit.\n</code></pre>"},{"location":"cli/#serve","title":"serve","text":"<p>Run the builtin development server.</p> <p>Usage:</p> <pre><code>cli serve [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -a, --dev-addr &lt;IP:PORT&gt;        IP address and port to serve documentation\n                                  locally (default: localhost:8000)\n  -o, --open                      Open the website in a Web browser after the\n                                  initial build finishes.\n  --no-livereload                 Disable the live reloading in the\n                                  development server.\n  --dirty                         Only re-build files that have changed.\n  -c, --clean                     Build the site without any effects of\n                                  `mkdocs serve` - pure `mkdocs build`, then\n                                  serve.\n  --watch-theme                   Include the theme in list of files to watch\n                                  for live reloading. Ignored when live reload\n                                  is not used.\n  -w, --watch PATH                A directory or file to watch for live\n                                  reloading. Can be supplied multiple times.\n  -f, --config-file FILENAME      Provide a specific MkDocs config. This can\n                                  be a file name, or '-' to read from stdin.\n  -s, --strict / --no-strict      Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"contributing/","title":"Contribution guide","text":""},{"location":"contributing/#ci","title":"CI","text":"<p>All pull-requests should pass CI, including linting and testing.</p>"},{"location":"contributing/#linting-pre-commit","title":"Linting (<code>pre-commit</code>)","text":"<p>We use <code>pre-commit</code> to ensure every commit reaches a minimum quality level. While it's not mandatory, it is strongly advised to install <code>pre-commit</code> hooks in your workspace to ensure that every commit will be automatically checked and/or formatted:</p> <pre><code>pre-commit install\n</code></pre> <p>You can run those linters on demand for tracked files:</p> <pre><code>pdm lint\n</code></pre> <p>Type checking is minimal in <code>pre-commit</code> so if you want to perform a full typing analysis, run:</p> <pre><code>pdm typing\n</code></pre>"},{"location":"contributing/#tests","title":"Tests","text":"<p>Tests are managed using pytest. You can run them in your worksapce using:</p> <pre><code>pdm test\n</code></pre> <p>The test suite requires some services which are provided using Docker Compose. You can start those using:</p> <pre><code>docker compose up\n</code></pre>"},{"location":"contributing/#conventional-commit","title":"Conventional commit","text":"<p>We use conventional commit for commit messages.</p> <p>Type must be one of the following:</p> <ul> <li><code>build</code>: Changes that affect the build system or external dependencies</li> <li><code>ci</code>: Changes to our CI configuration files and scripts (e.g. GitHub workflows)</li> <li><code>docs</code>: Documentation only changes</li> <li><code>feat</code>: A new feature</li> <li><code>fix</code>: A bug fix</li> <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li> <li><code>style</code>: Changes on code formatting that do not affect the meaning of the code</li> <li><code>test</code>: Adding missing tests or correcting existing tests</li> </ul>"},{"location":"docstrings/","title":"Docstrings","text":"<p>This page showcase the mkdocsstrings extension with its own code.</p> <p>Todo</p> <p>Make a dedicated demo package to have just what is needed to style</p> <p>This module contains the \"mkdocstrings\" plugin for MkDocs.</p> <p>The plugin instantiates a Markdown extension (<code>MkdocstringsExtension</code>), and adds it to the list of Markdown extensions used by <code>mkdocs</code> during the <code>on_config</code> event hook.</p> <p>Once the documentation is built, the <code>on_post_build</code> event hook is triggered and calls the <code>handlers.teardown()</code> method. This method is used to teardown the handlers that were instantiated during documentation buildup.</p> <p>Finally, when serving the documentation, it can add directories to watch during the <code>on_serve</code> event hook.</p> <p>This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions.</p> <p>The extension is composed of a Markdown block processor that matches indented blocks starting with a line like <code>identifier</code>.</p> <p>For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates.</p> <p>Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction:</p> <pre><code>::: some.identifier\n    handler: python\n    options:\n      option1: value1\n      option2:\n      - value2a\n      - value2b\n      option_x: etc\n</code></pre> <p>Base module for handlers.</p> <p>This module contains the base classes for implementing handlers.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin","title":"<code>MkdocstringsPlugin</code>","text":"<p>             Bases: <code>BasePlugin[PluginConfig]</code></p> <p>An <code>mkdocs</code> plugin.</p> <p>This plugin defines the following event hooks:</p> <ul> <li><code>on_config</code></li> <li><code>on_env</code></li> <li><code>on_post_build</code></li> </ul> <p>Check the Developing Plugins page of <code>mkdocs</code> for more information about its plugin system.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>class MkdocstringsPlugin(BasePlugin[PluginConfig]):\n    \"\"\"An `mkdocs` plugin.\n\n    This plugin defines the following event hooks:\n\n    - `on_config`\n    - `on_env`\n    - `on_post_build`\n\n    Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs`\n    for more information about its plugin system.\n    \"\"\"\n\n    css_filename = \"assets/_mkdocstrings.css\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the object.\"\"\"\n        super().__init__()\n        self._handlers: Handlers | None = None\n\n    @property\n    def handlers(self) -&gt; Handlers:\n        \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build.\n\n        Raises:\n            RuntimeError: If the plugin hasn't been initialized with a config.\n\n        Returns:\n            An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build).\n        \"\"\"\n        if not self._handlers:\n            raise RuntimeError(\"The plugin hasn't been initialized with a config yet\")\n        return self._handlers\n\n    def on_config(self, config: MkDocsConfig) -&gt; MkDocsConfig | None:\n        \"\"\"Instantiate our Markdown extension.\n\n        Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config).\n        In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension]\n        and add it to the list of Markdown extensions used by `mkdocs`.\n\n        We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it\n        later when processing markdown to get handlers and their global configurations).\n\n        Arguments:\n            config: The MkDocs config object.\n\n        Returns:\n            The modified config.\n        \"\"\"\n        if not self.plugin_enabled:\n            log.debug(\"Plugin is not enabled. Skipping.\")\n            return config\n        log.debug(\"Adding extension to the list\")\n\n        theme_name = config.theme.name or os.path.dirname(config.theme.dirs[0])\n\n        to_import: InventoryImportType = []\n        for handler_name, conf in self.config.handlers.items():\n            for import_item in conf.pop(\"import\", ()):\n                if isinstance(import_item, str):\n                    import_item = {\"url\": import_item}  # noqa: PLW2901\n                to_import.append((handler_name, import_item))\n\n        extension_config = {\n            \"theme_name\": theme_name,\n            \"mdx\": config.markdown_extensions,\n            \"mdx_configs\": config.mdx_configs,\n            \"mkdocstrings\": self.config,\n            \"mkdocs\": config,\n        }\n        self._handlers = Handlers(extension_config)\n\n        autorefs: AutorefsPlugin\n        try:\n            # If autorefs plugin is explicitly enabled, just use it.\n            autorefs = config.plugins[\"autorefs\"]  # type: ignore[assignment]\n            log.debug(f\"Picked up existing autorefs instance {autorefs!r}\")\n        except KeyError:\n            # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`.\n            autorefs = AutorefsPlugin()\n            autorefs.scan_toc = False\n            config.plugins[\"autorefs\"] = autorefs\n            log.debug(f\"Added a subdued autorefs instance {autorefs!r}\")\n        # Add collector-based fallback in either case.\n        autorefs.get_fallback_anchor = self.handlers.get_anchors\n\n        mkdocstrings_extension = MkdocstringsExtension(extension_config, self.handlers, autorefs)\n        config.markdown_extensions.append(mkdocstrings_extension)  # type: ignore[arg-type]\n\n        config.extra_css.insert(0, self.css_filename)  # So that it has lower priority than user files.\n\n        self._inv_futures = {}\n        if to_import:\n            inv_loader = futures.ThreadPoolExecutor(4)\n            for handler_name, import_item in to_import:\n                loader = self.get_handler(handler_name).load_inventory\n                future = inv_loader.submit(\n                    self._load_inventory,  # type: ignore[misc]\n                    loader,\n                    **import_item,\n                )\n                self._inv_futures[future] = (loader, import_item)\n            inv_loader.shutdown(wait=False)\n\n        return config\n\n    @property\n    def inventory_enabled(self) -&gt; bool:\n        \"\"\"Tell if the inventory is enabled or not.\n\n        Returns:\n            Whether the inventory is enabled.\n        \"\"\"\n        inventory_enabled = self.config.enable_inventory\n        if inventory_enabled is None:\n            inventory_enabled = any(handler.enable_inventory for handler in self.handlers.seen_handlers)\n        return inventory_enabled\n\n    @property\n    def plugin_enabled(self) -&gt; bool:\n        \"\"\"Tell if the plugin is enabled or not.\n\n        Returns:\n            Whether the plugin is enabled.\n        \"\"\"\n        return self.config.enabled\n\n    def on_env(self, env: Environment, config: MkDocsConfig, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n        \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering.\n\n        Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env).\n\n        - Write mkdocstrings' extra files into the site dir.\n        - Gather results from background inventory download tasks.\n        \"\"\"\n        if not self.plugin_enabled:\n            return\n        if self._handlers:\n            css_content = \"\\n\".join(handler.extra_css for handler in self.handlers.seen_handlers)\n            write_file(css_content.encode(\"utf-8\"), os.path.join(config.site_dir, self.css_filename))\n\n            if self.inventory_enabled:\n                log.debug(\"Creating inventory file objects.inv\")\n                inv_contents = self.handlers.inventory.format_sphinx()\n                write_file(inv_contents, os.path.join(config.site_dir, \"objects.inv\"))\n\n        if self._inv_futures:\n            log.debug(f\"Waiting for {len(self._inv_futures)} inventory download(s)\")\n            futures.wait(self._inv_futures, timeout=30)\n            results = {}\n            # Reversed order so that pages from first futures take precedence:\n            for fut in reversed(list(self._inv_futures)):\n                try:\n                    results.update(fut.result())\n                except Exception as error:  # noqa: BLE001\n                    loader, import_item = self._inv_futures[fut]\n                    loader_name = loader.__func__.__qualname__\n                    log.error(f\"Couldn't load inventory {import_item} through {loader_name}: {error}\")  # noqa: TRY400\n            for page, identifier in results.items():\n                config.plugins[\"autorefs\"].register_url(page, identifier)  # type: ignore[attr-defined]\n            self._inv_futures = {}\n\n    def on_post_build(\n        self,\n        config: MkDocsConfig,  # noqa: ARG002\n        **kwargs: Any,  # noqa: ARG002\n    ) -&gt; None:\n        \"\"\"Teardown the handlers.\n\n        Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build).\n        This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.\n\n        For example, a handler could open a subprocess in the background and keep it open\n        to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point:\n        the proper place to do this is in the handler's `teardown` method, which is indirectly called by this hook.\n\n        Arguments:\n            config: The MkDocs config object.\n            **kwargs: Additional arguments passed by MkDocs.\n        \"\"\"\n        if not self.plugin_enabled:\n            return\n\n        for future in self._inv_futures:\n            future.cancel()\n\n        if self._handlers:\n            log.debug(\"Tearing handlers down\")\n            self.handlers.teardown()\n\n    def get_handler(self, handler_name: str) -&gt; BaseHandler:\n        \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][].\n\n        Arguments:\n            handler_name: The name of the handler.\n\n        Returns:\n            An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler].\n        \"\"\"\n        return self.handlers.get_handler(handler_name)\n\n    @classmethod\n    # lru_cache does not allow mutable arguments such lists, but that is what we load from YAML config.\n    @list_to_tuple\n    @functools.lru_cache(maxsize=None)\n    def _load_inventory(cls, loader: InventoryLoaderType, url: str, **kwargs: Any) -&gt; Mapping[str, str]:\n        \"\"\"Download and process inventory files using a handler.\n\n        Arguments:\n            loader: A function returning a sequence of pairs (identifier, url).\n            url: The URL to download and process.\n            **kwargs: Extra arguments to pass to the loader.\n\n        Returns:\n            A mapping from identifier to absolute URL.\n        \"\"\"\n        log.debug(f\"Downloading inventory from {url!r}\")\n        content = download_and_cache_url(url, download_url_with_gz, datetime.timedelta(days=1))\n        result = dict(loader(BytesIO(content), url=url, **kwargs))\n        log.debug(f\"Loaded inventory from {url!r}: {len(result)} items\")\n        return result\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.handlers","title":"<code>handlers: Handlers</code>  <code>property</code>","text":"<p>Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the plugin hasn't been initialized with a config.</p> <p>Returns:</p> Type Description <code>Handlers</code> <p>An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build).</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.inventory_enabled","title":"<code>inventory_enabled: bool</code>  <code>property</code>","text":"<p>Tell if the inventory is enabled or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the inventory is enabled.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.plugin_enabled","title":"<code>plugin_enabled: bool</code>  <code>property</code>","text":"<p>Tell if the plugin is enabled or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the plugin is enabled.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the object.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the object.\"\"\"\n    super().__init__()\n    self._handlers: Handlers | None = None\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.get_handler","title":"<code>get_handler(handler_name)</code>","text":"<p>Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler_name</code> <code>str</code> <p>The name of the handler.</p> required <p>Returns:</p> Type Description <code>BaseHandler</code> <p>An instance of a subclass of <code>BaseHandler</code>.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def get_handler(self, handler_name: str) -&gt; BaseHandler:\n    \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][].\n\n    Arguments:\n        handler_name: The name of the handler.\n\n    Returns:\n        An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler].\n    \"\"\"\n    return self.handlers.get_handler(handler_name)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","title":"<code>on_config(config)</code>","text":"<p>Instantiate our Markdown extension.</p> <p>Hook for the <code>on_config</code> event. In this hook, we instantiate our <code>MkdocstringsExtension</code> and add it to the list of Markdown extensions used by <code>mkdocs</code>.</p> <p>We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MkDocsConfig</code> <p>The MkDocs config object.</p> required <p>Returns:</p> Type Description <code>MkDocsConfig | None</code> <p>The modified config.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_config(self, config: MkDocsConfig) -&gt; MkDocsConfig | None:\n    \"\"\"Instantiate our Markdown extension.\n\n    Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config).\n    In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension]\n    and add it to the list of Markdown extensions used by `mkdocs`.\n\n    We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it\n    later when processing markdown to get handlers and their global configurations).\n\n    Arguments:\n        config: The MkDocs config object.\n\n    Returns:\n        The modified config.\n    \"\"\"\n    if not self.plugin_enabled:\n        log.debug(\"Plugin is not enabled. Skipping.\")\n        return config\n    log.debug(\"Adding extension to the list\")\n\n    theme_name = config.theme.name or os.path.dirname(config.theme.dirs[0])\n\n    to_import: InventoryImportType = []\n    for handler_name, conf in self.config.handlers.items():\n        for import_item in conf.pop(\"import\", ()):\n            if isinstance(import_item, str):\n                import_item = {\"url\": import_item}  # noqa: PLW2901\n            to_import.append((handler_name, import_item))\n\n    extension_config = {\n        \"theme_name\": theme_name,\n        \"mdx\": config.markdown_extensions,\n        \"mdx_configs\": config.mdx_configs,\n        \"mkdocstrings\": self.config,\n        \"mkdocs\": config,\n    }\n    self._handlers = Handlers(extension_config)\n\n    autorefs: AutorefsPlugin\n    try:\n        # If autorefs plugin is explicitly enabled, just use it.\n        autorefs = config.plugins[\"autorefs\"]  # type: ignore[assignment]\n        log.debug(f\"Picked up existing autorefs instance {autorefs!r}\")\n    except KeyError:\n        # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`.\n        autorefs = AutorefsPlugin()\n        autorefs.scan_toc = False\n        config.plugins[\"autorefs\"] = autorefs\n        log.debug(f\"Added a subdued autorefs instance {autorefs!r}\")\n    # Add collector-based fallback in either case.\n    autorefs.get_fallback_anchor = self.handlers.get_anchors\n\n    mkdocstrings_extension = MkdocstringsExtension(extension_config, self.handlers, autorefs)\n    config.markdown_extensions.append(mkdocstrings_extension)  # type: ignore[arg-type]\n\n    config.extra_css.insert(0, self.css_filename)  # So that it has lower priority than user files.\n\n    self._inv_futures = {}\n    if to_import:\n        inv_loader = futures.ThreadPoolExecutor(4)\n        for handler_name, import_item in to_import:\n            loader = self.get_handler(handler_name).load_inventory\n            future = inv_loader.submit(\n                self._load_inventory,  # type: ignore[misc]\n                loader,\n                **import_item,\n            )\n            self._inv_futures[future] = (loader, import_item)\n        inv_loader.shutdown(wait=False)\n\n    return config\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_env","title":"<code>on_env(env, config, *args, **kwargs)</code>","text":"<p>Extra actions that need to happen after all Markdown rendering and before HTML rendering.</p> <p>Hook for the <code>on_env</code> event.</p> <ul> <li>Write mkdocstrings' extra files into the site dir.</li> <li>Gather results from background inventory download tasks.</li> </ul> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_env(self, env: Environment, config: MkDocsConfig, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering.\n\n    Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env).\n\n    - Write mkdocstrings' extra files into the site dir.\n    - Gather results from background inventory download tasks.\n    \"\"\"\n    if not self.plugin_enabled:\n        return\n    if self._handlers:\n        css_content = \"\\n\".join(handler.extra_css for handler in self.handlers.seen_handlers)\n        write_file(css_content.encode(\"utf-8\"), os.path.join(config.site_dir, self.css_filename))\n\n        if self.inventory_enabled:\n            log.debug(\"Creating inventory file objects.inv\")\n            inv_contents = self.handlers.inventory.format_sphinx()\n            write_file(inv_contents, os.path.join(config.site_dir, \"objects.inv\"))\n\n    if self._inv_futures:\n        log.debug(f\"Waiting for {len(self._inv_futures)} inventory download(s)\")\n        futures.wait(self._inv_futures, timeout=30)\n        results = {}\n        # Reversed order so that pages from first futures take precedence:\n        for fut in reversed(list(self._inv_futures)):\n            try:\n                results.update(fut.result())\n            except Exception as error:  # noqa: BLE001\n                loader, import_item = self._inv_futures[fut]\n                loader_name = loader.__func__.__qualname__\n                log.error(f\"Couldn't load inventory {import_item} through {loader_name}: {error}\")  # noqa: TRY400\n        for page, identifier in results.items():\n            config.plugins[\"autorefs\"].register_url(page, identifier)  # type: ignore[attr-defined]\n        self._inv_futures = {}\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","title":"<code>on_post_build(config, **kwargs)</code>","text":"<p>Teardown the handlers.</p> <p>Hook for the <code>on_post_build</code> event. This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.</p> <p>For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the handler's <code>teardown</code> method, which is indirectly called by this hook.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MkDocsConfig</code> <p>The MkDocs config object.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed by MkDocs.</p> <code>{}</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_post_build(\n    self,\n    config: MkDocsConfig,  # noqa: ARG002\n    **kwargs: Any,  # noqa: ARG002\n) -&gt; None:\n    \"\"\"Teardown the handlers.\n\n    Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build).\n    This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.\n\n    For example, a handler could open a subprocess in the background and keep it open\n    to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point:\n    the proper place to do this is in the handler's `teardown` method, which is indirectly called by this hook.\n\n    Arguments:\n        config: The MkDocs config object.\n        **kwargs: Additional arguments passed by MkDocs.\n    \"\"\"\n    if not self.plugin_enabled:\n        return\n\n    for future in self._inv_futures:\n        future.cancel()\n\n    if self._handlers:\n        log.debug(\"Tearing handlers down\")\n        self.handlers.teardown()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig","title":"<code>PluginConfig</code>","text":"<p>             Bases: <code>Config</code></p> <p>The configuration options of <code>mkdocstrings</code>, written in <code>mkdocs.yml</code>.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>class PluginConfig(Config):\n    \"\"\"The configuration options of `mkdocstrings`, written in `mkdocs.yml`.\"\"\"\n\n    handlers = opt.Type(dict, default={})\n    \"\"\"\n    Global configuration of handlers.\n\n    You can set global configuration per handler, applied everywhere,\n    but overridable in each \"autodoc\" instruction. Example:\n\n    ```yaml\n    plugins:\n      - mkdocstrings:\n          handlers:\n            python:\n              options:\n                option1: true\n                option2: \"value\"\n            rust:\n              options:\n                option9: 2\n    ```\n    \"\"\"\n\n    default_handler = opt.Type(str, default=\"python\")\n    \"\"\"The default handler to use. The value is the name of the handler module. Default is \"python\".\"\"\"\n    custom_templates = opt.Optional(opt.Dir(exists=True))\n    \"\"\"Location of custom templates to use when rendering API objects.\n\n    Value should be the path of a directory relative to the MkDocs configuration file.\n    \"\"\"\n    enable_inventory = opt.Optional(opt.Type(bool))\n    \"\"\"Whether to enable object inventory creation.\"\"\"\n    enabled = opt.Type(bool, default=True)\n    \"\"\"Whether to enable the plugin. Default is true. If false, *mkdocstrings* will not collect or render anything.\"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig.custom_templates","title":"<code>custom_templates = opt.Optional(opt.Dir(exists=True))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Location of custom templates to use when rendering API objects.</p> <p>Value should be the path of a directory relative to the MkDocs configuration file.</p>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig.default_handler","title":"<code>default_handler = opt.Type(str, default='python')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The default handler to use. The value is the name of the handler module. Default is \"python\".</p>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig.enable_inventory","title":"<code>enable_inventory = opt.Optional(opt.Type(bool))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable object inventory creation.</p>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig.enabled","title":"<code>enabled = opt.Type(bool, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable the plugin. Default is true. If false, mkdocstrings will not collect or render anything.</p>"},{"location":"docstrings/#mkdocstrings.plugin.PluginConfig.handlers","title":"<code>handlers = opt.Type(dict, default={})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Global configuration of handlers.</p> <p>You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example:</p> <pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            option1: true\n            option2: \"value\"\n        rust:\n          options:\n            option9: 2\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.list_to_tuple","title":"<code>list_to_tuple(function)</code>","text":"<p>Decorater to convert lists to tuples in the arguments.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def list_to_tuple(function: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorater to convert lists to tuples in the arguments.\"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        safe_args = [tuple(item) if isinstance(item, list) else item for item in args]\n        if kwargs:\n            kwargs = {key: tuple(value) if isinstance(value, list) else value for key, value in kwargs.items()}  # type: ignore[assignment]\n        return function(*safe_args, **kwargs)  # type: ignore[arg-type]\n\n    return wrapper\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor","title":"<code>AutoDocProcessor</code>","text":"<p>             Bases: <code>BlockProcessor</code></p> <p>Our \"autodoc\" Markdown block processor.</p> <p>It has a <code>test</code> method that tells if a block matches a criterion, and a <code>run</code> method that processes it.</p> <p>It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>class AutoDocProcessor(BlockProcessor):\n    \"\"\"Our \"autodoc\" Markdown block processor.\n\n    It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion,\n    and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it.\n\n    It also has utility methods allowing to get handlers and their configuration easily, useful when processing\n    a matched block.\n    \"\"\"\n\n    regex = re.compile(r\"^(?P&lt;heading&gt;#{1,6} *|)::: ?(?P&lt;name&gt;.+?) *$\", flags=re.MULTILINE)\n\n    def __init__(\n        self,\n        parser: BlockParser,\n        md: Markdown,\n        config: dict,\n        handlers: Handlers,\n        autorefs: AutorefsPlugin,\n    ) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            parser: A `markdown.blockparser.BlockParser` instance.\n            md: A `markdown.Markdown` instance.\n            config: The [configuration][mkdocstrings.plugin.PluginConfig] of the `mkdocstrings` plugin.\n            handlers: The handlers container.\n            autorefs: The autorefs plugin instance.\n        \"\"\"\n        super().__init__(parser=parser)\n        self.md = md\n        self._config = config\n        self._handlers = handlers\n        self._autorefs = autorefs\n        self._updated_envs: set = set()\n\n    def test(self, parent: Element, block: str) -&gt; bool:  # noqa: ARG002\n        \"\"\"Match our autodoc instructions.\n\n        Arguments:\n            parent: The parent element in the XML tree.\n            block: The block to be tested.\n\n        Returns:\n            Whether this block should be processed or not.\n        \"\"\"\n        return bool(self.regex.search(block))\n\n    def run(self, parent: Element, blocks: MutableSequence[str]) -&gt; None:\n        \"\"\"Run code on the matched blocks.\n\n        The identifier and configuration lines are retrieved from a matched block\n        and used to collect and render an object.\n\n        Arguments:\n            parent: The parent element in the XML tree.\n            blocks: The rest of the blocks to be processed.\n        \"\"\"\n        block = blocks.pop(0)\n        match = self.regex.search(block)\n\n        if match:\n            if match.start() &gt; 0:\n                self.parser.parseBlocks(parent, [block[: match.start()]])\n            # removes the first line\n            block = block[match.end() :]\n\n        block, the_rest = self.detab(block)\n\n        if match:\n            identifier = match[\"name\"]\n            heading_level = match[\"heading\"].count(\"#\")\n            log.debug(f\"Matched '::: {identifier}'\")\n\n            html, handler, data = self._process_block(identifier, block, heading_level)\n            el = Element(\"div\", {\"class\": \"mkdocstrings\"})\n            # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end.\n            el.text = self.md.htmlStash.store(html)\n            # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up.\n            headings = handler.get_headings()\n            el.extend(headings)\n\n            page = self._autorefs.current_page\n            if page is not None:\n                for heading in headings:\n                    rendered_anchor = heading.attrib[\"id\"]\n                    self._autorefs.register_anchor(page, rendered_anchor)\n\n                    if \"data-role\" in heading.attrib:\n                        self._handlers.inventory.register(\n                            name=rendered_anchor,\n                            domain=handler.domain,\n                            role=heading.attrib[\"data-role\"],\n                            priority=1,  # register with standard priority\n                            uri=f\"{page}#{rendered_anchor}\",\n                        )\n\n                        # also register other anchors for this object in the inventory\n                        try:\n                            data_object = handler.collect(rendered_anchor, handler.fallback_config)\n                        except CollectionError:\n                            continue\n                        for anchor in handler.get_anchors(data_object):\n                            if anchor not in self._handlers.inventory:\n                                self._handlers.inventory.register(\n                                    name=anchor,\n                                    domain=handler.domain,\n                                    role=heading.attrib[\"data-role\"],\n                                    priority=2,  # register with lower priority\n                                    uri=f\"{page}#{rendered_anchor}\",\n                                )\n\n            parent.append(el)\n\n        if the_rest:\n            # This block contained unindented line(s) after the first indented\n            # line. Insert these lines as the first block of the master blocks\n            # list for future processing.\n            blocks.insert(0, the_rest)\n\n    def _process_block(\n        self,\n        identifier: str,\n        yaml_block: str,\n        heading_level: int = 0,\n    ) -&gt; tuple[str, BaseHandler, CollectorItem]:\n        \"\"\"Process an autodoc block.\n\n        Arguments:\n            identifier: The identifier of the object to collect and render.\n            yaml_block: The YAML configuration.\n            heading_level: Suggested level of the heading to insert (0 to ignore).\n\n        Raises:\n            PluginError: When something wrong happened during collection.\n            TemplateNotFound: When a template used for rendering could not be found.\n\n        Returns:\n            Rendered HTML, the handler that was used, and the collected item.\n        \"\"\"\n        config = yaml.safe_load(yaml_block) or {}\n        handler_name = self._handlers.get_handler_name(config)\n\n        log.debug(f\"Using handler '{handler_name}'\")\n        handler_config = self._handlers.get_handler_config(handler_name)\n        handler = self._handlers.get_handler(handler_name, handler_config)\n\n        global_options = handler_config.get(\"options\", {})\n        local_options = config.get(\"options\", {})\n        options = ChainMap(local_options, global_options)\n\n        if heading_level:\n            options = ChainMap(options, {\"heading_level\": heading_level})  # like setdefault\n\n        log.debug(\"Collecting data\")\n        try:\n            data: CollectorItem = handler.collect(identifier, options)\n        except CollectionError as exception:\n            log.error(str(exception))  # noqa: TRY400\n            if PluginError is SystemExit:  # TODO: when MkDocs 1.2 is sufficiently common, this can be dropped.\n                log.error(f\"Error reading page '{self._autorefs.current_page}':\")  # noqa: TRY400\n            raise PluginError(f\"Could not collect '{identifier}'\") from exception\n\n        if handler_name not in self._updated_envs:  # We haven't seen this handler before on this document.\n            log.debug(\"Updating handler's rendering env\")\n            handler._update_env(self.md, self._config)\n            self._updated_envs.add(handler_name)\n\n        log.debug(\"Rendering templates\")\n        try:\n            rendered = handler.render(data, options)\n        except TemplateNotFound as exc:\n            theme_name = self._config[\"theme_name\"]\n            log.error(  # noqa: TRY400\n                f\"Template '{exc.name}' not found for '{handler_name}' handler and theme '{theme_name}'.\",\n            )\n            raise\n\n        return rendered, handler, data\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.__init__","title":"<code>__init__(parser, md, config, handlers, autorefs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>BlockParser</code> <p>A <code>markdown.blockparser.BlockParser</code> instance.</p> required <code>md</code> <code>Markdown</code> <p>A <code>markdown.Markdown</code> instance.</p> required <code>config</code> <code>dict</code> <p>The configuration of the <code>mkdocstrings</code> plugin.</p> required <code>handlers</code> <code>Handlers</code> <p>The handlers container.</p> required <code>autorefs</code> <code>AutorefsPlugin</code> <p>The autorefs plugin instance.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def __init__(\n    self,\n    parser: BlockParser,\n    md: Markdown,\n    config: dict,\n    handlers: Handlers,\n    autorefs: AutorefsPlugin,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        parser: A `markdown.blockparser.BlockParser` instance.\n        md: A `markdown.Markdown` instance.\n        config: The [configuration][mkdocstrings.plugin.PluginConfig] of the `mkdocstrings` plugin.\n        handlers: The handlers container.\n        autorefs: The autorefs plugin instance.\n    \"\"\"\n    super().__init__(parser=parser)\n    self.md = md\n    self._config = config\n    self._handlers = handlers\n    self._autorefs = autorefs\n    self._updated_envs: set = set()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.run","title":"<code>run(parent, blocks)</code>","text":"<p>Run code on the matched blocks.</p> <p>The identifier and configuration lines are retrieved from a matched block and used to collect and render an object.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Element</code> <p>The parent element in the XML tree.</p> required <code>blocks</code> <code>MutableSequence[str]</code> <p>The rest of the blocks to be processed.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def run(self, parent: Element, blocks: MutableSequence[str]) -&gt; None:\n    \"\"\"Run code on the matched blocks.\n\n    The identifier and configuration lines are retrieved from a matched block\n    and used to collect and render an object.\n\n    Arguments:\n        parent: The parent element in the XML tree.\n        blocks: The rest of the blocks to be processed.\n    \"\"\"\n    block = blocks.pop(0)\n    match = self.regex.search(block)\n\n    if match:\n        if match.start() &gt; 0:\n            self.parser.parseBlocks(parent, [block[: match.start()]])\n        # removes the first line\n        block = block[match.end() :]\n\n    block, the_rest = self.detab(block)\n\n    if match:\n        identifier = match[\"name\"]\n        heading_level = match[\"heading\"].count(\"#\")\n        log.debug(f\"Matched '::: {identifier}'\")\n\n        html, handler, data = self._process_block(identifier, block, heading_level)\n        el = Element(\"div\", {\"class\": \"mkdocstrings\"})\n        # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end.\n        el.text = self.md.htmlStash.store(html)\n        # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up.\n        headings = handler.get_headings()\n        el.extend(headings)\n\n        page = self._autorefs.current_page\n        if page is not None:\n            for heading in headings:\n                rendered_anchor = heading.attrib[\"id\"]\n                self._autorefs.register_anchor(page, rendered_anchor)\n\n                if \"data-role\" in heading.attrib:\n                    self._handlers.inventory.register(\n                        name=rendered_anchor,\n                        domain=handler.domain,\n                        role=heading.attrib[\"data-role\"],\n                        priority=1,  # register with standard priority\n                        uri=f\"{page}#{rendered_anchor}\",\n                    )\n\n                    # also register other anchors for this object in the inventory\n                    try:\n                        data_object = handler.collect(rendered_anchor, handler.fallback_config)\n                    except CollectionError:\n                        continue\n                    for anchor in handler.get_anchors(data_object):\n                        if anchor not in self._handlers.inventory:\n                            self._handlers.inventory.register(\n                                name=anchor,\n                                domain=handler.domain,\n                                role=heading.attrib[\"data-role\"],\n                                priority=2,  # register with lower priority\n                                uri=f\"{page}#{rendered_anchor}\",\n                            )\n\n        parent.append(el)\n\n    if the_rest:\n        # This block contained unindented line(s) after the first indented\n        # line. Insert these lines as the first block of the master blocks\n        # list for future processing.\n        blocks.insert(0, the_rest)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.test","title":"<code>test(parent, block)</code>","text":"<p>Match our autodoc instructions.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Element</code> <p>The parent element in the XML tree.</p> required <code>block</code> <code>str</code> <p>The block to be tested.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether this block should be processed or not.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def test(self, parent: Element, block: str) -&gt; bool:  # noqa: ARG002\n    \"\"\"Match our autodoc instructions.\n\n    Arguments:\n        parent: The parent element in the XML tree.\n        block: The block to be tested.\n\n    Returns:\n        Whether this block should be processed or not.\n    \"\"\"\n    return bool(self.regex.search(block))\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension","title":"<code>MkdocstringsExtension</code>","text":"<p>             Bases: <code>Extension</code></p> <p>Our Markdown extension.</p> <p>It cannot work outside of <code>mkdocstrings</code>.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>class MkdocstringsExtension(Extension):\n    \"\"\"Our Markdown extension.\n\n    It cannot work outside of `mkdocstrings`.\n    \"\"\"\n\n    def __init__(self, config: dict, handlers: Handlers, autorefs: AutorefsPlugin, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor\n                when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown].\n            handlers: The handlers container.\n            autorefs: The autorefs plugin instance.\n            **kwargs: Keyword arguments used by `markdown.extensions.Extension`.\n        \"\"\"\n        super().__init__(**kwargs)\n        self._config = config\n        self._handlers = handlers\n        self._autorefs = autorefs\n\n    def extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802 (casing: parent method's name)\n        \"\"\"Register the extension.\n\n        Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser.\n\n        Arguments:\n            md: A `markdown.Markdown` instance.\n        \"\"\"\n        md.parser.blockprocessors.register(\n            AutoDocProcessor(md.parser, md, self._config, self._handlers, self._autorefs),\n            \"mkdocstrings\",\n            priority=75,  # Right before markdown.blockprocessors.HashHeaderProcessor\n        )\n        md.treeprocessors.register(\n            _HeadingsPostProcessor(md),\n            \"mkdocstrings_post_headings\",\n            priority=4,  # Right after 'toc'.\n        )\n        md.treeprocessors.register(\n            _TocLabelsTreeProcessor(md),\n            \"mkdocstrings_post_toc_labels\",\n            priority=4,  # Right after 'toc'.\n        )\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.__init__","title":"<code>__init__(config, handlers, autorefs, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration items from <code>mkdocs</code> and <code>mkdocstrings</code> that must be passed to the block processor when instantiated in <code>extendMarkdown</code>.</p> required <code>handlers</code> <code>Handlers</code> <p>The handlers container.</p> required <code>autorefs</code> <code>AutorefsPlugin</code> <p>The autorefs plugin instance.</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments used by <code>markdown.extensions.Extension</code>.</p> <code>{}</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def __init__(self, config: dict, handlers: Handlers, autorefs: AutorefsPlugin, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor\n            when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown].\n        handlers: The handlers container.\n        autorefs: The autorefs plugin instance.\n        **kwargs: Keyword arguments used by `markdown.extensions.Extension`.\n    \"\"\"\n    super().__init__(**kwargs)\n    self._config = config\n    self._handlers = handlers\n    self._autorefs = autorefs\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","title":"<code>extendMarkdown(md)</code>","text":"<p>Register the extension.</p> <p>Add an instance of our <code>AutoDocProcessor</code> to the Markdown parser.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Markdown</code> <p>A <code>markdown.Markdown</code> instance.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802 (casing: parent method's name)\n    \"\"\"Register the extension.\n\n    Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser.\n\n    Arguments:\n        md: A `markdown.Markdown` instance.\n    \"\"\"\n    md.parser.blockprocessors.register(\n        AutoDocProcessor(md.parser, md, self._config, self._handlers, self._autorefs),\n        \"mkdocstrings\",\n        priority=75,  # Right before markdown.blockprocessors.HashHeaderProcessor\n    )\n    md.treeprocessors.register(\n        _HeadingsPostProcessor(md),\n        \"mkdocstrings_post_headings\",\n        priority=4,  # Right after 'toc'.\n    )\n    md.treeprocessors.register(\n        _TocLabelsTreeProcessor(md),\n        \"mkdocstrings_post_toc_labels\",\n        priority=4,  # Right after 'toc'.\n    )\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>The base handler class.</p> <p>Inherit from this class to implement a handler.</p> <p>You will have to implement the <code>collect</code> and <code>render</code> methods. You can also implement the <code>teardown</code> method, and  override the <code>update_env</code> method, to add more filters to the Jinja environment, making them available in your Jinja templates.</p> <p>To define a fallback theme, add a <code>fallback_theme</code> class-variable. To add custom CSS, add an <code>extra_css</code> variable or create an 'style.css' file beside the templates.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class BaseHandler:\n    \"\"\"The base handler class.\n\n    Inherit from this class to implement a handler.\n\n    You will have to implement the `collect` and `render` methods.\n    You can also implement the `teardown` method,\n    and  override the `update_env` method, to add more filters to the Jinja environment,\n    making them available in your Jinja templates.\n\n    To define a fallback theme, add a `fallback_theme` class-variable.\n    To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates.\n    \"\"\"\n\n    name: str = \"\"\n    \"\"\"The handler's name, for example \"python\".\"\"\"\n    domain: str = \"default\"\n    \"\"\"The handler's domain, used to register objects in the inventory, for example \"py\".\"\"\"\n    enable_inventory: bool = False\n    \"\"\"Whether the inventory creation is enabled.\"\"\"\n    fallback_config: ClassVar[dict] = {}\n    \"\"\"Fallback configuration when searching anchors for identifiers.\"\"\"\n    fallback_theme: str = \"\"\n    \"\"\"Fallback theme to use when a template isn't found in the configured theme.\"\"\"\n    extra_css = \"\"\n    \"\"\"Extra CSS.\"\"\"\n\n    def __init__(self, handler: str, theme: str, custom_templates: str | None = None) -&gt; None:\n        \"\"\"Initialize the object.\n\n        If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute\n        in `self` to use as a fallback theme.\n\n        Arguments:\n            handler: The name of the handler.\n            theme: The name of theme to use.\n            custom_templates: Directory containing custom templates.\n        \"\"\"\n        paths = []\n\n        # add selected theme templates\n        themes_dir = self.get_templates_dir(handler)\n        paths.append(themes_dir / theme)\n\n        # add extended theme templates\n        extended_templates_dirs = self.get_extended_templates_dirs(handler)\n        for templates_dir in extended_templates_dirs:\n            paths.append(templates_dir / theme)\n\n        # add fallback theme templates\n        if self.fallback_theme and self.fallback_theme != theme:\n            paths.append(themes_dir / self.fallback_theme)\n\n            # add fallback theme of extended templates\n            for templates_dir in extended_templates_dirs:\n                paths.append(templates_dir / self.fallback_theme)\n\n        for path in paths:\n            css_path = path / \"style.css\"\n            if css_path.is_file():\n                self.extra_css += \"\\n\" + css_path.read_text(encoding=\"utf-8\")\n                break\n\n        if custom_templates is not None:\n            paths.insert(0, Path(custom_templates) / handler / theme)\n\n        self.env = Environment(\n            autoescape=True,\n            loader=FileSystemLoader(paths),\n            auto_reload=False,  # Editing a template in the middle of a build is not useful.\n        )\n        self.env.filters[\"any\"] = do_any\n        self.env.globals[\"log\"] = get_template_logger()\n\n        self._headings: list[Element] = []\n        self._md: Markdown = None  # type: ignore[assignment]  # To be populated in `update_env`.\n\n    @classmethod\n    def load_inventory(\n        cls,\n        in_file: BinaryIO,  # noqa: ARG003\n        url: str,  # noqa: ARG003\n        base_url: str | None = None,  # noqa: ARG003\n        **kwargs: Any,  # noqa: ARG003\n    ) -&gt; Iterator[tuple[str, str]]:\n        \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`.\n\n        Arguments:\n            in_file: The binary file-like object to read the inventory from.\n            url: The URL that this file is being streamed from (used to guess `base_url`).\n            base_url: The URL that this inventory's sub-paths are relative to.\n            **kwargs: Ignore additional arguments passed from the config.\n\n        Yields:\n            Tuples of (item identifier, item URL).\n        \"\"\"\n        yield from ()\n\n    def collect(self, identifier: str, config: MutableMapping[str, Any]) -&gt; CollectorItem:\n        \"\"\"Collect data given an identifier and user configuration.\n\n        In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into\n        a Python dictionary for example, though the implementation is completely free.\n\n        Arguments:\n            identifier: An identifier for which to collect data. For example, in Python,\n                it would be 'mkdocstrings.handlers' to collect documentation about the handlers module.\n                It can be anything that you can feed to the tool of your choice.\n            config: The handler's configuration options.\n\n        Returns:\n            Anything you want, as long as you can feed it to the handler's `render` method.\n        \"\"\"\n        raise NotImplementedError\n\n    def render(self, data: CollectorItem, config: Mapping[str, Any]) -&gt; str:\n        \"\"\"Render a template using provided data and configuration options.\n\n        Arguments:\n            data: The collected data to render.\n            config: The handler's configuration options.\n\n        Returns:\n            The rendered template as HTML.\n        \"\"\"\n        raise NotImplementedError\n\n    def teardown(self) -&gt; None:\n        \"\"\"Teardown the handler.\n\n        This method should be implemented to, for example, terminate a subprocess\n        that was started when creating the handler instance.\n        \"\"\"\n\n    def get_templates_dir(self, handler: str | None = None) -&gt; Path:\n        \"\"\"Return the path to the handler's templates directory.\n\n        Override to customize how the templates directory is found.\n\n        Arguments:\n            handler: The name of the handler to get the templates directory of.\n\n        Raises:\n            ModuleNotFoundError: When no such handler is installed.\n            FileNotFoundError: When the templates directory cannot be found.\n\n        Returns:\n            The templates directory path.\n        \"\"\"\n        handler = handler or self.name\n        try:\n            import mkdocstrings_handlers\n        except ModuleNotFoundError as error:\n            raise ModuleNotFoundError(f\"Handler '{handler}' not found, is it installed?\") from error\n\n        for path in mkdocstrings_handlers.__path__:\n            theme_path = Path(path, handler, \"templates\")\n            if theme_path.exists():\n                return theme_path\n\n        raise FileNotFoundError(f\"Can't find 'templates' folder for handler '{handler}'\")\n\n    def get_extended_templates_dirs(self, handler: str) -&gt; list[Path]:\n        \"\"\"Load template extensions for the given handler, return their templates directories.\n\n        Arguments:\n            handler: The name of the handler to get the extended templates directory of.\n\n        Returns:\n            The extensions templates directories.\n        \"\"\"\n        discovered_extensions = entry_points(group=f\"mkdocstrings.{handler}.templates\")\n        return [extension.load()() for extension in discovered_extensions]\n\n    def get_anchors(self, data: CollectorItem) -&gt; tuple[str, ...]:\n        \"\"\"Return the possible identifiers (HTML anchors) for a collected item.\n\n        Arguments:\n            data: The collected data.\n\n        Returns:\n            The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.\n        \"\"\"\n        # TODO: remove this when https://github.com/mkdocstrings/crystal/pull/6 is merged and released\n        try:\n            return (self.get_anchor(data),)  # type: ignore[attr-defined]\n        except AttributeError:\n            return ()\n\n    def do_convert_markdown(\n        self,\n        text: str,\n        heading_level: int,\n        html_id: str = \"\",\n        *,\n        strip_paragraph: bool = False,\n    ) -&gt; Markup:\n        \"\"\"Render Markdown text; for use inside templates.\n\n        Arguments:\n            text: The text to convert.\n            heading_level: The base heading level to start all Markdown headings from.\n            html_id: The HTML id of the element that's considered the parent of this element.\n            strip_paragraph: Whether to exclude the &lt;p&gt; tag from around the whole output.\n\n        Returns:\n            An HTML string.\n        \"\"\"\n        treeprocessors = self._md.treeprocessors\n        treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = heading_level  # type: ignore[attr-defined]\n        treeprocessors[IdPrependingTreeprocessor.name].id_prefix = html_id and html_id + \"--\"  # type: ignore[attr-defined]\n        treeprocessors[ParagraphStrippingTreeprocessor.name].strip = strip_paragraph  # type: ignore[attr-defined]\n        try:\n            return Markup(self._md.convert(text))\n        finally:\n            treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = 0  # type: ignore[attr-defined]\n            treeprocessors[IdPrependingTreeprocessor.name].id_prefix = \"\"  # type: ignore[attr-defined]\n            treeprocessors[ParagraphStrippingTreeprocessor.name].strip = False  # type: ignore[attr-defined]\n            self._md.reset()\n\n    def do_heading(\n        self,\n        content: Markup,\n        heading_level: int,\n        *,\n        role: str | None = None,\n        hidden: bool = False,\n        toc_label: str | None = None,\n        **attributes: str,\n    ) -&gt; Markup:\n        \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates.\n\n        Arguments:\n            content: The HTML within the heading.\n            heading_level: The level of heading (e.g. 3 -&gt; `h3`).\n            role: An optional role for the object bound to this heading.\n            hidden: If True, only register it for the table of contents, don't render anything.\n            toc_label: The title to use in the table of contents ('data-toc-label' attribute).\n            **attributes: Any extra HTML attributes of the heading.\n\n        Returns:\n            An HTML string.\n        \"\"\"\n        # First, produce the \"fake\" heading, for ToC only.\n        el = Element(f\"h{heading_level}\", attributes)\n        if toc_label is None:\n            toc_label = content.unescape() if isinstance(content, Markup) else content\n        el.set(\"data-toc-label\", toc_label)\n        if role:\n            el.set(\"data-role\", role)\n        self._headings.append(el)\n\n        if hidden:\n            return Markup('&lt;a id=\"{0}\"&gt;&lt;/a&gt;').format(attributes[\"id\"])\n\n        # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading.\n        # Start with a heading that has just attributes (no text), and add a placeholder into it.\n        el = Element(f\"h{heading_level}\", attributes)\n        el.append(Element(\"mkdocstrings-placeholder\"))\n        # Tell the 'toc' extension to make its additions if configured so.\n        toc = cast(TocTreeprocessor, self._md.treeprocessors[\"toc\"])\n        if toc.use_anchors:\n            toc.add_anchor(el, attributes[\"id\"])\n        if toc.use_permalinks:\n            toc.add_permalink(el, attributes[\"id\"])\n\n        # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle\n        # of the heading with a placeholder that can never occur (text can't directly contain angle brackets).\n        # Now this HTML wrapper can be \"filled\" by replacing the placeholder.\n        html_with_placeholder = tostring(el, encoding=\"unicode\")\n        assert (  # noqa: S101\n            html_with_placeholder.count(\"&lt;mkdocstrings-placeholder /&gt;\") == 1\n        ), f\"Bug in mkdocstrings: failed to replace in {html_with_placeholder!r}\"\n        html = html_with_placeholder.replace(\"&lt;mkdocstrings-placeholder /&gt;\", content)\n        return Markup(html)\n\n    def get_headings(self) -&gt; Sequence[Element]:\n        \"\"\"Return and clear the headings gathered so far.\n\n        Returns:\n            A list of HTML elements.\n        \"\"\"\n        result = list(self._headings)\n        self._headings.clear()\n        return result\n\n    def update_env(self, md: Markdown, config: dict) -&gt; None:  # noqa: ARG002\n        \"\"\"Update the Jinja environment.\n\n        Arguments:\n            md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.\n            config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n                of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n        \"\"\"\n        self._md = md\n        self.env.filters[\"highlight\"] = Highlighter(md).highlight\n        self.env.filters[\"convert_markdown\"] = self.do_convert_markdown\n        self.env.filters[\"heading\"] = self.do_heading\n\n    def _update_env(self, md: Markdown, config: dict) -&gt; None:\n        \"\"\"Update our handler to point to our configured Markdown instance, grabbing some of the config from `md`.\"\"\"\n        extensions = config[\"mdx\"] + [MkdocstringsInnerExtension(self._headings)]\n\n        new_md = Markdown(extensions=extensions, extension_configs=config[\"mdx_configs\"])\n        # MkDocs adds its own (required) extension that's not part of the config. Propagate it.\n        if \"relpath\" in md.treeprocessors:\n            new_md.treeprocessors.register(md.treeprocessors[\"relpath\"], \"relpath\", priority=0)\n\n        self.update_env(new_md, config)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.domain","title":"<code>domain: str = 'default'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The handler's domain, used to register objects in the inventory, for example \"py\".</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.enable_inventory","title":"<code>enable_inventory: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the inventory creation is enabled.</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.extra_css","title":"<code>extra_css = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extra CSS.</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.fallback_config","title":"<code>fallback_config: dict = {}</code>  <code>class-attribute</code>","text":"<p>Fallback configuration when searching anchors for identifiers.</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.fallback_theme","title":"<code>fallback_theme: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fallback theme to use when a template isn't found in the configured theme.</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.name","title":"<code>name: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The handler's name, for example \"python\".</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.__init__","title":"<code>__init__(handler, theme, custom_templates=None)</code>","text":"<p>Initialize the object.</p> <p>If the given theme is not supported (it does not exist), it will look for a <code>fallback_theme</code> attribute in <code>self</code> to use as a fallback theme.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str</code> <p>The name of the handler.</p> required <code>theme</code> <code>str</code> <p>The name of theme to use.</p> required <code>custom_templates</code> <code>str | None</code> <p>Directory containing custom templates.</p> <code>None</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def __init__(self, handler: str, theme: str, custom_templates: str | None = None) -&gt; None:\n    \"\"\"Initialize the object.\n\n    If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute\n    in `self` to use as a fallback theme.\n\n    Arguments:\n        handler: The name of the handler.\n        theme: The name of theme to use.\n        custom_templates: Directory containing custom templates.\n    \"\"\"\n    paths = []\n\n    # add selected theme templates\n    themes_dir = self.get_templates_dir(handler)\n    paths.append(themes_dir / theme)\n\n    # add extended theme templates\n    extended_templates_dirs = self.get_extended_templates_dirs(handler)\n    for templates_dir in extended_templates_dirs:\n        paths.append(templates_dir / theme)\n\n    # add fallback theme templates\n    if self.fallback_theme and self.fallback_theme != theme:\n        paths.append(themes_dir / self.fallback_theme)\n\n        # add fallback theme of extended templates\n        for templates_dir in extended_templates_dirs:\n            paths.append(templates_dir / self.fallback_theme)\n\n    for path in paths:\n        css_path = path / \"style.css\"\n        if css_path.is_file():\n            self.extra_css += \"\\n\" + css_path.read_text(encoding=\"utf-8\")\n            break\n\n    if custom_templates is not None:\n        paths.insert(0, Path(custom_templates) / handler / theme)\n\n    self.env = Environment(\n        autoescape=True,\n        loader=FileSystemLoader(paths),\n        auto_reload=False,  # Editing a template in the middle of a build is not useful.\n    )\n    self.env.filters[\"any\"] = do_any\n    self.env.globals[\"log\"] = get_template_logger()\n\n    self._headings: list[Element] = []\n    self._md: Markdown = None  # type: ignore[assignment]  # To be populated in `update_env`.\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.collect","title":"<code>collect(identifier, config)</code>","text":"<p>Collect data given an identifier and user configuration.</p> <p>In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice.</p> required <code>config</code> <code>MutableMapping[str, Any]</code> <p>The handler's configuration options.</p> required <p>Returns:</p> Type Description <code>CollectorItem</code> <p>Anything you want, as long as you can feed it to the handler's <code>render</code> method.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def collect(self, identifier: str, config: MutableMapping[str, Any]) -&gt; CollectorItem:\n    \"\"\"Collect data given an identifier and user configuration.\n\n    In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into\n    a Python dictionary for example, though the implementation is completely free.\n\n    Arguments:\n        identifier: An identifier for which to collect data. For example, in Python,\n            it would be 'mkdocstrings.handlers' to collect documentation about the handlers module.\n            It can be anything that you can feed to the tool of your choice.\n        config: The handler's configuration options.\n\n    Returns:\n        Anything you want, as long as you can feed it to the handler's `render` method.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.do_convert_markdown","title":"<code>do_convert_markdown(text, heading_level, html_id='', *, strip_paragraph=False)</code>","text":"<p>Render Markdown text; for use inside templates.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to convert.</p> required <code>heading_level</code> <code>int</code> <p>The base heading level to start all Markdown headings from.</p> required <code>html_id</code> <code>str</code> <p>The HTML id of the element that's considered the parent of this element.</p> <code>''</code> <code>strip_paragraph</code> <code>bool</code> <p>Whether to exclude the <p> tag from around the whole output.</p> <code>False</code> <p>Returns:</p> Type Description <code>Markup</code> <p>An HTML string.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_convert_markdown(\n    self,\n    text: str,\n    heading_level: int,\n    html_id: str = \"\",\n    *,\n    strip_paragraph: bool = False,\n) -&gt; Markup:\n    \"\"\"Render Markdown text; for use inside templates.\n\n    Arguments:\n        text: The text to convert.\n        heading_level: The base heading level to start all Markdown headings from.\n        html_id: The HTML id of the element that's considered the parent of this element.\n        strip_paragraph: Whether to exclude the &lt;p&gt; tag from around the whole output.\n\n    Returns:\n        An HTML string.\n    \"\"\"\n    treeprocessors = self._md.treeprocessors\n    treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = heading_level  # type: ignore[attr-defined]\n    treeprocessors[IdPrependingTreeprocessor.name].id_prefix = html_id and html_id + \"--\"  # type: ignore[attr-defined]\n    treeprocessors[ParagraphStrippingTreeprocessor.name].strip = strip_paragraph  # type: ignore[attr-defined]\n    try:\n        return Markup(self._md.convert(text))\n    finally:\n        treeprocessors[HeadingShiftingTreeprocessor.name].shift_by = 0  # type: ignore[attr-defined]\n        treeprocessors[IdPrependingTreeprocessor.name].id_prefix = \"\"  # type: ignore[attr-defined]\n        treeprocessors[ParagraphStrippingTreeprocessor.name].strip = False  # type: ignore[attr-defined]\n        self._md.reset()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.do_heading","title":"<code>do_heading(content, heading_level, *, role=None, hidden=False, toc_label=None, **attributes)</code>","text":"<p>Render an HTML heading and register it for the table of contents. For use inside templates.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Markup</code> <p>The HTML within the heading.</p> required <code>heading_level</code> <code>int</code> <p>The level of heading (e.g. 3 -&gt; <code>h3</code>).</p> required <code>role</code> <code>str | None</code> <p>An optional role for the object bound to this heading.</p> <code>None</code> <code>hidden</code> <code>bool</code> <p>If True, only register it for the table of contents, don't render anything.</p> <code>False</code> <code>toc_label</code> <code>str | None</code> <p>The title to use in the table of contents ('data-toc-label' attribute).</p> <code>None</code> <code>**attributes</code> <code>str</code> <p>Any extra HTML attributes of the heading.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Markup</code> <p>An HTML string.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_heading(\n    self,\n    content: Markup,\n    heading_level: int,\n    *,\n    role: str | None = None,\n    hidden: bool = False,\n    toc_label: str | None = None,\n    **attributes: str,\n) -&gt; Markup:\n    \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates.\n\n    Arguments:\n        content: The HTML within the heading.\n        heading_level: The level of heading (e.g. 3 -&gt; `h3`).\n        role: An optional role for the object bound to this heading.\n        hidden: If True, only register it for the table of contents, don't render anything.\n        toc_label: The title to use in the table of contents ('data-toc-label' attribute).\n        **attributes: Any extra HTML attributes of the heading.\n\n    Returns:\n        An HTML string.\n    \"\"\"\n    # First, produce the \"fake\" heading, for ToC only.\n    el = Element(f\"h{heading_level}\", attributes)\n    if toc_label is None:\n        toc_label = content.unescape() if isinstance(content, Markup) else content\n    el.set(\"data-toc-label\", toc_label)\n    if role:\n        el.set(\"data-role\", role)\n    self._headings.append(el)\n\n    if hidden:\n        return Markup('&lt;a id=\"{0}\"&gt;&lt;/a&gt;').format(attributes[\"id\"])\n\n    # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading.\n    # Start with a heading that has just attributes (no text), and add a placeholder into it.\n    el = Element(f\"h{heading_level}\", attributes)\n    el.append(Element(\"mkdocstrings-placeholder\"))\n    # Tell the 'toc' extension to make its additions if configured so.\n    toc = cast(TocTreeprocessor, self._md.treeprocessors[\"toc\"])\n    if toc.use_anchors:\n        toc.add_anchor(el, attributes[\"id\"])\n    if toc.use_permalinks:\n        toc.add_permalink(el, attributes[\"id\"])\n\n    # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle\n    # of the heading with a placeholder that can never occur (text can't directly contain angle brackets).\n    # Now this HTML wrapper can be \"filled\" by replacing the placeholder.\n    html_with_placeholder = tostring(el, encoding=\"unicode\")\n    assert (  # noqa: S101\n        html_with_placeholder.count(\"&lt;mkdocstrings-placeholder /&gt;\") == 1\n    ), f\"Bug in mkdocstrings: failed to replace in {html_with_placeholder!r}\"\n    html = html_with_placeholder.replace(\"&lt;mkdocstrings-placeholder /&gt;\", content)\n    return Markup(html)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.get_anchors","title":"<code>get_anchors(data)</code>","text":"<p>Return the possible identifiers (HTML anchors) for a collected item.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CollectorItem</code> <p>The collected data.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_anchors(self, data: CollectorItem) -&gt; tuple[str, ...]:\n    \"\"\"Return the possible identifiers (HTML anchors) for a collected item.\n\n    Arguments:\n        data: The collected data.\n\n    Returns:\n        The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.\n    \"\"\"\n    # TODO: remove this when https://github.com/mkdocstrings/crystal/pull/6 is merged and released\n    try:\n        return (self.get_anchor(data),)  # type: ignore[attr-defined]\n    except AttributeError:\n        return ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.get_extended_templates_dirs","title":"<code>get_extended_templates_dirs(handler)</code>","text":"<p>Load template extensions for the given handler, return their templates directories.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str</code> <p>The name of the handler to get the extended templates directory of.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>The extensions templates directories.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_extended_templates_dirs(self, handler: str) -&gt; list[Path]:\n    \"\"\"Load template extensions for the given handler, return their templates directories.\n\n    Arguments:\n        handler: The name of the handler to get the extended templates directory of.\n\n    Returns:\n        The extensions templates directories.\n    \"\"\"\n    discovered_extensions = entry_points(group=f\"mkdocstrings.{handler}.templates\")\n    return [extension.load()() for extension in discovered_extensions]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.get_headings","title":"<code>get_headings()</code>","text":"<p>Return and clear the headings gathered so far.</p> <p>Returns:</p> Type Description <code>Sequence[Element]</code> <p>A list of HTML elements.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_headings(self) -&gt; Sequence[Element]:\n    \"\"\"Return and clear the headings gathered so far.\n\n    Returns:\n        A list of HTML elements.\n    \"\"\"\n    result = list(self._headings)\n    self._headings.clear()\n    return result\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.get_templates_dir","title":"<code>get_templates_dir(handler=None)</code>","text":"<p>Return the path to the handler's templates directory.</p> <p>Override to customize how the templates directory is found.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str | None</code> <p>The name of the handler to get the templates directory of.</p> <code>None</code> <p>Raises:</p> Type Description <code>ModuleNotFoundError</code> <p>When no such handler is installed.</p> <code>FileNotFoundError</code> <p>When the templates directory cannot be found.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The templates directory path.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_templates_dir(self, handler: str | None = None) -&gt; Path:\n    \"\"\"Return the path to the handler's templates directory.\n\n    Override to customize how the templates directory is found.\n\n    Arguments:\n        handler: The name of the handler to get the templates directory of.\n\n    Raises:\n        ModuleNotFoundError: When no such handler is installed.\n        FileNotFoundError: When the templates directory cannot be found.\n\n    Returns:\n        The templates directory path.\n    \"\"\"\n    handler = handler or self.name\n    try:\n        import mkdocstrings_handlers\n    except ModuleNotFoundError as error:\n        raise ModuleNotFoundError(f\"Handler '{handler}' not found, is it installed?\") from error\n\n    for path in mkdocstrings_handlers.__path__:\n        theme_path = Path(path, handler, \"templates\")\n        if theme_path.exists():\n            return theme_path\n\n    raise FileNotFoundError(f\"Can't find 'templates' folder for handler '{handler}'\")\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.load_inventory","title":"<code>load_inventory(in_file, url, base_url=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Yield items and their URLs from an inventory file streamed from <code>in_file</code>.</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>BinaryIO</code> <p>The binary file-like object to read the inventory from.</p> required <code>url</code> <code>str</code> <p>The URL that this file is being streamed from (used to guess <code>base_url</code>).</p> required <code>base_url</code> <code>str | None</code> <p>The URL that this inventory's sub-paths are relative to.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Ignore additional arguments passed from the config.</p> <code>{}</code> <p>Yields:</p> Type Description <code>str</code> <p>Tuples of (item identifier, item URL).</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>@classmethod\ndef load_inventory(\n    cls,\n    in_file: BinaryIO,  # noqa: ARG003\n    url: str,  # noqa: ARG003\n    base_url: str | None = None,  # noqa: ARG003\n    **kwargs: Any,  # noqa: ARG003\n) -&gt; Iterator[tuple[str, str]]:\n    \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`.\n\n    Arguments:\n        in_file: The binary file-like object to read the inventory from.\n        url: The URL that this file is being streamed from (used to guess `base_url`).\n        base_url: The URL that this inventory's sub-paths are relative to.\n        **kwargs: Ignore additional arguments passed from the config.\n\n    Yields:\n        Tuples of (item identifier, item URL).\n    \"\"\"\n    yield from ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.render","title":"<code>render(data, config)</code>","text":"<p>Render a template using provided data and configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CollectorItem</code> <p>The collected data to render.</p> required <code>config</code> <code>Mapping[str, Any]</code> <p>The handler's configuration options.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The rendered template as HTML.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def render(self, data: CollectorItem, config: Mapping[str, Any]) -&gt; str:\n    \"\"\"Render a template using provided data and configuration options.\n\n    Arguments:\n        data: The collected data to render.\n        config: The handler's configuration options.\n\n    Returns:\n        The rendered template as HTML.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.teardown","title":"<code>teardown()</code>","text":"<p>Teardown the handler.</p> <p>This method should be implemented to, for example, terminate a subprocess that was started when creating the handler instance.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Teardown the handler.\n\n    This method should be implemented to, for example, terminate a subprocess\n    that was started when creating the handler instance.\n    \"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.update_env","title":"<code>update_env(md, config)</code>","text":"<p>Update the Jinja environment.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Markdown</code> <p>The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.</p> required <code>config</code> <code>dict</code> <p>Configuration options for <code>mkdocs</code> and <code>mkdocstrings</code>, read from <code>mkdocs.yml</code>. See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def update_env(self, md: Markdown, config: dict) -&gt; None:  # noqa: ARG002\n    \"\"\"Update the Jinja environment.\n\n    Arguments:\n        md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.\n        config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n            of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n    \"\"\"\n    self._md = md\n    self.env.filters[\"highlight\"] = Highlighter(md).highlight\n    self.env.filters[\"convert_markdown\"] = self.do_convert_markdown\n    self.env.filters[\"heading\"] = self.do_heading\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.CollectionError","title":"<code>CollectionError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An exception raised when some collection of data failed.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class CollectionError(Exception):\n    \"\"\"An exception raised when some collection of data failed.\"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers","title":"<code>Handlers</code>","text":"<p>A collection of handlers.</p> <p>Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class Handlers:\n    \"\"\"A collection of handlers.\n\n    Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of\n    this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access.\n    \"\"\"\n\n    def __init__(self, config: dict) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n                of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n        \"\"\"\n        self._config = config\n        self._handlers: dict[str, BaseHandler] = {}\n        self.inventory: Inventory = Inventory(project=self._config[\"mkdocs\"][\"site_name\"])\n\n    def get_anchors(self, identifier: str) -&gt; tuple[str, ...]:\n        \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.\n\n        Arguments:\n            identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseHandler.collect] can accept).\n\n        Returns:\n            A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.\n        \"\"\"\n        for handler in self._handlers.values():\n            fallback_config = getattr(handler, \"fallback_config\", {})\n            try:\n                anchors = handler.get_anchors(handler.collect(identifier, fallback_config))\n            except CollectionError:\n                continue\n            if anchors:\n                return anchors\n        return ()\n\n    def get_handler_name(self, config: dict) -&gt; str:\n        \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.\n\n        Arguments:\n            config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.\n\n        Returns:\n            The name of the handler to use.\n        \"\"\"\n        global_config = self._config[\"mkdocstrings\"]\n        if \"handler\" in config:\n            return config[\"handler\"]\n        return global_config[\"default_handler\"]\n\n    def get_handler_config(self, name: str) -&gt; dict:\n        \"\"\"Return the global configuration of the given handler.\n\n        Arguments:\n            name: The name of the handler to get the global configuration of.\n\n        Returns:\n            The global configuration of the given handler. It can be an empty dictionary.\n        \"\"\"\n        handlers = self._config[\"mkdocstrings\"].get(\"handlers\", {})\n        if handlers:\n            return handlers.get(name, {})\n        return {}\n\n    def get_handler(self, name: str, handler_config: dict | None = None) -&gt; BaseHandler:\n        \"\"\"Get a handler thanks to its name.\n\n        This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its\n        `get_handler` method to get an instance of a handler, and caches it in dictionary.\n        It means that during one run (for each reload when serving, or once when building),\n        a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.\n\n        Arguments:\n            name: The name of the handler. Really, it's the name of the Python module holding it.\n            handler_config: Configuration passed to the handler.\n\n        Returns:\n            An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler],\n                as instantiated by the `get_handler` method of the handler's module.\n        \"\"\"\n        if name not in self._handlers:\n            if handler_config is None:\n                handler_config = self.get_handler_config(name)\n            handler_config.update(self._config)\n            module = importlib.import_module(f\"mkdocstrings_handlers.{name}\")\n            self._handlers[name] = module.get_handler(\n                theme=self._config[\"theme_name\"],\n                custom_templates=self._config[\"mkdocstrings\"][\"custom_templates\"],\n                config_file_path=self._config[\"mkdocs\"][\"config_file_path\"],\n                **handler_config,\n            )\n        return self._handlers[name]\n\n    @property\n    def seen_handlers(self) -&gt; Iterable[BaseHandler]:\n        \"\"\"Get the handlers that were encountered so far throughout the build.\n\n        Returns:\n            An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]\n            (usable only to loop through it).\n        \"\"\"\n        return self._handlers.values()\n\n    def teardown(self) -&gt; None:\n        \"\"\"Teardown all cached handlers and clear the cache.\"\"\"\n        for handler in self.seen_handlers:\n            handler.teardown()\n        self._handlers.clear()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.seen_handlers","title":"<code>seen_handlers: Iterable[BaseHandler]</code>  <code>property</code>","text":"<p>Get the handlers that were encountered so far throughout the build.</p> <p>Returns:</p> Type Description <code>Iterable[BaseHandler]</code> <p>An iterable of instances of <code>BaseHandler</code></p> <code>Iterable[BaseHandler]</code> <p>(usable only to loop through it).</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Configuration options for <code>mkdocs</code> and <code>mkdocstrings</code>, read from <code>mkdocs.yml</code>. See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def __init__(self, config: dict) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n            of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n    \"\"\"\n    self._config = config\n    self._handlers: dict[str, BaseHandler] = {}\n    self.inventory: Inventory = Inventory(project=self._config[\"mkdocs\"][\"site_name\"])\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_anchors","title":"<code>get_anchors(identifier)</code>","text":"<p>Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier (one that collect can accept).</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_anchors(self, identifier: str) -&gt; tuple[str, ...]:\n    \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.\n\n    Arguments:\n        identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseHandler.collect] can accept).\n\n    Returns:\n        A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.\n    \"\"\"\n    for handler in self._handlers.values():\n        fallback_config = getattr(handler, \"fallback_config\", {})\n        try:\n            anchors = handler.get_anchors(handler.collect(identifier, fallback_config))\n        except CollectionError:\n            continue\n        if anchors:\n            return anchors\n    return ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler","title":"<code>get_handler(name, handler_config=None)</code>","text":"<p>Get a handler thanks to its name.</p> <p>This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its <code>get_handler</code> method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the handler. Really, it's the name of the Python module holding it.</p> required <code>handler_config</code> <code>dict | None</code> <p>Configuration passed to the handler.</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseHandler</code> <p>An instance of a subclass of <code>BaseHandler</code>, as instantiated by the <code>get_handler</code> method of the handler's module.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler(self, name: str, handler_config: dict | None = None) -&gt; BaseHandler:\n    \"\"\"Get a handler thanks to its name.\n\n    This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its\n    `get_handler` method to get an instance of a handler, and caches it in dictionary.\n    It means that during one run (for each reload when serving, or once when building),\n    a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.\n\n    Arguments:\n        name: The name of the handler. Really, it's the name of the Python module holding it.\n        handler_config: Configuration passed to the handler.\n\n    Returns:\n        An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler],\n            as instantiated by the `get_handler` method of the handler's module.\n    \"\"\"\n    if name not in self._handlers:\n        if handler_config is None:\n            handler_config = self.get_handler_config(name)\n        handler_config.update(self._config)\n        module = importlib.import_module(f\"mkdocstrings_handlers.{name}\")\n        self._handlers[name] = module.get_handler(\n            theme=self._config[\"theme_name\"],\n            custom_templates=self._config[\"mkdocstrings\"][\"custom_templates\"],\n            config_file_path=self._config[\"mkdocs\"][\"config_file_path\"],\n            **handler_config,\n        )\n    return self._handlers[name]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_config","title":"<code>get_handler_config(name)</code>","text":"<p>Return the global configuration of the given handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the handler to get the global configuration of.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The global configuration of the given handler. It can be an empty dictionary.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler_config(self, name: str) -&gt; dict:\n    \"\"\"Return the global configuration of the given handler.\n\n    Arguments:\n        name: The name of the handler to get the global configuration of.\n\n    Returns:\n        The global configuration of the given handler. It can be an empty dictionary.\n    \"\"\"\n    handlers = self._config[\"mkdocstrings\"].get(\"handlers\", {})\n    if handlers:\n        return handlers.get(name, {})\n    return {}\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_name","title":"<code>get_handler_name(config)</code>","text":"<p>Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the handler to use.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler_name(self, config: dict) -&gt; str:\n    \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.\n\n    Arguments:\n        config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.\n\n    Returns:\n        The name of the handler to use.\n    \"\"\"\n    global_config = self._config[\"mkdocstrings\"]\n    if \"handler\" in config:\n        return config[\"handler\"]\n    return global_config[\"default_handler\"]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.teardown","title":"<code>teardown()</code>","text":"<p>Teardown all cached handlers and clear the cache.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Teardown all cached handlers and clear the cache.\"\"\"\n    for handler in self.seen_handlers:\n        handler.teardown()\n    self._handlers.clear()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.ThemeNotSupported","title":"<code>ThemeNotSupported</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An exception raised to tell a theme is not supported.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class ThemeNotSupported(Exception):  # noqa: N818\n    \"\"\"An exception raised to tell a theme is not supported.\"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.do_any","title":"<code>do_any(seq, attribute=None)</code>","text":"<p>Check if at least one of the item in the sequence evaluates to true.</p> <p>The <code>any</code> builtin as a filter for Jinja templates.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>Sequence</code> <p>An iterable object.</p> required <code>attribute</code> <code>str | None</code> <p>The attribute name to use on each object of the iterable.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean telling if any object of the iterable evaluated to True.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_any(seq: Sequence, attribute: str | None = None) -&gt; bool:\n    \"\"\"Check if at least one of the item in the sequence evaluates to true.\n\n    The `any` builtin as a filter for Jinja templates.\n\n    Arguments:\n        seq: An iterable object.\n        attribute: The attribute name to use on each object of the iterable.\n\n    Returns:\n        A boolean telling if any object of the iterable evaluated to True.\n    \"\"\"\n    if attribute is None:\n        return any(seq)\n    return any(_[attribute] for _ in seq)\n</code></pre>"},{"location":"housekeeping/","title":"Housekeeping","text":""},{"location":"housekeeping/#releasing","title":"Releasing","text":"<p>Release is fully automated and you just need to run the Release workflow. Versioning is automatic and guessed from Conventional Commit history.</p>"},{"location":"housekeeping/#stable-release","title":"Stable release","text":"<ol> <li>Go to the Release workflow</li> <li>Properly select the target branch (given our process, the default <code>main</code> is correct)</li> <li>Optional: manually select a kind of increment (<code>MAJOR</code>, <code>MINOR</code>, <code>PATCH</code>) if you don't want to rely on automatic versioning</li> <li>Run the workflow</li> </ol>"},{"location":"housekeeping/#pre-release","title":"Pre-release","text":"<ol> <li>Go to the Release workflow</li> <li>Properly select the target branch (given our process, the default <code>main</code> is correct)</li> <li>Select the pre-release type (<code>alpha</code>, <code>beta</code> or <code>rc</code>)</li> <li>Run the workflow</li> </ol>"},{"location":"mermaid/","title":"Mermaid","text":"<p>See Material for MkDocs diagrams documentation for a complete reference.</p> <p>Those examples are extracted from the Mermaid documentation and are the most complexes found to showcase all styles and possibilities.</p> <p>Some have a <code>Syntax error in graph</code> instead of the diagram: it means that <code>mkdocs-material</code>'s <code>mermaid.js</code> version does not support them yet.</p>"},{"location":"mermaid/#flowchart","title":"Flowchart","text":"<pre><code>flowchart LR\n    A[Hard edge] --&gt;|Link text| B(Round edge)\n    B --&gt; C{Decision}\n    C --&gt;|One| D[Result one]\n    C --&gt;|Two| E[Result two]</code></pre>"},{"location":"mermaid/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n    par Alice to Bob\n        Alice-&gt;&gt;Bob: Go help John\n    and Alice to John\n        Alice-&gt;&gt;John: I want this done today\n        par John to Charlie\n            John-&gt;&gt;Charlie: Can we do this today?\n        and John to Diana\n            John-&gt;&gt;Diana: Can you help us today?\n        end\n    end</code></pre>"},{"location":"mermaid/#class-diagram","title":"Class diagram","text":"<pre><code>---\ntitle: Animal example\n---\nclassDiagram\n    note \"From Duck till Zebra\"\n    Animal &lt;|-- Duck\n    note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\n    Animal &lt;|-- Fish\n    Animal &lt;|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }</code></pre>"},{"location":"mermaid/#state-diagram","title":"State diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Active\n\n    state Active {\n        [*] --&gt; NumLockOff\n        NumLockOff --&gt; NumLockOn : EvNumLockPressed\n        NumLockOn --&gt; NumLockOff : EvNumLockPressed\n        --\n        [*] --&gt; CapsLockOff\n        CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed\n        CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed\n        --\n        [*] --&gt; ScrollLockOff\n        ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed\n    }</code></pre>"},{"location":"mermaid/#entity-relationship-diagram","title":"Entity Relationship diagram","text":"<pre><code>erDiagram\n    CAR ||--o{ NAMED-DRIVER : allows\n    CAR {\n        string registrationNumber PK\n        string make\n        string model\n        string[] parts\n    }\n    PERSON ||--o{ NAMED-DRIVER : is\n    PERSON {\n        string driversLicense PK \"The license #\"\n        string(99) firstName \"Only 99 characters are allowed\"\n        string lastName\n        string phone UK\n        int age\n    }\n    NAMED-DRIVER {\n        string carRegistrationNumber PK, FK\n        string driverLicence PK, FK\n    }\n    MANUFACTURER only one to zero or more CAR : makes</code></pre>"},{"location":"mermaid/#gantt","title":"Gantt","text":"<pre><code>gantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :1d\n    Functionality added                 :milestone, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h</code></pre>"},{"location":"mermaid/#pie-chart","title":"Pie Chart","text":"<pre><code>%%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%%\npie showData\n    title Key elements in Product X\n    \"Calcium\" : 42.96\n    \"Potassium\" : 50.05\n    \"Magnesium\" : 10.01\n    \"Iron\" :  5</code></pre>"},{"location":"mermaid/#requirement-diagram","title":"Requirement Diagram","text":"<pre><code> requirementDiagram\n\n    requirement test_req {\n    id: 1\n    text: the test text.\n    risk: high\n    verifymethod: test\n    }\n\n    functionalRequirement test_req2 {\n    id: 1.1\n    text: the second test text.\n    risk: low\n    verifymethod: inspection\n    }\n\n    performanceRequirement test_req3 {\n    id: 1.2\n    text: the third test text.\n    risk: medium\n    verifymethod: demonstration\n    }\n\n    interfaceRequirement test_req4 {\n    id: 1.2.1\n    text: the fourth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    physicalRequirement test_req5 {\n    id: 1.2.2\n    text: the fifth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    designConstraint test_req6 {\n    id: 1.2.3\n    text: the sixth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    element test_entity {\n    type: simulation\n    }\n\n    element test_entity2 {\n    type: word doc\n    docRef: reqs/test_entity\n    }\n\n    element test_entity3 {\n    type: \"test suite\"\n    docRef: github.com/all_the_tests\n    }\n\n\n    test_entity - satisfies -&gt; test_req2\n    test_req - traces -&gt; test_req2\n    test_req - contains -&gt; test_req3\n    test_req3 - contains -&gt; test_req4\n    test_req4 - derives -&gt; test_req5\n    test_req5 - refines -&gt; test_req6\n    test_entity3 - verifies -&gt; test_req5\n    test_req &lt;- copies - test_entity2</code></pre>"},{"location":"mermaid/#gitgraph","title":"GitGraph","text":"<pre><code>gitGraph:\n    commit \"Ashish\"\n    branch newbranch\n    checkout newbranch\n    commit id:\"1111\"\n    commit tag:\"test\"\n    checkout main\n    commit type: HIGHLIGHT\n    commit\n    merge newbranch\n    commit\n    branch b2\n    commit</code></pre>"},{"location":"mermaid/#c4-diagrams","title":"C4 Diagrams","text":""},{"location":"mermaid/#system-context","title":"System Context","text":"<pre><code>  C4Context\n      title System Context diagram for Internet Banking System\n      Enterprise_Boundary(b0, \"BankBoundary0\") {\n        Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\")\n        Person(customerB, \"Banking Customer B\")\n        Person_Ext(customerC, \"Banking Customer C\", \"desc\")\n\n        Person(customerD, \"Banking Customer D\", \"A customer of the bank, &lt;br/&gt; with personal bank accounts.\")\n\n        System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\")\n\n        Enterprise_Boundary(b1, \"BankBoundary\") {\n\n          SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n          System_Boundary(b2, \"BankBoundary2\") {\n            System(SystemA, \"Banking System A\")\n            System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\")\n          }\n\n          System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\")\n          SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\")\n\n          Boundary(b3, \"BankBoundary3\", \"boundary\") {\n            SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\")\n            SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\")\n          }\n        }\n      }\n\n      BiRel(customerA, SystemAA, \"Uses\")\n      BiRel(SystemAA, SystemE, \"Uses\")\n      Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\")\n      Rel(SystemC, customerA, \"Sends e-mails to\")\n\n      UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\")\n      UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\")\n      UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\")\n      UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\")\n      UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\")\n\n      UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")</code></pre>"},{"location":"mermaid/#container","title":"Container","text":"<pre><code>    C4Container\n    title Container diagram for Internet Banking System\n\n    System_Ext(email_system, \"E-Mail System\", \"The internal Microsoft Exchange system\", $tags=\"v1.0\")\n    Person(customer, Customer, \"A customer of the bank, with personal bank accounts\", $tags=\"v1.0\")\n\n    Container_Boundary(c1, \"Internet Banking\") {\n        Container(spa, \"Single-Page App\", \"JavaScript, Angular\", \"Provides all the Internet banking functionality to customers via their web browser\")\n        Container_Ext(mobile_app, \"Mobile App\", \"C#, Xamarin\", \"Provides a limited subset of the Internet banking functionality to customers via their mobile device\")\n        Container(web_app, \"Web Application\", \"Java, Spring MVC\", \"Delivers the static content and the Internet banking SPA\")\n        ContainerDb(database, \"Database\", \"SQL Database\", \"Stores user registration information, hashed auth credentials, access logs, etc.\")\n        ContainerDb_Ext(backend_api, \"API Application\", \"Java, Docker Container\", \"Provides Internet banking functionality via API\")\n\n    }\n\n    System_Ext(banking_system, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n    Rel(customer, web_app, \"Uses\", \"HTTPS\")\n    UpdateRelStyle(customer, web_app, $offsetY=\"60\", $offsetX=\"90\")\n    Rel(customer, spa, \"Uses\", \"HTTPS\")\n    UpdateRelStyle(customer, spa, $offsetY=\"-40\")\n    Rel(customer, mobile_app, \"Uses\")\n    UpdateRelStyle(customer, mobile_app, $offsetY=\"-30\")\n\n    Rel(web_app, spa, \"Delivers\")\n    UpdateRelStyle(web_app, spa, $offsetX=\"130\")\n    Rel(spa, backend_api, \"Uses\", \"async, JSON/HTTPS\")\n    Rel(mobile_app, backend_api, \"Uses\", \"async, JSON/HTTPS\")\n    Rel_Back(database, backend_api, \"Reads from and writes to\", \"sync, JDBC\")\n\n    Rel(email_system, customer, \"Sends e-mails to\")\n    UpdateRelStyle(email_system, customer, $offsetX=\"-45\")\n    Rel(backend_api, email_system, \"Sends e-mails using\", \"sync, SMTP\")\n    UpdateRelStyle(backend_api, email_system, $offsetY=\"-60\")\n    Rel(backend_api, banking_system, \"Uses\", \"sync/async, XML/HTTPS\")\n    UpdateRelStyle(backend_api, banking_system, $offsetY=\"-50\", $offsetX=\"-140\")\n\n</code></pre>"},{"location":"mermaid/#component","title":"Component","text":"<pre><code>    C4Component\n    title Component diagram for Internet Banking System - API Application\n\n    Container(spa, \"Single Page Application\", \"javascript and angular\", \"Provides all the internet banking functionality to customers via their web browser.\")\n    Container(ma, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the internet banking functionality to customers via their mobile mobile device.\")\n    ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n    System_Ext(mbs, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n    Container_Boundary(api, \"API Application\") {\n        Component(sign, \"Sign In Controller\", \"MVC Rest Controller\", \"Allows users to sign in to the internet banking system\")\n        Component(accounts, \"Accounts Summary Controller\", \"MVC Rest Controller\", \"Provides customers with a summary of their bank accounts\")\n        Component(security, \"Security Component\", \"Spring Bean\", \"Provides functionality related to singing in, changing passwords, etc.\")\n        Component(mbsfacade, \"Mainframe Banking System Facade\", \"Spring Bean\", \"A facade onto the mainframe banking system.\")\n\n        Rel(sign, security, \"Uses\")\n        Rel(accounts, mbsfacade, \"Uses\")\n        Rel(security, db, \"Read &amp; write to\", \"JDBC\")\n        Rel(mbsfacade, mbs, \"Uses\", \"XML/HTTPS\")\n    }\n\n    Rel_Back(spa, sign, \"Uses\", \"JSON/HTTPS\")\n    Rel(spa, accounts, \"Uses\", \"JSON/HTTPS\")\n\n    Rel(ma, sign, \"Uses\", \"JSON/HTTPS\")\n    Rel(ma, accounts, \"Uses\", \"JSON/HTTPS\")\n\n    UpdateRelStyle(spa, sign, $offsetY=\"-40\")\n    UpdateRelStyle(spa, accounts, $offsetX=\"40\", $offsetY=\"40\")\n\n    UpdateRelStyle(ma, sign, $offsetX=\"-90\", $offsetY=\"40\")\n    UpdateRelStyle(ma, accounts, $offsetY=\"-40\")\n\n        UpdateRelStyle(sign, security, $offsetX=\"-160\", $offsetY=\"10\")\n        UpdateRelStyle(accounts, mbsfacade, $offsetX=\"140\", $offsetY=\"10\")\n        UpdateRelStyle(security, db, $offsetY=\"-40\")\n        UpdateRelStyle(mbsfacade, mbs, $offsetY=\"-40\")\n\n</code></pre>"},{"location":"mermaid/#dynamic","title":"Dynamic","text":"<pre><code>    C4Dynamic\n    title Dynamic diagram for Internet Banking System - API Application\n\n    ContainerDb(c4, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n    Container(c1, \"Single-Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet banking functionality to customers via their web browser.\")\n    Container_Boundary(b, \"API Application\") {\n      Component(c3, \"Security Component\", \"Spring Bean\", \"Provides functionality Related to signing in, changing passwords, etc.\")\n      Component(c2, \"Sign In Controller\", \"Spring MVC Rest Controller\", \"Allows users to sign in to the Internet Banking System.\")\n    }\n    Rel(c1, c2, \"Submits credentials to\", \"JSON/HTTPS\")\n    Rel(c2, c3, \"Calls isAuthenticated() on\")\n    Rel(c3, c4, \"select * from users where username = ?\", \"JDBC\")\n\n    UpdateRelStyle(c1, c2, $textColor=\"red\", $offsetY=\"-40\")\n    UpdateRelStyle(c2, c3, $textColor=\"red\", $offsetX=\"-40\", $offsetY=\"60\")\n    UpdateRelStyle(c3, c4, $textColor=\"red\", $offsetY=\"-40\", $offsetX=\"10\")\n</code></pre>"},{"location":"mermaid/#deployment","title":"Deployment","text":"<pre><code>    C4Deployment\n    title Deployment Diagram for Internet Banking System - Live\n\n    Deployment_Node(mob, \"Customer's mobile device\", \"Apple IOS or Android\"){\n        Container(mobile, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the Internet Banking functionality to customers via their mobile device.\")\n    }\n\n    Deployment_Node(comp, \"Customer's computer\", \"Microsoft Windows or Apple macOS\"){\n        Deployment_Node(browser, \"Web Browser\", \"Google Chrome, Mozilla Firefox,&lt;br/&gt; Apple Safari or Microsoft Edge\"){\n            Container(spa, \"Single Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet Banking functionality to customers via their web browser.\")\n        }\n    }\n\n    Deployment_Node(plc, \"Big Bank plc\", \"Big Bank plc data center\"){\n        Deployment_Node(dn, \"bigbank-api*** x8\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(apache, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){\n                Container(api, \"API Application\", \"Java and Spring MVC\", \"Provides Internet Banking functionality via a JSON/HTTPS API.\")\n            }\n        }\n        Deployment_Node(bb2, \"bigbank-web*** x4\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(apache2, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){\n                Container(web, \"Web Application\", \"Java and Spring MVC\", \"Delivers the static content and the Internet Banking single page application.\")\n            }\n        }\n        Deployment_Node(bigbankdb01, \"bigbank-db01\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(oracle, \"Oracle - Primary\", \"Oracle 12c\"){\n                ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n            }\n        }\n        Deployment_Node(bigbankdb02, \"bigbank-db02\", \"Ubuntu 16.04 LTS\") {\n            Deployment_Node(oracle2, \"Oracle - Secondary\", \"Oracle 12c\") {\n                ContainerDb(db2, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n            }\n        }\n    }\n\n    Rel(mobile, api, \"Makes API calls to\", \"json/HTTPS\")\n    Rel(spa, api, \"Makes API calls to\", \"json/HTTPS\")\n    Rel_U(web, spa, \"Delivers to the customer's web browser\")\n    Rel(api, db, \"Reads from and writes to\", \"JDBC\")\n    Rel(api, db2, \"Reads from and writes to\", \"JDBC\")\n    Rel_R(db, db2, \"Replicates data to\")\n\n    UpdateRelStyle(spa, api, $offsetY=\"-40\")\n    UpdateRelStyle(web, spa, $offsetY=\"-40\")\n    UpdateRelStyle(api, db, $offsetY=\"-20\", $offsetX=\"5\")\n    UpdateRelStyle(api, db2, $offsetX=\"-40\", $offsetY=\"-20\")\n    UpdateRelStyle(db, db2, $offsetY=\"-10\")\n\n</code></pre>"},{"location":"mermaid/#mindmaps","title":"Mindmaps","text":"<pre><code>mindmap\n  root((mindmap))\n    Origins\n      Long history\n      ::icon(fa fa-book)\n      Popularisation\n        British popular psychology author Tony Buzan\n    Research\n      On effectiveness&lt;br/&gt;and features\n      On Automatic creation\n        Uses\n            Creative techniques\n            Strategic planning\n            Argument mapping\n    Tools\n      Pen and paper\n      Mermaid\n</code></pre>"},{"location":"mermaid/#timeline","title":"Timeline","text":"<pre><code>timeline\n    title History of Social Media Platform\n    2002 : LinkedIn\n    2004 : Facebook : Google\n    2005 : Youtube\n    2006 : Twitter</code></pre>"}]}