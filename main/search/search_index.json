{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ledger theme for MkDocs","text":"<p>This site is both a documentation and a showcase for this theme.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Just follow the README steps. Those are</p>"},{"location":"#installation","title":"Installation","text":"<p>Just install <code>mkdocs-ledger</code> from the GemFury repository (this requires credentials). Properly chose the extra depending on what you want to document:</p> <pre><code># Basic installation\npip install mkdocs-ledger\n# Installation with docstring support\npip install mkdocs-ledger[docstrings]\n# Installation with `click` documentation support\npip install mkdocs-ledger[click]\n# Installation with all features\npip install mkdocs-ledger[docstrings,click]\n</code></pre>"},{"location":"#configure-mkdocs","title":"Configure mkdocs","text":"<p>Just use the <code>ledger</code> theme in your <code>mkdocs.yml</code> configuration:</p> <pre><code>theme: ledger\n</code></pre> <p>For docstrings support, use the <code>mkdocstrings</code> plugin (<code>material/search</code> needs to be added too). For click support, use the <code>mkdocs-click</code> markdown plugin.</p> <pre><code>theme: ledger\nmarkdown_extensions:\n- mkdocs-click\nplugins:\n- material/search\n- mkdocstrings\n</code></pre>"},{"location":"#references","title":"References","text":"<p>This theme is based on MkDocs and some extensions so please consult upstream documentations:</p> <ul> <li>MkDocs: the documentation engine</li> <li>Material for MkDocs: the base theme</li> <li>mkdocsstrings: docstrings support</li> <li>mkdocs-click: automatic documentation for Python Click</li> </ul>"},{"location":"#showcase","title":"Showcase","text":""},{"location":"#demo-pages","title":"Demo pages","text":"<p>The following pages are just here to showcase supported features:</p> <ul> <li>docstrings: showcase docstrings support</li> <li>OpenAPI: showcase OpenAPI documentation based on <code>redoc</code>/<code>RedocLy</code></li> <li>Click: showcase <code>click</code> automatic documentation</li> <li>Mermaid: showcase <code>mermaid.js</code> diagrams integration</li> </ul> <p>They are using fake or demo data, most of the time took form their feature official website. If you are hacking this theme, don't hesitarte to use those pages to see the result. If you add support for a specific feature, please add a page showcasing it.</p> <p>Light/Dark mode</p> <p>This theme comes with support for both light and dark mode so don't forget to try both.</p> <p>The toggle button (/) is in the top header on the right.</p>"},{"location":"#known-documentations","title":"Known documentations","text":"<p>You can also take a look at some existing documentations using this theme:</p> <ul> <li>Vault Platform Manager</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#013-2023-06-28","title":"\ud83d\ude80 0.1.3 (2023-06-28)","text":""},{"location":"changelog/#012-2023-06-28","title":"\ud83d\ude80 0.1.2 (2023-06-28)","text":""},{"location":"changelog/#011-2023-06-28","title":"\ud83d\ude80 0.1.1 (2023-06-28)","text":""},{"location":"changelog/#build","title":"\ud83d\udce6 Build","text":"<ul> <li>commitizen: merge prereleases in changelog on bump</li> <li>commitizen: update changelog on bump and pin major to zero until stable</li> </ul>"},{"location":"changelog/#010-2023-06-28","title":"\ud83d\ude80 0.1.0 (2023-06-28)","text":""},{"location":"changelog/#new-features","title":"\ud83d\udcab New features","text":"<ul> <li>Initial import</li> </ul>"},{"location":"changelog/#build_1","title":"\ud83d\udce6 Build","text":"<ul> <li>dev: fix <code>setuptools</code> being silently required</li> <li>apply the <code>python.copier</code> template (partially)</li> </ul>"},{"location":"cli/","title":"Click","text":"<p>This demo site shows the rendering of the MkDocs CLI itself through <code>mkdocs-click</code>.</p>"},{"location":"cli/#cli","title":"cli","text":"<p>MkDocs - Project documentation with Markdown.</p> <p>Usage:</p> <pre><code>cli [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  -V, --version  Show the version and exit.\n  -q, --quiet    Silence warnings\n  -v, --verbose  Enable verbose output\n  --help         Show this message and exit.\n</code></pre>"},{"location":"cli/#build","title":"build","text":"<p>Build the MkDocs documentation</p> <p>Usage:</p> <pre><code>cli build [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --clean / --dirty           Remove old files from the site_dir before\n                                  building (the default).\n  -f, --config-file FILENAME      Provide a specific MkDocs config\n  -s, --strict                    Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -d, --site-dir PATH             The directory to output the result of the\n                                  documentation build.\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#gh-deploy","title":"gh-deploy","text":"<p>Deploy your documentation to GitHub Pages</p> <p>Usage:</p> <pre><code>cli gh-deploy [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --clean / --dirty           Remove old files from the site_dir before\n                                  building (the default).\n  -m, --message TEXT              A commit message to use when committing to\n                                  the GitHub Pages remote branch. Commit {sha}\n                                  and MkDocs {version} are available as\n                                  expansions\n  -b, --remote-branch TEXT        The remote branch to commit to for GitHub\n                                  Pages. This overrides the value specified in\n                                  config\n  -r, --remote-name TEXT          The remote name to commit to for GitHub\n                                  Pages. This overrides the value specified in\n                                  config\n  --force                         Force the push to the repository.\n  --no-history                    Replace the whole Git history with one new\n                                  commit.\n  --ignore-version                Ignore check that build is not being\n                                  deployed with an older version of MkDocs.\n  --shell                         Use the shell when invoking Git.\n  -f, --config-file FILENAME      Provide a specific MkDocs config\n  -s, --strict                    Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -d, --site-dir PATH             The directory to output the result of the\n                                  documentation build.\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#new","title":"new","text":"<p>Create a new MkDocs project</p> <p>Usage:</p> <pre><code>cli new [OPTIONS] PROJECT_DIRECTORY\n</code></pre> <p>Options:</p> <pre><code>  -q, --quiet    Silence warnings\n  -v, --verbose  Enable verbose output\n  --help         Show this message and exit.\n</code></pre>"},{"location":"cli/#serve","title":"serve","text":"<p>Run the builtin development server</p> <p>Usage:</p> <pre><code>cli serve [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -a, --dev-addr &lt;IP:PORT&gt;        IP address and port to serve documentation\n                                  locally (default: localhost:8000)\n  --livereload                    Enable the live reloading in the development\n                                  server (this is the default)\n  --no-livereload                 Disable the live reloading in the\n                                  development server.\n  --dirtyreload                   Enable the live reloading in the development\n                                  server, but only re-build files that have\n                                  changed\n  --watch-theme                   Include the theme in list of files to watch\n                                  for live reloading. Ignored when live reload\n                                  is not used.\n  -w, --watch PATH                A directory or file to watch for live\n                                  reloading. Can be supplied multiple times.\n  -f, --config-file FILENAME      Provide a specific MkDocs config\n  -s, --strict                    Enable strict mode. This will cause MkDocs\n                                  to abort the build on any warnings.\n  -t, --theme [ledger|material|mkdocs|readthedocs]\n                                  The theme to use when building your\n                                  documentation.\n  --use-directory-urls / --no-directory-urls\n                                  Use directory URLs when building pages (the\n                                  default).\n  -q, --quiet                     Silence warnings\n  -v, --verbose                   Enable verbose output\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"docstrings/","title":"Docstrings","text":"<p>This page showcase the mkdocsstrings extension with its own code.</p> <p>Todo</p> <p>Make a dedicated demo package to have just what is needed to style</p> <p>This module contains the \"mkdocstrings\" plugin for MkDocs.</p> <p>The plugin instantiates a Markdown extension (<code>MkdocstringsExtension</code>), and adds it to the list of Markdown extensions used by <code>mkdocs</code> during the <code>on_config</code> event hook.</p> <p>Once the documentation is built, the <code>on_post_build</code> event hook is triggered and calls the <code>handlers.teardown()</code> method. This method is used to teardown the handlers that were instantiated during documentation buildup.</p> <p>Finally, when serving the documentation, it can add directories to watch during the <code>on_serve</code> event hook.</p> <p>This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions.</p> <p>The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'.</p> <p>For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates.</p> <p>Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction:</p> <pre><code>::: some.identifier\nhandler: python\nselection:\noption1: value1\noption2:\n- value2a\n- value2b\nrendering:\noption_x: etc\n</code></pre> <p>Base module for handlers.</p> <p>This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers.</p> <p>It also provides two methods:</p> <ul> <li><code>get_handler</code>, that will cache handlers into the <code>HANDLERS_CACHE</code> dictionary.</li> <li><code>teardown</code>, that will teardown all the cached handlers, and then clear the cache.</li> </ul>"},{"location":"docstrings/#mkdocstrings.plugin.RENDERING_OPTS_KEY","title":"<code>RENDERING_OPTS_KEY: str = 'rendering'</code>  <code>module-attribute</code>","text":"<p>Deprecated. The name of the rendering parameter in YAML configuration blocks.</p>"},{"location":"docstrings/#mkdocstrings.plugin.SELECTION_OPTS_KEY","title":"<code>SELECTION_OPTS_KEY: str = 'selection'</code>  <code>module-attribute</code>","text":"<p>Deprecated. The name of the selection parameter in YAML configuration blocks.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin","title":"<code>MkdocstringsPlugin</code>","text":"<p>         Bases: <code>BasePlugin</code></p> <p>An <code>mkdocs</code> plugin.</p> <p>This plugin defines the following event hooks:</p> <ul> <li><code>on_config</code></li> <li><code>on_env</code></li> <li><code>on_post_build</code></li> <li><code>on_serve</code></li> </ul> <p>Check the Developing Plugins page of <code>mkdocs</code> for more information about its plugin system.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>class MkdocstringsPlugin(BasePlugin):\n\"\"\"An `mkdocs` plugin.\n    This plugin defines the following event hooks:\n    - `on_config`\n    - `on_env`\n    - `on_post_build`\n    - `on_serve`\n    Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs`\n    for more information about its plugin system.\n    \"\"\"\nconfig_scheme: tuple[tuple[str, MkType]] = (\n(\"watch\", MkType(list, default=[])),  # type: ignore[assignment]\n(\"handlers\", MkType(dict, default={})),\n(\"default_handler\", MkType(str, default=\"python\")),\n(\"custom_templates\", MkType(str, default=None)),\n(\"enable_inventory\", MkType(bool, default=None)),\n(\"enabled\", MkType(bool, default=True)),\n)\n\"\"\"\n    The configuration options of `mkdocstrings`, written in `mkdocs.yml`.\n    Available options are:\n    - **`watch` (deprecated)**: A list of directories to watch. Only used when serving the documentation with mkdocs.\n       Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed.\n       Deprecated in favor of the now built-in `watch` feature of MkDocs.\n    - **`default_handler`**: The default handler to use. The value is the name of the handler module. Default is \"python\".\n    - **`enabled`**: Whether to enable the plugin. Default is true. If false, *mkdocstrings* will not collect or render anything.\n    - **`handlers`**: Global configuration of handlers. You can set global configuration per handler, applied everywhere,\n      but overridable in each \"autodoc\" instruction. Example:\n    ```yaml\n    plugins:\n      - mkdocstrings:\n          handlers:\n            python:\n              options:\n                selection_opt: true\n                rendering_opt: \"value\"\n            rust:\n              options:\n                selection_opt: 2\n    ```\n    \"\"\"\ncss_filename = \"assets/_mkdocstrings.css\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize the object.\"\"\"\nsuper().__init__()\nself._handlers: Handlers | None = None\n@property\ndef handlers(self) -&gt; Handlers:\n\"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build.\n        Raises:\n            RuntimeError: If the plugin hasn't been initialized with a config.\n        Returns:\n            An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build).\n        \"\"\"\nif not self._handlers:\nraise RuntimeError(\"The plugin hasn't been initialized with a config yet\")\nreturn self._handlers\n# TODO: remove once watch feature is removed\ndef on_serve(\nself,\nserver: LiveReloadServer,\nconfig: Config,  # noqa: ARG002\nbuilder: Callable,\n*args: Any,  # noqa: ARG002\n**kwargs: Any,  # noqa: ARG002\n) -&gt; None:\n\"\"\"Watch directories.\n        Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve).\n        In this hook, we add the directories specified in the plugin's configuration to the list of directories\n        watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again\n        and the site reloaded.\n        Arguments:\n            server: The `livereload` server instance.\n            config: The MkDocs config object (unused).\n            builder: The function to build the site.\n            *args: Additional arguments passed by MkDocs.\n            **kwargs: Additional arguments passed by MkDocs.\n        \"\"\"\nif not self.plugin_enabled:\nreturn\nif self.config[\"watch\"]:\nfor element in self.config[\"watch\"]:\nlog.debug(f\"Adding directory '{element}' to watcher\")\nserver.watch(element, builder)\ndef on_config(self, config: Config, **kwargs: Any) -&gt; Config:  # noqa: ARG002\n\"\"\"Instantiate our Markdown extension.\n        Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config).\n        In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension]\n        and add it to the list of Markdown extensions used by `mkdocs`.\n        We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it\n        later when processing markdown to get handlers and their global configurations).\n        Arguments:\n            config: The MkDocs config object.\n            **kwargs: Additional arguments passed by MkDocs.\n        Returns:\n            The modified config.\n        \"\"\"\nif not self.plugin_enabled:\nlog.debug(\"Plugin is not enabled. Skipping.\")\nreturn config\nlog.debug(\"Adding extension to the list\")\ntheme_name = config[\"theme\"].name or os.path.dirname(config[\"theme\"].dirs[0])\nto_import: InventoryImportType = []\nfor handler_name, conf in self.config[\"handlers\"].items():\nfor import_item in conf.pop(\"import\", ()):\nif isinstance(import_item, str):\nimport_item = {\"url\": import_item}  # noqa: PLW2901\nto_import.append((handler_name, import_item))\nextension_config = {\n\"theme_name\": theme_name,\n\"mdx\": config[\"markdown_extensions\"],\n\"mdx_configs\": config[\"mdx_configs\"],\n\"mkdocstrings\": self.config,\n\"mkdocs\": config,\n}\nself._handlers = Handlers(extension_config)\ntry:\n# If autorefs plugin is explicitly enabled, just use it.\nautorefs = config[\"plugins\"][\"autorefs\"]\nlog.debug(f\"Picked up existing autorefs instance {autorefs!r}\")\nexcept KeyError:\n# Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`.\nautorefs = AutorefsPlugin()\nautorefs.scan_toc = False\nconfig[\"plugins\"][\"autorefs\"] = autorefs\nlog.debug(f\"Added a subdued autorefs instance {autorefs!r}\")\n# Add collector-based fallback in either case.\nautorefs.get_fallback_anchor = self.handlers.get_anchors\nmkdocstrings_extension = MkdocstringsExtension(extension_config, self.handlers, autorefs)\nconfig[\"markdown_extensions\"].append(mkdocstrings_extension)\nconfig[\"extra_css\"].insert(0, self.css_filename)  # So that it has lower priority than user files.\nself._inv_futures = {}\nif to_import:\ninv_loader = futures.ThreadPoolExecutor(4)\nfor handler_name, import_item in to_import:\nloader = self.get_handler(handler_name).load_inventory\nfuture = inv_loader.submit(\nself._load_inventory,  # type: ignore[misc]\nloader,\n**import_item,\n)\nself._inv_futures[future] = (loader, import_item)\ninv_loader.shutdown(wait=False)\nif self.config[\"watch\"]:\nself._warn_about_watch_option()\nreturn config\n@property\ndef inventory_enabled(self) -&gt; bool:\n\"\"\"Tell if the inventory is enabled or not.\n        Returns:\n            Whether the inventory is enabled.\n        \"\"\"\ninventory_enabled = self.config[\"enable_inventory\"]\nif inventory_enabled is None:\ninventory_enabled = any(handler.enable_inventory for handler in self.handlers.seen_handlers)\nreturn inventory_enabled\n@property\ndef plugin_enabled(self) -&gt; bool:\n\"\"\"Tell if the plugin is enabled or not.\n        Returns:\n            Whether the plugin is enabled.\n        \"\"\"\nreturn self.config[\"enabled\"]\ndef on_env(self, env: Environment, config: Config, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n\"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering.\n        Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env).\n        - Write mkdocstrings' extra files into the site dir.\n        - Gather results from background inventory download tasks.\n        \"\"\"\nif not self.plugin_enabled:\nreturn\nif self._handlers:\ncss_content = \"\\n\".join(handler.extra_css for handler in self.handlers.seen_handlers)\nwrite_file(css_content.encode(\"utf-8\"), os.path.join(config[\"site_dir\"], self.css_filename))\nif self.inventory_enabled:\nlog.debug(\"Creating inventory file objects.inv\")\ninv_contents = self.handlers.inventory.format_sphinx()\nwrite_file(inv_contents, os.path.join(config[\"site_dir\"], \"objects.inv\"))\nif self._inv_futures:\nlog.debug(f\"Waiting for {len(self._inv_futures)} inventory download(s)\")\nfutures.wait(self._inv_futures, timeout=30)\nresults = {}\n# Reversed order so that pages from first futures take precedence:\nfor fut in reversed(list(self._inv_futures)):\ntry:\nresults.update(fut.result())\nexcept Exception as error:  # noqa: BLE001\nloader, import_item = self._inv_futures[fut]\nloader_name = loader.__func__.__qualname__\nlog.error(f\"Couldn't load inventory {import_item} through {loader_name}: {error}\")  # noqa: TRY400\nfor page, identifier in results.items():\nconfig[\"plugins\"][\"autorefs\"].register_url(page, identifier)\nself._inv_futures = {}\ndef on_post_build(\nself,\nconfig: Config,  # noqa: ARG002\n**kwargs: Any,  # noqa: ARG002\n) -&gt; None:\n\"\"\"Teardown the handlers.\n        Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build).\n        This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.\n        For example, a handler could open a subprocess in the background and keep it open\n        to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point:\n        the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook.\n        Arguments:\n            config: The MkDocs config object.\n            **kwargs: Additional arguments passed by MkDocs.\n        \"\"\"\nif not self.plugin_enabled:\nreturn\nfor future in self._inv_futures:\nfuture.cancel()\nif self._handlers:\nlog.debug(\"Tearing handlers down\")\nself.handlers.teardown()\ndef get_handler(self, handler_name: str) -&gt; BaseHandler:\n\"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][].\n        Arguments:\n            handler_name: The name of the handler.\n        Returns:\n            An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler].\n        \"\"\"\nreturn self.handlers.get_handler(handler_name)\n@classmethod\n# lru_cache does not allow mutable arguments such lists, but that is what we load from YAML config.\n@list_to_tuple\n@functools.lru_cache(maxsize=None)\ndef _load_inventory(cls, loader: InventoryLoaderType, url: str, **kwargs: Any) -&gt; Mapping[str, str]:\n\"\"\"Download and process inventory files using a handler.\n        Arguments:\n            loader: A function returning a sequence of pairs (identifier, url).\n            url: The URL to download and process.\n            **kwargs: Extra arguments to pass to the loader.\n        Returns:\n            A mapping from identifier to absolute URL.\n        \"\"\"\nlog.debug(f\"Downloading inventory from {url!r}\")\nreq = request.Request(url, headers={\"Accept-Encoding\": \"gzip\", \"User-Agent\": \"mkdocstrings/0.15.0\"})\nwith request.urlopen(req) as resp:  # noqa: S310 (URL audit OK: comes from a checked-in config)\ncontent: BinaryIO = resp\nif \"gzip\" in resp.headers.get(\"content-encoding\", \"\"):\ncontent = gzip.GzipFile(fileobj=resp)  # type: ignore[assignment]\nresult = dict(loader(content, url=url, **kwargs))\nlog.debug(f\"Loaded inventory from {url!r}: {len(result)} items\")\nreturn result\n@classmethod\n@functools.lru_cache(maxsize=None)  # Warn only once\ndef _warn_about_watch_option(cls) -&gt; None:\nlog.info(\n\"DEPRECATION: mkdocstrings' watch feature is deprecated in favor of MkDocs' watch feature, \"\n\"see https://www.mkdocs.org/user-guide/configuration/#watch\",\n)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","title":"<code>config_scheme: tuple[tuple[str, MkType]] = (('watch', MkType(list, default=[])), ('handlers', MkType(dict, default={})), ('default_handler', MkType(str, default='python')), ('custom_templates', MkType(str, default=None)), ('enable_inventory', MkType(bool, default=None)), ('enabled', MkType(bool, default=True)))</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The configuration options of <code>mkdocstrings</code>, written in <code>mkdocs.yml</code>.</p> <p>Available options are:</p> <ul> <li><code>watch</code> (deprecated): A list of directories to watch. Only used when serving the documentation with mkdocs.    Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed.    Deprecated in favor of the now built-in <code>watch</code> feature of MkDocs.</li> <li><code>default_handler</code>: The default handler to use. The value is the name of the handler module. Default is \"python\".</li> <li><code>enabled</code>: Whether to enable the plugin. Default is true. If false, mkdocstrings will not collect or render anything.</li> <li><code>handlers</code>: Global configuration of handlers. You can set global configuration per handler, applied everywhere,   but overridable in each \"autodoc\" instruction. Example:</li> </ul> <pre><code>plugins:\n- mkdocstrings:\nhandlers:\npython:\noptions:\nselection_opt: true\nrendering_opt: \"value\"\nrust:\noptions:\nselection_opt: 2\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.handlers","title":"<code>handlers: Handlers</code>  <code>property</code>","text":"<p>Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the plugin hasn't been initialized with a config.</p> <p>Returns:</p> Type Description <code>Handlers</code> <p>An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build).</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.inventory_enabled","title":"<code>inventory_enabled: bool</code>  <code>property</code>","text":"<p>Tell if the inventory is enabled or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the inventory is enabled.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.plugin_enabled","title":"<code>plugin_enabled: bool</code>  <code>property</code>","text":"<p>Tell if the plugin is enabled or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the plugin is enabled.</p>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the object.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the object.\"\"\"\nsuper().__init__()\nself._handlers: Handlers | None = None\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.get_handler","title":"<code>get_handler(handler_name)</code>","text":"<p>Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler_name</code> <code>str</code> <p>The name of the handler.</p> required <p>Returns:</p> Type Description <code>BaseHandler</code> <p>An instance of a subclass of <code>BaseHandler</code>.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def get_handler(self, handler_name: str) -&gt; BaseHandler:\n\"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][].\n    Arguments:\n        handler_name: The name of the handler.\n    Returns:\n        An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler].\n    \"\"\"\nreturn self.handlers.get_handler(handler_name)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","title":"<code>on_config(config, **kwargs)</code>","text":"<p>Instantiate our Markdown extension.</p> <p>Hook for the <code>on_config</code> event. In this hook, we instantiate our <code>MkdocstringsExtension</code> and add it to the list of Markdown extensions used by <code>mkdocs</code>.</p> <p>We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations).</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The MkDocs config object.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed by MkDocs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Config</code> <p>The modified config.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_config(self, config: Config, **kwargs: Any) -&gt; Config:  # noqa: ARG002\n\"\"\"Instantiate our Markdown extension.\n    Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config).\n    In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension]\n    and add it to the list of Markdown extensions used by `mkdocs`.\n    We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it\n    later when processing markdown to get handlers and their global configurations).\n    Arguments:\n        config: The MkDocs config object.\n        **kwargs: Additional arguments passed by MkDocs.\n    Returns:\n        The modified config.\n    \"\"\"\nif not self.plugin_enabled:\nlog.debug(\"Plugin is not enabled. Skipping.\")\nreturn config\nlog.debug(\"Adding extension to the list\")\ntheme_name = config[\"theme\"].name or os.path.dirname(config[\"theme\"].dirs[0])\nto_import: InventoryImportType = []\nfor handler_name, conf in self.config[\"handlers\"].items():\nfor import_item in conf.pop(\"import\", ()):\nif isinstance(import_item, str):\nimport_item = {\"url\": import_item}  # noqa: PLW2901\nto_import.append((handler_name, import_item))\nextension_config = {\n\"theme_name\": theme_name,\n\"mdx\": config[\"markdown_extensions\"],\n\"mdx_configs\": config[\"mdx_configs\"],\n\"mkdocstrings\": self.config,\n\"mkdocs\": config,\n}\nself._handlers = Handlers(extension_config)\ntry:\n# If autorefs plugin is explicitly enabled, just use it.\nautorefs = config[\"plugins\"][\"autorefs\"]\nlog.debug(f\"Picked up existing autorefs instance {autorefs!r}\")\nexcept KeyError:\n# Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`.\nautorefs = AutorefsPlugin()\nautorefs.scan_toc = False\nconfig[\"plugins\"][\"autorefs\"] = autorefs\nlog.debug(f\"Added a subdued autorefs instance {autorefs!r}\")\n# Add collector-based fallback in either case.\nautorefs.get_fallback_anchor = self.handlers.get_anchors\nmkdocstrings_extension = MkdocstringsExtension(extension_config, self.handlers, autorefs)\nconfig[\"markdown_extensions\"].append(mkdocstrings_extension)\nconfig[\"extra_css\"].insert(0, self.css_filename)  # So that it has lower priority than user files.\nself._inv_futures = {}\nif to_import:\ninv_loader = futures.ThreadPoolExecutor(4)\nfor handler_name, import_item in to_import:\nloader = self.get_handler(handler_name).load_inventory\nfuture = inv_loader.submit(\nself._load_inventory,  # type: ignore[misc]\nloader,\n**import_item,\n)\nself._inv_futures[future] = (loader, import_item)\ninv_loader.shutdown(wait=False)\nif self.config[\"watch\"]:\nself._warn_about_watch_option()\nreturn config\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_env","title":"<code>on_env(env, config, *args, **kwargs)</code>","text":"<p>Extra actions that need to happen after all Markdown rendering and before HTML rendering.</p> <p>Hook for the <code>on_env</code> event.</p> <ul> <li>Write mkdocstrings' extra files into the site dir.</li> <li>Gather results from background inventory download tasks.</li> </ul> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_env(self, env: Environment, config: Config, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n\"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering.\n    Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env).\n    - Write mkdocstrings' extra files into the site dir.\n    - Gather results from background inventory download tasks.\n    \"\"\"\nif not self.plugin_enabled:\nreturn\nif self._handlers:\ncss_content = \"\\n\".join(handler.extra_css for handler in self.handlers.seen_handlers)\nwrite_file(css_content.encode(\"utf-8\"), os.path.join(config[\"site_dir\"], self.css_filename))\nif self.inventory_enabled:\nlog.debug(\"Creating inventory file objects.inv\")\ninv_contents = self.handlers.inventory.format_sphinx()\nwrite_file(inv_contents, os.path.join(config[\"site_dir\"], \"objects.inv\"))\nif self._inv_futures:\nlog.debug(f\"Waiting for {len(self._inv_futures)} inventory download(s)\")\nfutures.wait(self._inv_futures, timeout=30)\nresults = {}\n# Reversed order so that pages from first futures take precedence:\nfor fut in reversed(list(self._inv_futures)):\ntry:\nresults.update(fut.result())\nexcept Exception as error:  # noqa: BLE001\nloader, import_item = self._inv_futures[fut]\nloader_name = loader.__func__.__qualname__\nlog.error(f\"Couldn't load inventory {import_item} through {loader_name}: {error}\")  # noqa: TRY400\nfor page, identifier in results.items():\nconfig[\"plugins\"][\"autorefs\"].register_url(page, identifier)\nself._inv_futures = {}\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","title":"<code>on_post_build(config, **kwargs)</code>","text":"<p>Teardown the handlers.</p> <p>Hook for the <code>on_post_build</code> event. This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.</p> <p>For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's <code>teardown</code> method, which is indirectly called by this hook.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The MkDocs config object.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed by MkDocs.</p> <code>{}</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_post_build(\nself,\nconfig: Config,  # noqa: ARG002\n**kwargs: Any,  # noqa: ARG002\n) -&gt; None:\n\"\"\"Teardown the handlers.\n    Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build).\n    This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup.\n    For example, a handler could open a subprocess in the background and keep it open\n    to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point:\n    the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook.\n    Arguments:\n        config: The MkDocs config object.\n        **kwargs: Additional arguments passed by MkDocs.\n    \"\"\"\nif not self.plugin_enabled:\nreturn\nfor future in self._inv_futures:\nfuture.cancel()\nif self._handlers:\nlog.debug(\"Tearing handlers down\")\nself.handlers.teardown()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","title":"<code>on_serve(server, config, builder, *args, **kwargs)</code>","text":"<p>Watch directories.</p> <p>Hook for the <code>on_serve</code> event. In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by <code>mkdocs</code>. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>LiveReloadServer</code> <p>The <code>livereload</code> server instance.</p> required <code>config</code> <code>Config</code> <p>The MkDocs config object (unused).</p> required <code>builder</code> <code>Callable</code> <p>The function to build the site.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments passed by MkDocs.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed by MkDocs.</p> <code>{}</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def on_serve(\nself,\nserver: LiveReloadServer,\nconfig: Config,  # noqa: ARG002\nbuilder: Callable,\n*args: Any,  # noqa: ARG002\n**kwargs: Any,  # noqa: ARG002\n) -&gt; None:\n\"\"\"Watch directories.\n    Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve).\n    In this hook, we add the directories specified in the plugin's configuration to the list of directories\n    watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again\n    and the site reloaded.\n    Arguments:\n        server: The `livereload` server instance.\n        config: The MkDocs config object (unused).\n        builder: The function to build the site.\n        *args: Additional arguments passed by MkDocs.\n        **kwargs: Additional arguments passed by MkDocs.\n    \"\"\"\nif not self.plugin_enabled:\nreturn\nif self.config[\"watch\"]:\nfor element in self.config[\"watch\"]:\nlog.debug(f\"Adding directory '{element}' to watcher\")\nserver.watch(element, builder)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.plugin.list_to_tuple","title":"<code>list_to_tuple(function)</code>","text":"<p>Decorater to convert lists to tuples in the arguments.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/plugin.py</code> <pre><code>def list_to_tuple(function: Callable[P, R]) -&gt; Callable[P, R]:\n\"\"\"Decorater to convert lists to tuples in the arguments.\"\"\"\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\nsafe_args = [tuple(item) if isinstance(item, list) else item for item in args]\nif kwargs:\nkwargs = {key: tuple(value) if isinstance(value, list) else value for key, value in kwargs.items()}  # type: ignore[assignment]\nreturn function(*safe_args, **kwargs)  # type: ignore[arg-type]\nreturn wrapper\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor","title":"<code>AutoDocProcessor</code>","text":"<p>         Bases: <code>BlockProcessor</code></p> <p>Our \"autodoc\" Markdown block processor.</p> <p>It has a <code>test</code> method that tells if a block matches a criterion, and a <code>run</code> method that processes it.</p> <p>It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>class AutoDocProcessor(BlockProcessor):\n\"\"\"Our \"autodoc\" Markdown block processor.\n    It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion,\n    and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it.\n    It also has utility methods allowing to get handlers and their configuration easily, useful when processing\n    a matched block.\n    \"\"\"\nregex = re.compile(r\"^(?P&lt;heading&gt;#{1,6} *|)::: ?(?P&lt;name&gt;.+?) *$\", flags=re.MULTILINE)\ndef __init__(\nself,\nparser: BlockParser,\nmd: Markdown,\nconfig: dict,\nhandlers: Handlers,\nautorefs: AutorefsPlugin,\n) -&gt; None:\n\"\"\"Initialize the object.\n        Arguments:\n            parser: A `markdown.blockparser.BlockParser` instance.\n            md: A `markdown.Markdown` instance.\n            config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme]\n                of the `mkdocstrings` plugin.\n            handlers: The handlers container.\n            autorefs: The autorefs plugin instance.\n        \"\"\"\nsuper().__init__(parser=parser)\nself.md = md\nself._config = config\nself._handlers = handlers\nself._autorefs = autorefs\nself._updated_envs: set = set()\ndef test(self, parent: Element, block: str) -&gt; bool:  # noqa: ARG002\n\"\"\"Match our autodoc instructions.\n        Arguments:\n            parent: The parent element in the XML tree.\n            block: The block to be tested.\n        Returns:\n            Whether this block should be processed or not.\n        \"\"\"\nreturn bool(self.regex.search(block))\ndef run(self, parent: Element, blocks: MutableSequence[str]) -&gt; None:\n\"\"\"Run code on the matched blocks.\n        The identifier and configuration lines are retrieved from a matched block\n        and used to collect and render an object.\n        Arguments:\n            parent: The parent element in the XML tree.\n            blocks: The rest of the blocks to be processed.\n        \"\"\"\nblock = blocks.pop(0)\nmatch = self.regex.search(block)\nif match:\nif match.start() &gt; 0:\nself.parser.parseBlocks(parent, [block[: match.start()]])\n# removes the first line\nblock = block[match.end() :]\nblock, the_rest = self.detab(block)\nif match:\nidentifier = match[\"name\"]\nheading_level = match[\"heading\"].count(\"#\")\nlog.debug(f\"Matched '::: {identifier}'\")\nhtml, handler, data = self._process_block(identifier, block, heading_level)\nel = Element(\"div\", {\"class\": \"mkdocstrings\"})\n# The final HTML is inserted as opaque to subsequent processing, and only revealed at the end.\nel.text = self.md.htmlStash.store(html)\n# So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up.\nheadings = handler.get_headings()\nel.extend(headings)\npage = self._autorefs.current_page\nif page:\nfor heading in headings:\nanchor = heading.attrib[\"id\"]\nself._autorefs.register_anchor(page, anchor)\nif \"data-role\" in heading.attrib:\nself._handlers.inventory.register(\nname=anchor,\ndomain=handler.domain,\nrole=heading.attrib[\"data-role\"],\nuri=f\"{page}#{anchor}\",\n)\nparent.append(el)\nif the_rest:\n# This block contained unindented line(s) after the first indented\n# line. Insert these lines as the first block of the master blocks\n# list for future processing.\nblocks.insert(0, the_rest)\ndef _process_block(\nself,\nidentifier: str,\nyaml_block: str,\nheading_level: int = 0,\n) -&gt; tuple[str, BaseHandler, CollectorItem]:\n\"\"\"Process an autodoc block.\n        Arguments:\n            identifier: The identifier of the object to collect and render.\n            yaml_block: The YAML configuration.\n            heading_level: Suggested level of the heading to insert (0 to ignore).\n        Raises:\n            PluginError: When something wrong happened during collection.\n            TemplateNotFound: When a template used for rendering could not be found.\n        Returns:\n            Rendered HTML, the handler that was used, and the collected item.\n        \"\"\"\nconfig = yaml.safe_load(yaml_block) or {}\nhandler_name = self._handlers.get_handler_name(config)\nlog.debug(f\"Using handler '{handler_name}'\")\nhandler_config = self._handlers.get_handler_config(handler_name)\nhandler = self._handlers.get_handler(handler_name, handler_config)\nglobal_options = handler_config.get(\"options\", {})\nlocal_options = config.get(\"options\", {})\ndeprecated_global_options = ChainMap(handler_config.get(\"selection\", {}), handler_config.get(\"rendering\", {}))\ndeprecated_local_options = ChainMap(config.get(\"selection\", {}), config.get(\"rendering\", {}))\noptions = ChainMap(local_options, deprecated_local_options, global_options, deprecated_global_options)\nif deprecated_global_options or deprecated_local_options:\nself._warn_about_options_key()\nif heading_level:\noptions = ChainMap(options, {\"heading_level\": heading_level})  # like setdefault\nlog.debug(\"Collecting data\")\ntry:\ndata: CollectorItem = handler.collect(identifier, options)\nexcept CollectionError as exception:\nlog.error(str(exception))  # noqa: TRY400\nif PluginError is SystemExit:  # When MkDocs 1.2 is sufficiently common, this can be dropped.\nlog.error(f\"Error reading page '{self._autorefs.current_page}':\")  # noqa: TRY400\nraise PluginError(f\"Could not collect '{identifier}'\") from exception\nif handler_name not in self._updated_envs:  # We haven't seen this handler before on this document.\nlog.debug(\"Updating renderer's env\")\nhandler._update_env(self.md, self._config)\nself._updated_envs.add(handler_name)\nlog.debug(\"Rendering templates\")\ntry:\nrendered = handler.render(data, options)\nexcept TemplateNotFound as exc:\ntheme_name = self._config[\"theme_name\"]\nlog.error(  # noqa: TRY400\nf\"Template '{exc.name}' not found for '{handler_name}' handler and theme '{theme_name}'.\",\n)\nraise\nreturn rendered, handler, data\n@classmethod\n@functools.lru_cache(maxsize=None)  # Warn only once\ndef _warn_about_options_key(cls) -&gt; None:\nlog.info(\"DEPRECATION: 'selection' and 'rendering' are deprecated and merged into a single 'options' YAML key\")\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.__init__","title":"<code>__init__(parser, md, config, handlers, autorefs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>BlockParser</code> <p>A <code>markdown.blockparser.BlockParser</code> instance.</p> required <code>md</code> <code>Markdown</code> <p>A <code>markdown.Markdown</code> instance.</p> required <code>config</code> <code>dict</code> <p>The configuration of the <code>mkdocstrings</code> plugin.</p> required <code>handlers</code> <code>Handlers</code> <p>The handlers container.</p> required <code>autorefs</code> <code>AutorefsPlugin</code> <p>The autorefs plugin instance.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def __init__(\nself,\nparser: BlockParser,\nmd: Markdown,\nconfig: dict,\nhandlers: Handlers,\nautorefs: AutorefsPlugin,\n) -&gt; None:\n\"\"\"Initialize the object.\n    Arguments:\n        parser: A `markdown.blockparser.BlockParser` instance.\n        md: A `markdown.Markdown` instance.\n        config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme]\n            of the `mkdocstrings` plugin.\n        handlers: The handlers container.\n        autorefs: The autorefs plugin instance.\n    \"\"\"\nsuper().__init__(parser=parser)\nself.md = md\nself._config = config\nself._handlers = handlers\nself._autorefs = autorefs\nself._updated_envs: set = set()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.run","title":"<code>run(parent, blocks)</code>","text":"<p>Run code on the matched blocks.</p> <p>The identifier and configuration lines are retrieved from a matched block and used to collect and render an object.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Element</code> <p>The parent element in the XML tree.</p> required <code>blocks</code> <code>MutableSequence[str]</code> <p>The rest of the blocks to be processed.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def run(self, parent: Element, blocks: MutableSequence[str]) -&gt; None:\n\"\"\"Run code on the matched blocks.\n    The identifier and configuration lines are retrieved from a matched block\n    and used to collect and render an object.\n    Arguments:\n        parent: The parent element in the XML tree.\n        blocks: The rest of the blocks to be processed.\n    \"\"\"\nblock = blocks.pop(0)\nmatch = self.regex.search(block)\nif match:\nif match.start() &gt; 0:\nself.parser.parseBlocks(parent, [block[: match.start()]])\n# removes the first line\nblock = block[match.end() :]\nblock, the_rest = self.detab(block)\nif match:\nidentifier = match[\"name\"]\nheading_level = match[\"heading\"].count(\"#\")\nlog.debug(f\"Matched '::: {identifier}'\")\nhtml, handler, data = self._process_block(identifier, block, heading_level)\nel = Element(\"div\", {\"class\": \"mkdocstrings\"})\n# The final HTML is inserted as opaque to subsequent processing, and only revealed at the end.\nel.text = self.md.htmlStash.store(html)\n# So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up.\nheadings = handler.get_headings()\nel.extend(headings)\npage = self._autorefs.current_page\nif page:\nfor heading in headings:\nanchor = heading.attrib[\"id\"]\nself._autorefs.register_anchor(page, anchor)\nif \"data-role\" in heading.attrib:\nself._handlers.inventory.register(\nname=anchor,\ndomain=handler.domain,\nrole=heading.attrib[\"data-role\"],\nuri=f\"{page}#{anchor}\",\n)\nparent.append(el)\nif the_rest:\n# This block contained unindented line(s) after the first indented\n# line. Insert these lines as the first block of the master blocks\n# list for future processing.\nblocks.insert(0, the_rest)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.test","title":"<code>test(parent, block)</code>","text":"<p>Match our autodoc instructions.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Element</code> <p>The parent element in the XML tree.</p> required <code>block</code> <code>str</code> <p>The block to be tested.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether this block should be processed or not.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def test(self, parent: Element, block: str) -&gt; bool:  # noqa: ARG002\n\"\"\"Match our autodoc instructions.\n    Arguments:\n        parent: The parent element in the XML tree.\n        block: The block to be tested.\n    Returns:\n        Whether this block should be processed or not.\n    \"\"\"\nreturn bool(self.regex.search(block))\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension","title":"<code>MkdocstringsExtension</code>","text":"<p>         Bases: <code>Extension</code></p> <p>Our Markdown extension.</p> <p>It cannot work outside of <code>mkdocstrings</code>.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>class MkdocstringsExtension(Extension):\n\"\"\"Our Markdown extension.\n    It cannot work outside of `mkdocstrings`.\n    \"\"\"\ndef __init__(self, config: dict, handlers: Handlers, autorefs: AutorefsPlugin, **kwargs: Any) -&gt; None:\n\"\"\"Initialize the object.\n        Arguments:\n            config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor\n                when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown].\n            handlers: The handlers container.\n            autorefs: The autorefs plugin instance.\n            **kwargs: Keyword arguments used by `markdown.extensions.Extension`.\n        \"\"\"\nsuper().__init__(**kwargs)\nself._config = config\nself._handlers = handlers\nself._autorefs = autorefs\ndef extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802 (casing: parent method's name)\n\"\"\"Register the extension.\n        Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser.\n        Arguments:\n            md: A `markdown.Markdown` instance.\n        \"\"\"\nmd.parser.blockprocessors.register(\nAutoDocProcessor(md.parser, md, self._config, self._handlers, self._autorefs),\n\"mkdocstrings\",\npriority=75,  # Right before markdown.blockprocessors.HashHeaderProcessor\n)\nmd.treeprocessors.register(\n_PostProcessor(md),\n\"mkdocstrings_post\",\npriority=4,  # Right after 'toc'.\n)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.__init__","title":"<code>__init__(config, handlers, autorefs, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration items from <code>mkdocs</code> and <code>mkdocstrings</code> that must be passed to the block processor when instantiated in <code>extendMarkdown</code>.</p> required <code>handlers</code> <code>Handlers</code> <p>The handlers container.</p> required <code>autorefs</code> <code>AutorefsPlugin</code> <p>The autorefs plugin instance.</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments used by <code>markdown.extensions.Extension</code>.</p> <code>{}</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def __init__(self, config: dict, handlers: Handlers, autorefs: AutorefsPlugin, **kwargs: Any) -&gt; None:\n\"\"\"Initialize the object.\n    Arguments:\n        config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor\n            when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown].\n        handlers: The handlers container.\n        autorefs: The autorefs plugin instance.\n        **kwargs: Keyword arguments used by `markdown.extensions.Extension`.\n    \"\"\"\nsuper().__init__(**kwargs)\nself._config = config\nself._handlers = handlers\nself._autorefs = autorefs\n</code></pre>"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","title":"<code>extendMarkdown(md)</code>","text":"<p>Register the extension.</p> <p>Add an instance of our <code>AutoDocProcessor</code> to the Markdown parser.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Markdown</code> <p>A <code>markdown.Markdown</code> instance.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/extension.py</code> <pre><code>def extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802 (casing: parent method's name)\n\"\"\"Register the extension.\n    Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser.\n    Arguments:\n        md: A `markdown.Markdown` instance.\n    \"\"\"\nmd.parser.blockprocessors.register(\nAutoDocProcessor(md.parser, md, self._config, self._handlers, self._autorefs),\n\"mkdocstrings\",\npriority=75,  # Right before markdown.blockprocessors.HashHeaderProcessor\n)\nmd.treeprocessors.register(\n_PostProcessor(md),\n\"mkdocstrings_post\",\npriority=4,  # Right after 'toc'.\n)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector","title":"<code>BaseCollector</code>","text":"<p>The base collector class.</p> <p>Inherit from this class to implement a collector.</p> <p>You will have to implement the <code>collect</code> method. You can also implement the <code>teardown</code> method.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class BaseCollector:\n\"\"\"The base collector class.\n    Inherit from this class to implement a collector.\n    You will have to implement the `collect` method.\n    You can also implement the `teardown` method.\n    \"\"\"\ndef collect(self, identifier: str, config: MutableMapping[str, Any]) -&gt; CollectorItem:\n\"\"\"Collect data given an identifier and selection configuration.\n        In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into\n        a Python dictionary for example, though the implementation is completely free.\n        Arguments:\n            identifier: An identifier for which to collect data. For example, in Python,\n                it would be 'mkdocstrings.handlers' to collect documentation about the handlers module.\n                It can be anything that you can feed to the tool of your choice.\n            config: The handler's configuration options.\n        Returns:\n            Anything you want, as long as you can feed it to the renderer's `render` method.\n        \"\"\"\nraise NotImplementedError\ndef teardown(self) -&gt; None:\n\"\"\"Teardown the collector.\n        This method should be implemented to, for example, terminate a subprocess\n        that was started when creating the collector instance.\n        \"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector.collect","title":"<code>collect(identifier, config)</code>","text":"<p>Collect data given an identifier and selection configuration.</p> <p>In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice.</p> required <code>config</code> <code>MutableMapping[str, Any]</code> <p>The handler's configuration options.</p> required <p>Returns:</p> Type Description <code>CollectorItem</code> <p>Anything you want, as long as you can feed it to the renderer's <code>render</code> method.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def collect(self, identifier: str, config: MutableMapping[str, Any]) -&gt; CollectorItem:\n\"\"\"Collect data given an identifier and selection configuration.\n    In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into\n    a Python dictionary for example, though the implementation is completely free.\n    Arguments:\n        identifier: An identifier for which to collect data. For example, in Python,\n            it would be 'mkdocstrings.handlers' to collect documentation about the handlers module.\n            It can be anything that you can feed to the tool of your choice.\n        config: The handler's configuration options.\n    Returns:\n        Anything you want, as long as you can feed it to the renderer's `render` method.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector.teardown","title":"<code>teardown()</code>","text":"<p>Teardown the collector.</p> <p>This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def teardown(self) -&gt; None:\n\"\"\"Teardown the collector.\n    This method should be implemented to, for example, terminate a subprocess\n    that was started when creating the collector instance.\n    \"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>         Bases: <code>BaseCollector</code>, <code>BaseRenderer</code></p> <p>The base handler class.</p> <p>Inherit from this class to implement a handler.</p> <p>It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>The cross-documentation domain/language for this handler.</p> <code>enable_inventory</code> <code>bool</code> <p>Whether this handler is interested in enabling the creation of the <code>objects.inv</code> Sphinx inventory file.</p> <code>fallback_config</code> <code>dict</code> <p>The configuration used to collect item during autorefs fallback.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class BaseHandler(BaseCollector, BaseRenderer):\n\"\"\"The base handler class.\n    Inherit from this class to implement a handler.\n    It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.\n    Attributes:\n        domain: The cross-documentation domain/language for this handler.\n        enable_inventory: Whether this handler is interested in enabling the creation\n            of the `objects.inv` Sphinx inventory file.\n        fallback_config: The configuration used to collect item during autorefs fallback.\n    \"\"\"\ndomain: str = \"default\"\nenable_inventory: bool = False\nfallback_config: dict = {}\n# TODO: once the BaseCollector and BaseRenderer classes are removed,\n# stop accepting the 'handler' parameter, and instead set a 'name' attribute on the Handler class.\n# Then make the 'handler' parameter in 'get_templates_dir' optional, and use the class 'name' by default.\ndef __init__(self, *args: str | BaseCollector | BaseRenderer, **kwargs: str | BaseCollector | BaseRenderer) -&gt; None:\n\"\"\"Initialize the object.\n        Arguments:\n            *args: Collector and renderer, or handler name, theme and custom_templates.\n            **kwargs: Same thing, but with keyword arguments.\n        Raises:\n            ValueError: When the given parameters are invalid.\n        \"\"\"\n# The method accepts *args and **kwargs temporarily,\n# to support the transition period where the BaseCollector\n# and BaseRenderer are deprecated, and the BaseHandler\n# can be instantiated with both instances of collector/renderer,\n# or renderer parameters, as positional parameters.\ncollector = None\nrenderer = None\n# parsing positional arguments\nstr_args = []\nfor arg in args:\nif isinstance(arg, BaseCollector):\ncollector = arg\nelif isinstance(arg, BaseRenderer):\nrenderer = arg\nelif isinstance(arg, str):\nstr_args.append(arg)\nwhile len(str_args) != 3:  # noqa: PLR2004\nstr_args.append(None)  # type: ignore[arg-type]\nhandler, theme, custom_templates = str_args\n# fetching values from keyword arguments\nif \"collector\" in kwargs:\ncollector = kwargs.pop(\"collector\")  # type: ignore[assignment]\nif \"renderer\" in kwargs:\nrenderer = kwargs.pop(\"renderer\")  # type: ignore[assignment]\nif \"handler\" in kwargs:\nhandler = kwargs.pop(\"handler\")  # type: ignore[assignment]\nif \"theme\" in kwargs:\ntheme = kwargs.pop(\"theme\")  # type: ignore[assignment]\nif \"custom_templates\" in kwargs:\ncustom_templates = kwargs.pop(\"custom_templates\")  # type: ignore[assignment]\nif collector is None and renderer is not None or collector is not None and renderer is None:\nraise ValueError(\"both 'collector' and 'renderer' must be provided\")\nif collector is not None:\nwarnings.warn(\nDeprecationWarning(\n\"The BaseCollector class is deprecated, and passing an instance of it \"\n\"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \"\n\"methods directly on your handler class.\",\n),\nstacklevel=1,\n)\nself.collector = collector\nself.collect = collector.collect  # type: ignore[method-assign]\nself.teardown = collector.teardown  # type: ignore[method-assign]\nif renderer is not None:\nif {handler, theme, custom_templates} != {None}:\nraise ValueError(\n\"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\",\n)\nwarnings.warn(\nDeprecationWarning(\n\"The BaseRenderer class is deprecated, and passing an instance of it \"\n\"to your handler is deprecated as well. Instead, define the `render` method \"\n\"directly on your handler class (as well as other methods and attributes like \"\n\"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\",\n),\nstacklevel=1,\n)\nself.renderer = renderer\nself.render = renderer.render  # type: ignore[method-assign]\nself.get_templates_dir = renderer.get_templates_dir  # type: ignore[method-assign]\nself.get_anchors = renderer.get_anchors  # type: ignore[method-assign]\nself.do_convert_markdown = renderer.do_convert_markdown  # type: ignore[method-assign]\nself.do_heading = renderer.do_heading  # type: ignore[method-assign]\nself.get_headings = renderer.get_headings  # type: ignore[method-assign]\nself.update_env = renderer.update_env  # type: ignore[method-assign]\nself._update_env = renderer._update_env  # type: ignore[method-assign]\nself.fallback_theme = renderer.fallback_theme\nself.extra_css = renderer.extra_css\nrenderer.__class__.__init__(\nself,\nrenderer._handler,\nrenderer._theme,\nrenderer._custom_templates,\n)\nelse:\nif handler is None or theme is None:\nraise ValueError(\"'handler' and 'theme' cannot be None\")\nBaseRenderer.__init__(self, handler, theme, custom_templates)\n@classmethod\ndef load_inventory(\ncls,\nin_file: BinaryIO,  # noqa: ARG003\nurl: str,  # noqa: ARG003\nbase_url: str | None = None,  # noqa: ARG003\n**kwargs: Any,  # noqa: ARG003\n) -&gt; Iterator[tuple[str, str]]:\n\"\"\"Yield items and their URLs from an inventory file streamed from `in_file`.\n        Arguments:\n            in_file: The binary file-like object to read the inventory from.\n            url: The URL that this file is being streamed from (used to guess `base_url`).\n            base_url: The URL that this inventory's sub-paths are relative to.\n            **kwargs: Ignore additional arguments passed from the config.\n        Yields:\n            Tuples of (item identifier, item URL).\n        \"\"\"\nyield from ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str | BaseCollector | BaseRenderer</code> <p>Collector and renderer, or handler name, theme and custom_templates.</p> <code>()</code> <code>**kwargs</code> <code>str | BaseCollector | BaseRenderer</code> <p>Same thing, but with keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the given parameters are invalid.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def __init__(self, *args: str | BaseCollector | BaseRenderer, **kwargs: str | BaseCollector | BaseRenderer) -&gt; None:\n\"\"\"Initialize the object.\n    Arguments:\n        *args: Collector and renderer, or handler name, theme and custom_templates.\n        **kwargs: Same thing, but with keyword arguments.\n    Raises:\n        ValueError: When the given parameters are invalid.\n    \"\"\"\n# The method accepts *args and **kwargs temporarily,\n# to support the transition period where the BaseCollector\n# and BaseRenderer are deprecated, and the BaseHandler\n# can be instantiated with both instances of collector/renderer,\n# or renderer parameters, as positional parameters.\ncollector = None\nrenderer = None\n# parsing positional arguments\nstr_args = []\nfor arg in args:\nif isinstance(arg, BaseCollector):\ncollector = arg\nelif isinstance(arg, BaseRenderer):\nrenderer = arg\nelif isinstance(arg, str):\nstr_args.append(arg)\nwhile len(str_args) != 3:  # noqa: PLR2004\nstr_args.append(None)  # type: ignore[arg-type]\nhandler, theme, custom_templates = str_args\n# fetching values from keyword arguments\nif \"collector\" in kwargs:\ncollector = kwargs.pop(\"collector\")  # type: ignore[assignment]\nif \"renderer\" in kwargs:\nrenderer = kwargs.pop(\"renderer\")  # type: ignore[assignment]\nif \"handler\" in kwargs:\nhandler = kwargs.pop(\"handler\")  # type: ignore[assignment]\nif \"theme\" in kwargs:\ntheme = kwargs.pop(\"theme\")  # type: ignore[assignment]\nif \"custom_templates\" in kwargs:\ncustom_templates = kwargs.pop(\"custom_templates\")  # type: ignore[assignment]\nif collector is None and renderer is not None or collector is not None and renderer is None:\nraise ValueError(\"both 'collector' and 'renderer' must be provided\")\nif collector is not None:\nwarnings.warn(\nDeprecationWarning(\n\"The BaseCollector class is deprecated, and passing an instance of it \"\n\"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \"\n\"methods directly on your handler class.\",\n),\nstacklevel=1,\n)\nself.collector = collector\nself.collect = collector.collect  # type: ignore[method-assign]\nself.teardown = collector.teardown  # type: ignore[method-assign]\nif renderer is not None:\nif {handler, theme, custom_templates} != {None}:\nraise ValueError(\n\"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\",\n)\nwarnings.warn(\nDeprecationWarning(\n\"The BaseRenderer class is deprecated, and passing an instance of it \"\n\"to your handler is deprecated as well. Instead, define the `render` method \"\n\"directly on your handler class (as well as other methods and attributes like \"\n\"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\",\n),\nstacklevel=1,\n)\nself.renderer = renderer\nself.render = renderer.render  # type: ignore[method-assign]\nself.get_templates_dir = renderer.get_templates_dir  # type: ignore[method-assign]\nself.get_anchors = renderer.get_anchors  # type: ignore[method-assign]\nself.do_convert_markdown = renderer.do_convert_markdown  # type: ignore[method-assign]\nself.do_heading = renderer.do_heading  # type: ignore[method-assign]\nself.get_headings = renderer.get_headings  # type: ignore[method-assign]\nself.update_env = renderer.update_env  # type: ignore[method-assign]\nself._update_env = renderer._update_env  # type: ignore[method-assign]\nself.fallback_theme = renderer.fallback_theme\nself.extra_css = renderer.extra_css\nrenderer.__class__.__init__(\nself,\nrenderer._handler,\nrenderer._theme,\nrenderer._custom_templates,\n)\nelse:\nif handler is None or theme is None:\nraise ValueError(\"'handler' and 'theme' cannot be None\")\nBaseRenderer.__init__(self, handler, theme, custom_templates)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.load_inventory","title":"<code>load_inventory(in_file, url, base_url=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Yield items and their URLs from an inventory file streamed from <code>in_file</code>.</p> <p>Parameters:</p> Name Type Description Default <code>in_file</code> <code>BinaryIO</code> <p>The binary file-like object to read the inventory from.</p> required <code>url</code> <code>str</code> <p>The URL that this file is being streamed from (used to guess <code>base_url</code>).</p> required <code>base_url</code> <code>str | None</code> <p>The URL that this inventory's sub-paths are relative to.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Ignore additional arguments passed from the config.</p> <code>{}</code> <p>Yields:</p> Type Description <code>str</code> <p>Tuples of (item identifier, item URL).</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>@classmethod\ndef load_inventory(\ncls,\nin_file: BinaryIO,  # noqa: ARG003\nurl: str,  # noqa: ARG003\nbase_url: str | None = None,  # noqa: ARG003\n**kwargs: Any,  # noqa: ARG003\n) -&gt; Iterator[tuple[str, str]]:\n\"\"\"Yield items and their URLs from an inventory file streamed from `in_file`.\n    Arguments:\n        in_file: The binary file-like object to read the inventory from.\n        url: The URL that this file is being streamed from (used to guess `base_url`).\n        base_url: The URL that this inventory's sub-paths are relative to.\n        **kwargs: Ignore additional arguments passed from the config.\n    Yields:\n        Tuples of (item identifier, item URL).\n    \"\"\"\nyield from ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer","title":"<code>BaseRenderer</code>","text":"<p>The base renderer class.</p> <p>Inherit from this class to implement a renderer.</p> <p>You will have to implement the <code>render</code> method. You can also override the <code>update_env</code> method, to add more filters to the Jinja environment, making them available in your Jinja templates.</p> <p>To define a fallback theme, add a <code>fallback_theme</code> class-variable. To add custom CSS, add an <code>extra_css</code> variable or create an 'style.css' file beside the templates.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class BaseRenderer:\n\"\"\"The base renderer class.\n    Inherit from this class to implement a renderer.\n    You will have to implement the `render` method.\n    You can also override the `update_env` method, to add more filters to the Jinja environment,\n    making them available in your Jinja templates.\n    To define a fallback theme, add a `fallback_theme` class-variable.\n    To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates.\n    \"\"\"\nfallback_theme: str = \"\"\nextra_css = \"\"\ndef __init__(self, handler: str, theme: str, custom_templates: str | None = None) -&gt; None:\n\"\"\"Initialize the object.\n        If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute\n        in `self` to use as a fallback theme.\n        Arguments:\n            handler: The name of the handler.\n            theme: The name of theme to use.\n            custom_templates: Directory containing custom templates.\n        \"\"\"\npaths = []\n# TODO: remove once BaseRenderer is merged into BaseHandler\nself._handler = handler\nself._theme = theme\nself._custom_templates = custom_templates\n# add selected theme templates\nthemes_dir = self.get_templates_dir(handler)\npaths.append(themes_dir / theme)\n# add extended theme templates\nextended_templates_dirs = self.get_extended_templates_dirs(handler)\nfor templates_dir in extended_templates_dirs:\npaths.append(templates_dir / theme)\n# add fallback theme templates\nif self.fallback_theme and self.fallback_theme != theme:\npaths.append(themes_dir / self.fallback_theme)\n# add fallback theme of extended templates\nfor templates_dir in extended_templates_dirs:\npaths.append(templates_dir / self.fallback_theme)\nfor path in paths:\ncss_path = path / \"style.css\"\nif css_path.is_file():\nself.extra_css += \"\\n\" + css_path.read_text(encoding=\"utf-8\")\nbreak\nif custom_templates is not None:\npaths.insert(0, Path(custom_templates) / handler / theme)\nself.env = Environment(\nautoescape=True,\nloader=FileSystemLoader(paths),\nauto_reload=False,  # Editing a template in the middle of a build is not useful.\n)\nself.env.filters[\"any\"] = do_any\nself.env.globals[\"log\"] = get_template_logger()\nself._headings: list[Element] = []\nself._md: Markdown = None  # type: ignore[assignment]  # To be populated in `update_env`.\ndef render(self, data: CollectorItem, config: Mapping[str, Any]) -&gt; str:\n\"\"\"Render a template using provided data and configuration options.\n        Arguments:\n            data: The collected data to render.\n            config: The handler's configuration options.\n        Returns:\n            The rendered template as HTML.\n        \"\"\"\nraise NotImplementedError\ndef get_templates_dir(self, handler: str) -&gt; Path:\n\"\"\"Return the path to the handler's templates directory.\n        Override to customize how the templates directory is found.\n        Arguments:\n            handler: The name of the handler to get the templates directory of.\n        Raises:\n            FileNotFoundError: When the templates directory cannot be found.\n        Returns:\n            The templates directory path.\n        \"\"\"\n# Templates can be found in 2 different logical locations:\n# - in mkdocstrings_handlers/HANDLER/templates: our new migration target\n# - in mkdocstrings/templates/HANDLER: current situation, this should be avoided\n# These two other locations are forbidden:\n# - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with\n# - in mkdocstrings/handlers/HANDLER/templates: not currently supported,\n#   and mkdocstrings will stop being a namespace\nwith suppress(ModuleNotFoundError):  # TODO: catch at some point to warn about missing handlers\nimport mkdocstrings_handlers\nfor path in mkdocstrings_handlers.__path__:\ntheme_path = Path(path, handler, \"templates\")\nif theme_path.exists():\nreturn theme_path\n# TODO: remove import and loop at some point,\n# as mkdocstrings will stop being a namespace package\nimport mkdocstrings\nfor path in mkdocstrings.__path__:\ntheme_path = Path(path, \"templates\", handler)\nif theme_path.exists():\nif handler != \"python\":\nwarnings.warn(\n\"Exposing templates in the mkdocstrings.templates namespace is deprecated. \"\n\"Put them in a templates folder inside your handler package instead.\",\nDeprecationWarning,\nstacklevel=1,\n)\nreturn theme_path\nraise FileNotFoundError(f\"Can't find 'templates' folder for handler '{handler}'\")\ndef get_extended_templates_dirs(self, handler: str) -&gt; list[Path]:\n\"\"\"Load template extensions for the given handler, return their templates directories.\n        Arguments:\n            handler: The name of the handler to get the extended templates directory of.\n        Returns:\n            The extensions templates directories.\n        \"\"\"\ndiscovered_extensions = entry_points(group=f\"mkdocstrings.{handler}.templates\")\nreturn [extension.load()() for extension in discovered_extensions]\ndef get_anchors(self, data: CollectorItem) -&gt; tuple[str, ...] | set[str]:\n\"\"\"Return the possible identifiers (HTML anchors) for a collected item.\n        Arguments:\n            data: The collected data.\n        Returns:\n            The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.\n        \"\"\"\n# TODO: remove this at some point\ntry:\nreturn (self.get_anchor(data),)  # type: ignore[attr-defined]\nexcept AttributeError:\nreturn ()\ndef do_convert_markdown(\nself,\ntext: str,\nheading_level: int,\nhtml_id: str = \"\",\n*,\nstrip_paragraph: bool = False,\n) -&gt; Markup:\n\"\"\"Render Markdown text; for use inside templates.\n        Arguments:\n            text: The text to convert.\n            heading_level: The base heading level to start all Markdown headings from.\n            html_id: The HTML id of the element that's considered the parent of this element.\n            strip_paragraph: Whether to exclude the &lt;p&gt; tag from around the whole output.\n        Returns:\n            An HTML string.\n        \"\"\"\ntreeprocessors = self._md.treeprocessors\ntreeprocessors[HeadingShiftingTreeprocessor.name].shift_by = heading_level\ntreeprocessors[IdPrependingTreeprocessor.name].id_prefix = html_id and html_id + \"--\"\ntreeprocessors[ParagraphStrippingTreeprocessor.name].strip = strip_paragraph\ntry:\nreturn Markup(self._md.convert(text))\nfinally:\ntreeprocessors[HeadingShiftingTreeprocessor.name].shift_by = 0\ntreeprocessors[IdPrependingTreeprocessor.name].id_prefix = \"\"\ntreeprocessors[ParagraphStrippingTreeprocessor.name].strip = False\nself._md.reset()\ndef do_heading(\nself,\ncontent: Markup,\nheading_level: int,\n*,\nrole: str | None = None,\nhidden: bool = False,\ntoc_label: str | None = None,\n**attributes: str,\n) -&gt; Markup:\n\"\"\"Render an HTML heading and register it for the table of contents. For use inside templates.\n        Arguments:\n            content: The HTML within the heading.\n            heading_level: The level of heading (e.g. 3 -&gt; `h3`).\n            role: An optional role for the object bound to this heading.\n            hidden: If True, only register it for the table of contents, don't render anything.\n            toc_label: The title to use in the table of contents ('data-toc-label' attribute).\n            **attributes: Any extra HTML attributes of the heading.\n        Returns:\n            An HTML string.\n        \"\"\"\n# First, produce the \"fake\" heading, for ToC only.\nel = Element(f\"h{heading_level}\", attributes)\nif toc_label is None:\ntoc_label = content.unescape() if isinstance(content, Markup) else content\nel.set(\"data-toc-label\", toc_label)\nif role:\nel.set(\"data-role\", role)\nself._headings.append(el)\nif hidden:\nreturn Markup('&lt;a id=\"{0}\"&gt;&lt;/a&gt;').format(attributes[\"id\"])\n# Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading.\n# Start with a heading that has just attributes (no text), and add a placeholder into it.\nel = Element(f\"h{heading_level}\", attributes)\nel.append(Element(\"mkdocstrings-placeholder\"))\n# Tell the 'toc' extension to make its additions if configured so.\ntoc = self._md.treeprocessors[\"toc\"]\nif toc.use_anchors:\ntoc.add_anchor(el, attributes[\"id\"])\nif toc.use_permalinks:\ntoc.add_permalink(el, attributes[\"id\"])\n# The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle\n# of the heading with a placeholder that can never occur (text can't directly contain angle brackets).\n# Now this HTML wrapper can be \"filled\" by replacing the placeholder.\nhtml_with_placeholder = tostring(el, encoding=\"unicode\")\nassert (  # noqa: S101\nhtml_with_placeholder.count(\"&lt;mkdocstrings-placeholder /&gt;\") == 1\n), f\"Bug in mkdocstrings: failed to replace in {html_with_placeholder!r}\"\nhtml = html_with_placeholder.replace(\"&lt;mkdocstrings-placeholder /&gt;\", content)\nreturn Markup(html)\ndef get_headings(self) -&gt; Sequence[Element]:\n\"\"\"Return and clear the headings gathered so far.\n        Returns:\n            A list of HTML elements.\n        \"\"\"\nresult = list(self._headings)\nself._headings.clear()\nreturn result\ndef update_env(self, md: Markdown, config: dict) -&gt; None:  # noqa: ARG002\n\"\"\"Update the Jinja environment.\n        Arguments:\n            md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.\n            config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n                of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n        \"\"\"\nself._md = md\nself.env.filters[\"highlight\"] = Highlighter(md).highlight\nself.env.filters[\"convert_markdown\"] = self.do_convert_markdown\nself.env.filters[\"heading\"] = self.do_heading\ndef _update_env(self, md: Markdown, config: dict) -&gt; None:\n\"\"\"Update our handler to point to our configured Markdown instance, grabbing some of the config from `md`.\"\"\"\nextensions = config[\"mdx\"] + [MkdocstringsInnerExtension(self._headings)]\nnew_md = Markdown(extensions=extensions, extension_configs=config[\"mdx_configs\"])\n# MkDocs adds its own (required) extension that's not part of the config. Propagate it.\nif \"relpath\" in md.treeprocessors:\nnew_md.treeprocessors.register(md.treeprocessors[\"relpath\"], \"relpath\", priority=0)\nself.update_env(new_md, config)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.__init__","title":"<code>__init__(handler, theme, custom_templates=None)</code>","text":"<p>Initialize the object.</p> <p>If the given theme is not supported (it does not exist), it will look for a <code>fallback_theme</code> attribute in <code>self</code> to use as a fallback theme.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str</code> <p>The name of the handler.</p> required <code>theme</code> <code>str</code> <p>The name of theme to use.</p> required <code>custom_templates</code> <code>str | None</code> <p>Directory containing custom templates.</p> <code>None</code> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def __init__(self, handler: str, theme: str, custom_templates: str | None = None) -&gt; None:\n\"\"\"Initialize the object.\n    If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute\n    in `self` to use as a fallback theme.\n    Arguments:\n        handler: The name of the handler.\n        theme: The name of theme to use.\n        custom_templates: Directory containing custom templates.\n    \"\"\"\npaths = []\n# TODO: remove once BaseRenderer is merged into BaseHandler\nself._handler = handler\nself._theme = theme\nself._custom_templates = custom_templates\n# add selected theme templates\nthemes_dir = self.get_templates_dir(handler)\npaths.append(themes_dir / theme)\n# add extended theme templates\nextended_templates_dirs = self.get_extended_templates_dirs(handler)\nfor templates_dir in extended_templates_dirs:\npaths.append(templates_dir / theme)\n# add fallback theme templates\nif self.fallback_theme and self.fallback_theme != theme:\npaths.append(themes_dir / self.fallback_theme)\n# add fallback theme of extended templates\nfor templates_dir in extended_templates_dirs:\npaths.append(templates_dir / self.fallback_theme)\nfor path in paths:\ncss_path = path / \"style.css\"\nif css_path.is_file():\nself.extra_css += \"\\n\" + css_path.read_text(encoding=\"utf-8\")\nbreak\nif custom_templates is not None:\npaths.insert(0, Path(custom_templates) / handler / theme)\nself.env = Environment(\nautoescape=True,\nloader=FileSystemLoader(paths),\nauto_reload=False,  # Editing a template in the middle of a build is not useful.\n)\nself.env.filters[\"any\"] = do_any\nself.env.globals[\"log\"] = get_template_logger()\nself._headings: list[Element] = []\nself._md: Markdown = None  # type: ignore[assignment]  # To be populated in `update_env`.\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.do_convert_markdown","title":"<code>do_convert_markdown(text, heading_level, html_id='', *, strip_paragraph=False)</code>","text":"<p>Render Markdown text; for use inside templates.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to convert.</p> required <code>heading_level</code> <code>int</code> <p>The base heading level to start all Markdown headings from.</p> required <code>html_id</code> <code>str</code> <p>The HTML id of the element that's considered the parent of this element.</p> <code>''</code> <code>strip_paragraph</code> <code>bool</code> <p>Whether to exclude the <p> tag from around the whole output.</p> <code>False</code> <p>Returns:</p> Type Description <code>Markup</code> <p>An HTML string.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_convert_markdown(\nself,\ntext: str,\nheading_level: int,\nhtml_id: str = \"\",\n*,\nstrip_paragraph: bool = False,\n) -&gt; Markup:\n\"\"\"Render Markdown text; for use inside templates.\n    Arguments:\n        text: The text to convert.\n        heading_level: The base heading level to start all Markdown headings from.\n        html_id: The HTML id of the element that's considered the parent of this element.\n        strip_paragraph: Whether to exclude the &lt;p&gt; tag from around the whole output.\n    Returns:\n        An HTML string.\n    \"\"\"\ntreeprocessors = self._md.treeprocessors\ntreeprocessors[HeadingShiftingTreeprocessor.name].shift_by = heading_level\ntreeprocessors[IdPrependingTreeprocessor.name].id_prefix = html_id and html_id + \"--\"\ntreeprocessors[ParagraphStrippingTreeprocessor.name].strip = strip_paragraph\ntry:\nreturn Markup(self._md.convert(text))\nfinally:\ntreeprocessors[HeadingShiftingTreeprocessor.name].shift_by = 0\ntreeprocessors[IdPrependingTreeprocessor.name].id_prefix = \"\"\ntreeprocessors[ParagraphStrippingTreeprocessor.name].strip = False\nself._md.reset()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.do_heading","title":"<code>do_heading(content, heading_level, *, role=None, hidden=False, toc_label=None, **attributes)</code>","text":"<p>Render an HTML heading and register it for the table of contents. For use inside templates.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Markup</code> <p>The HTML within the heading.</p> required <code>heading_level</code> <code>int</code> <p>The level of heading (e.g. 3 -&gt; <code>h3</code>).</p> required <code>role</code> <code>str | None</code> <p>An optional role for the object bound to this heading.</p> <code>None</code> <code>hidden</code> <code>bool</code> <p>If True, only register it for the table of contents, don't render anything.</p> <code>False</code> <code>toc_label</code> <code>str | None</code> <p>The title to use in the table of contents ('data-toc-label' attribute).</p> <code>None</code> <code>**attributes</code> <code>str</code> <p>Any extra HTML attributes of the heading.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Markup</code> <p>An HTML string.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_heading(\nself,\ncontent: Markup,\nheading_level: int,\n*,\nrole: str | None = None,\nhidden: bool = False,\ntoc_label: str | None = None,\n**attributes: str,\n) -&gt; Markup:\n\"\"\"Render an HTML heading and register it for the table of contents. For use inside templates.\n    Arguments:\n        content: The HTML within the heading.\n        heading_level: The level of heading (e.g. 3 -&gt; `h3`).\n        role: An optional role for the object bound to this heading.\n        hidden: If True, only register it for the table of contents, don't render anything.\n        toc_label: The title to use in the table of contents ('data-toc-label' attribute).\n        **attributes: Any extra HTML attributes of the heading.\n    Returns:\n        An HTML string.\n    \"\"\"\n# First, produce the \"fake\" heading, for ToC only.\nel = Element(f\"h{heading_level}\", attributes)\nif toc_label is None:\ntoc_label = content.unescape() if isinstance(content, Markup) else content\nel.set(\"data-toc-label\", toc_label)\nif role:\nel.set(\"data-role\", role)\nself._headings.append(el)\nif hidden:\nreturn Markup('&lt;a id=\"{0}\"&gt;&lt;/a&gt;').format(attributes[\"id\"])\n# Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading.\n# Start with a heading that has just attributes (no text), and add a placeholder into it.\nel = Element(f\"h{heading_level}\", attributes)\nel.append(Element(\"mkdocstrings-placeholder\"))\n# Tell the 'toc' extension to make its additions if configured so.\ntoc = self._md.treeprocessors[\"toc\"]\nif toc.use_anchors:\ntoc.add_anchor(el, attributes[\"id\"])\nif toc.use_permalinks:\ntoc.add_permalink(el, attributes[\"id\"])\n# The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle\n# of the heading with a placeholder that can never occur (text can't directly contain angle brackets).\n# Now this HTML wrapper can be \"filled\" by replacing the placeholder.\nhtml_with_placeholder = tostring(el, encoding=\"unicode\")\nassert (  # noqa: S101\nhtml_with_placeholder.count(\"&lt;mkdocstrings-placeholder /&gt;\") == 1\n), f\"Bug in mkdocstrings: failed to replace in {html_with_placeholder!r}\"\nhtml = html_with_placeholder.replace(\"&lt;mkdocstrings-placeholder /&gt;\", content)\nreturn Markup(html)\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_anchors","title":"<code>get_anchors(data)</code>","text":"<p>Return the possible identifiers (HTML anchors) for a collected item.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CollectorItem</code> <p>The collected data.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...] | set[str]</code> <p>The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_anchors(self, data: CollectorItem) -&gt; tuple[str, ...] | set[str]:\n\"\"\"Return the possible identifiers (HTML anchors) for a collected item.\n    Arguments:\n        data: The collected data.\n    Returns:\n        The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor.\n    \"\"\"\n# TODO: remove this at some point\ntry:\nreturn (self.get_anchor(data),)  # type: ignore[attr-defined]\nexcept AttributeError:\nreturn ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_extended_templates_dirs","title":"<code>get_extended_templates_dirs(handler)</code>","text":"<p>Load template extensions for the given handler, return their templates directories.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str</code> <p>The name of the handler to get the extended templates directory of.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>The extensions templates directories.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_extended_templates_dirs(self, handler: str) -&gt; list[Path]:\n\"\"\"Load template extensions for the given handler, return their templates directories.\n    Arguments:\n        handler: The name of the handler to get the extended templates directory of.\n    Returns:\n        The extensions templates directories.\n    \"\"\"\ndiscovered_extensions = entry_points(group=f\"mkdocstrings.{handler}.templates\")\nreturn [extension.load()() for extension in discovered_extensions]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_headings","title":"<code>get_headings()</code>","text":"<p>Return and clear the headings gathered so far.</p> <p>Returns:</p> Type Description <code>Sequence[Element]</code> <p>A list of HTML elements.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_headings(self) -&gt; Sequence[Element]:\n\"\"\"Return and clear the headings gathered so far.\n    Returns:\n        A list of HTML elements.\n    \"\"\"\nresult = list(self._headings)\nself._headings.clear()\nreturn result\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_templates_dir","title":"<code>get_templates_dir(handler)</code>","text":"<p>Return the path to the handler's templates directory.</p> <p>Override to customize how the templates directory is found.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>str</code> <p>The name of the handler to get the templates directory of.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>When the templates directory cannot be found.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The templates directory path.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_templates_dir(self, handler: str) -&gt; Path:\n\"\"\"Return the path to the handler's templates directory.\n    Override to customize how the templates directory is found.\n    Arguments:\n        handler: The name of the handler to get the templates directory of.\n    Raises:\n        FileNotFoundError: When the templates directory cannot be found.\n    Returns:\n        The templates directory path.\n    \"\"\"\n# Templates can be found in 2 different logical locations:\n# - in mkdocstrings_handlers/HANDLER/templates: our new migration target\n# - in mkdocstrings/templates/HANDLER: current situation, this should be avoided\n# These two other locations are forbidden:\n# - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with\n# - in mkdocstrings/handlers/HANDLER/templates: not currently supported,\n#   and mkdocstrings will stop being a namespace\nwith suppress(ModuleNotFoundError):  # TODO: catch at some point to warn about missing handlers\nimport mkdocstrings_handlers\nfor path in mkdocstrings_handlers.__path__:\ntheme_path = Path(path, handler, \"templates\")\nif theme_path.exists():\nreturn theme_path\n# TODO: remove import and loop at some point,\n# as mkdocstrings will stop being a namespace package\nimport mkdocstrings\nfor path in mkdocstrings.__path__:\ntheme_path = Path(path, \"templates\", handler)\nif theme_path.exists():\nif handler != \"python\":\nwarnings.warn(\n\"Exposing templates in the mkdocstrings.templates namespace is deprecated. \"\n\"Put them in a templates folder inside your handler package instead.\",\nDeprecationWarning,\nstacklevel=1,\n)\nreturn theme_path\nraise FileNotFoundError(f\"Can't find 'templates' folder for handler '{handler}'\")\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.render","title":"<code>render(data, config)</code>","text":"<p>Render a template using provided data and configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CollectorItem</code> <p>The collected data to render.</p> required <code>config</code> <code>Mapping[str, Any]</code> <p>The handler's configuration options.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The rendered template as HTML.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def render(self, data: CollectorItem, config: Mapping[str, Any]) -&gt; str:\n\"\"\"Render a template using provided data and configuration options.\n    Arguments:\n        data: The collected data to render.\n        config: The handler's configuration options.\n    Returns:\n        The rendered template as HTML.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.update_env","title":"<code>update_env(md, config)</code>","text":"<p>Update the Jinja environment.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Markdown</code> <p>The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.</p> required <code>config</code> <code>dict</code> <p>Configuration options for <code>mkdocs</code> and <code>mkdocstrings</code>, read from <code>mkdocs.yml</code>. See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def update_env(self, md: Markdown, config: dict) -&gt; None:  # noqa: ARG002\n\"\"\"Update the Jinja environment.\n    Arguments:\n        md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters.\n        config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n            of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n    \"\"\"\nself._md = md\nself.env.filters[\"highlight\"] = Highlighter(md).highlight\nself.env.filters[\"convert_markdown\"] = self.do_convert_markdown\nself.env.filters[\"heading\"] = self.do_heading\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.CollectionError","title":"<code>CollectionError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>An exception raised when some collection of data failed.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class CollectionError(Exception):\n\"\"\"An exception raised when some collection of data failed.\"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers","title":"<code>Handlers</code>","text":"<p>A collection of handlers.</p> <p>Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class Handlers:\n\"\"\"A collection of handlers.\n    Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of\n    this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access.\n    \"\"\"\ndef __init__(self, config: dict) -&gt; None:\n\"\"\"Initialize the object.\n        Arguments:\n            config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n                of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n        \"\"\"\nself._config = config\nself._handlers: dict[str, BaseHandler] = {}\nself.inventory: Inventory = Inventory(project=self._config[\"mkdocs\"][\"site_name\"])\ndef get_anchors(self, identifier: str) -&gt; tuple[str, ...] | set[str]:\n\"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.\n        Arguments:\n            identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept).\n        Returns:\n            A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.\n        \"\"\"\nfor handler in self._handlers.values():\nfallback_config = getattr(handler, \"fallback_config\", {})\ntry:\nanchors = handler.get_anchors(handler.collect(identifier, fallback_config))\nexcept CollectionError:\ncontinue\nif anchors:\nreturn anchors\nreturn ()\ndef get_handler_name(self, config: dict) -&gt; str:\n\"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.\n        Arguments:\n            config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.\n        Returns:\n            The name of the handler to use.\n        \"\"\"\nglobal_config = self._config[\"mkdocstrings\"]\nif \"handler\" in config:\nreturn config[\"handler\"]\nreturn global_config[\"default_handler\"]\ndef get_handler_config(self, name: str) -&gt; dict:\n\"\"\"Return the global configuration of the given handler.\n        Arguments:\n            name: The name of the handler to get the global configuration of.\n        Returns:\n            The global configuration of the given handler. It can be an empty dictionary.\n        \"\"\"\nhandlers = self._config[\"mkdocstrings\"].get(\"handlers\", {})\nif handlers:\nreturn handlers.get(name, {})\nreturn {}\ndef get_handler(self, name: str, handler_config: dict | None = None) -&gt; BaseHandler:\n\"\"\"Get a handler thanks to its name.\n        This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its\n        `get_handler` method to get an instance of a handler, and caches it in dictionary.\n        It means that during one run (for each reload when serving, or once when building),\n        a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.\n        Arguments:\n            name: The name of the handler. Really, it's the name of the Python module holding it.\n            handler_config: Configuration passed to the handler.\n        Returns:\n            An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler],\n                as instantiated by the `get_handler` method of the handler's module.\n        \"\"\"\nif name not in self._handlers:\nif handler_config is None:\nhandler_config = self.get_handler_config(name)\nhandler_config.update(self._config)\ntry:\nmodule = importlib.import_module(f\"mkdocstrings_handlers.{name}\")\nexcept ModuleNotFoundError:\nmodule = importlib.import_module(f\"mkdocstrings.handlers.{name}\")\nif name != \"python\":\nwarnings.warn(\nDeprecationWarning(\n\"Using the mkdocstrings.handlers namespace is deprecated. \"\n\"Handlers must now use the mkdocstrings_handlers namespace.\",\n),\nstacklevel=1,\n)\nself._handlers[name] = module.get_handler(\ntheme=self._config[\"theme_name\"],\ncustom_templates=self._config[\"mkdocstrings\"][\"custom_templates\"],\nconfig_file_path=self._config[\"mkdocs\"][\"config_file_path\"],\n**handler_config,\n)\nreturn self._handlers[name]\n@property\ndef seen_handlers(self) -&gt; Iterable[BaseHandler]:\n\"\"\"Get the handlers that were encountered so far throughout the build.\n        Returns:\n            An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]\n            (usable only to loop through it).\n        \"\"\"\nreturn self._handlers.values()\ndef teardown(self) -&gt; None:\n\"\"\"Teardown all cached handlers and clear the cache.\"\"\"\nfor handler in self.seen_handlers:\nhandler.teardown()\nself._handlers.clear()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.seen_handlers","title":"<code>seen_handlers: Iterable[BaseHandler]</code>  <code>property</code>","text":"<p>Get the handlers that were encountered so far throughout the build.</p> <p>Returns:</p> Type Description <code>Iterable[BaseHandler]</code> <p>An iterable of instances of <code>BaseHandler</code></p> <code>Iterable[BaseHandler]</code> <p>(usable only to loop through it).</p>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Configuration options for <code>mkdocs</code> and <code>mkdocstrings</code>, read from <code>mkdocs.yml</code>. See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary.</p> required Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def __init__(self, config: dict) -&gt; None:\n\"\"\"Initialize the object.\n    Arguments:\n        config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code\n            of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary.\n    \"\"\"\nself._config = config\nself._handlers: dict[str, BaseHandler] = {}\nself.inventory: Inventory = Inventory(project=self._config[\"mkdocs\"][\"site_name\"])\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_anchors","title":"<code>get_anchors(identifier)</code>","text":"<p>Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier (one that collect can accept).</p> required <p>Returns:</p> Type Description <code>tuple[str, ...] | set[str]</code> <p>A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_anchors(self, identifier: str) -&gt; tuple[str, ...] | set[str]:\n\"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it.\n    Arguments:\n        identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept).\n    Returns:\n        A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it.\n    \"\"\"\nfor handler in self._handlers.values():\nfallback_config = getattr(handler, \"fallback_config\", {})\ntry:\nanchors = handler.get_anchors(handler.collect(identifier, fallback_config))\nexcept CollectionError:\ncontinue\nif anchors:\nreturn anchors\nreturn ()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler","title":"<code>get_handler(name, handler_config=None)</code>","text":"<p>Get a handler thanks to its name.</p> <p>This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its <code>get_handler</code> method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the handler. Really, it's the name of the Python module holding it.</p> required <code>handler_config</code> <code>dict | None</code> <p>Configuration passed to the handler.</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseHandler</code> <p>An instance of a subclass of <code>BaseHandler</code>, as instantiated by the <code>get_handler</code> method of the handler's module.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler(self, name: str, handler_config: dict | None = None) -&gt; BaseHandler:\n\"\"\"Get a handler thanks to its name.\n    This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its\n    `get_handler` method to get an instance of a handler, and caches it in dictionary.\n    It means that during one run (for each reload when serving, or once when building),\n    a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it.\n    Arguments:\n        name: The name of the handler. Really, it's the name of the Python module holding it.\n        handler_config: Configuration passed to the handler.\n    Returns:\n        An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler],\n            as instantiated by the `get_handler` method of the handler's module.\n    \"\"\"\nif name not in self._handlers:\nif handler_config is None:\nhandler_config = self.get_handler_config(name)\nhandler_config.update(self._config)\ntry:\nmodule = importlib.import_module(f\"mkdocstrings_handlers.{name}\")\nexcept ModuleNotFoundError:\nmodule = importlib.import_module(f\"mkdocstrings.handlers.{name}\")\nif name != \"python\":\nwarnings.warn(\nDeprecationWarning(\n\"Using the mkdocstrings.handlers namespace is deprecated. \"\n\"Handlers must now use the mkdocstrings_handlers namespace.\",\n),\nstacklevel=1,\n)\nself._handlers[name] = module.get_handler(\ntheme=self._config[\"theme_name\"],\ncustom_templates=self._config[\"mkdocstrings\"][\"custom_templates\"],\nconfig_file_path=self._config[\"mkdocs\"][\"config_file_path\"],\n**handler_config,\n)\nreturn self._handlers[name]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_config","title":"<code>get_handler_config(name)</code>","text":"<p>Return the global configuration of the given handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the handler to get the global configuration of.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The global configuration of the given handler. It can be an empty dictionary.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler_config(self, name: str) -&gt; dict:\n\"\"\"Return the global configuration of the given handler.\n    Arguments:\n        name: The name of the handler to get the global configuration of.\n    Returns:\n        The global configuration of the given handler. It can be an empty dictionary.\n    \"\"\"\nhandlers = self._config[\"mkdocstrings\"].get(\"handlers\", {})\nif handlers:\nreturn handlers.get(name, {})\nreturn {}\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_name","title":"<code>get_handler_name(config)</code>","text":"<p>Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the handler to use.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def get_handler_name(self, config: dict) -&gt; str:\n\"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler.\n    Arguments:\n        config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction.\n    Returns:\n        The name of the handler to use.\n    \"\"\"\nglobal_config = self._config[\"mkdocstrings\"]\nif \"handler\" in config:\nreturn config[\"handler\"]\nreturn global_config[\"default_handler\"]\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.teardown","title":"<code>teardown()</code>","text":"<p>Teardown all cached handlers and clear the cache.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def teardown(self) -&gt; None:\n\"\"\"Teardown all cached handlers and clear the cache.\"\"\"\nfor handler in self.seen_handlers:\nhandler.teardown()\nself._handlers.clear()\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.ThemeNotSupported","title":"<code>ThemeNotSupported</code>","text":"<p>         Bases: <code>Exception</code></p> <p>An exception raised to tell a theme is not supported.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>class ThemeNotSupported(Exception):  # noqa: N818\n\"\"\"An exception raised to tell a theme is not supported.\"\"\"\n</code></pre>"},{"location":"docstrings/#mkdocstrings.handlers.base.do_any","title":"<code>do_any(seq, attribute=None)</code>","text":"<p>Check if at least one of the item in the sequence evaluates to true.</p> <p>The <code>any</code> builtin as a filter for Jinja templates.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>Sequence</code> <p>An iterable object.</p> required <code>attribute</code> <code>str | None</code> <p>The attribute name to use on each object of the iterable.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean telling if any object of the iterable evaluated to True.</p> Source code in <code>.venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py</code> <pre><code>def do_any(seq: Sequence, attribute: str | None = None) -&gt; bool:\n\"\"\"Check if at least one of the item in the sequence evaluates to true.\n    The `any` builtin as a filter for Jinja templates.\n    Arguments:\n        seq: An iterable object.\n        attribute: The attribute name to use on each object of the iterable.\n    Returns:\n        A boolean telling if any object of the iterable evaluated to True.\n    \"\"\"\nif attribute is None:\nreturn any(seq)\nreturn any(_[attribute] for _ in seq)\n</code></pre>"},{"location":"mermaid/","title":"Mermaid","text":"<p>See Material for MkDocs diagrams documentation for a complete reference.</p> <p>Those examples are extracted from the Mermaid documentation and are the most complexes found to showcase all styles and possibilities.</p> <p>Some have a <code>Syntax error in graph</code> instead of the diagram: it means that <code>mkdocs-material</code>'s <code>mermaid.js</code> version does not support them yet.</p>"},{"location":"mermaid/#flowchart","title":"Flowchart","text":"<pre><code>flowchart LR\n    A[Hard edge] --&gt;|Link text| B(Round edge)\n    B --&gt; C{Decision}\n    C --&gt;|One| D[Result one]\n    C --&gt;|Two| E[Result two]</code></pre>"},{"location":"mermaid/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n    par Alice to Bob\n        Alice-&gt;&gt;Bob: Go help John\n    and Alice to John\n        Alice-&gt;&gt;John: I want this done today\n        par John to Charlie\n            John-&gt;&gt;Charlie: Can we do this today?\n        and John to Diana\n            John-&gt;&gt;Diana: Can you help us today?\n        end\n    end</code></pre>"},{"location":"mermaid/#class-diagram","title":"Class diagram","text":"<pre><code>---\ntitle: Animal example\n---\nclassDiagram\n    note \"From Duck till Zebra\"\n    Animal &lt;|-- Duck\n    note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\n    Animal &lt;|-- Fish\n    Animal &lt;|-- Zebra\n    Animal : +int age\n    Animal : +String gender\n    Animal: +isMammal()\n    Animal: +mate()\n    class Duck{\n        +String beakColor\n        +swim()\n        +quack()\n    }\n    class Fish{\n        -int sizeInFeet\n        -canEat()\n    }\n    class Zebra{\n        +bool is_wild\n        +run()\n    }</code></pre>"},{"location":"mermaid/#state-diagram","title":"State diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Active\n\n    state Active {\n        [*] --&gt; NumLockOff\n        NumLockOff --&gt; NumLockOn : EvNumLockPressed\n        NumLockOn --&gt; NumLockOff : EvNumLockPressed\n        --\n        [*] --&gt; CapsLockOff\n        CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed\n        CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed\n        --\n        [*] --&gt; ScrollLockOff\n        ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed\n    }</code></pre>"},{"location":"mermaid/#entity-relationship-diagram","title":"Entity Relationship diagram","text":"<pre><code>erDiagram\n    CAR ||--o{ NAMED-DRIVER : allows\n    CAR {\n        string registrationNumber PK\n        string make\n        string model\n        string[] parts\n    }\n    PERSON ||--o{ NAMED-DRIVER : is\n    PERSON {\n        string driversLicense PK \"The license #\"\n        string(99) firstName \"Only 99 characters are allowed\"\n        string lastName\n        string phone UK\n        int age\n    }\n    NAMED-DRIVER {\n        string carRegistrationNumber PK, FK\n        string driverLicence PK, FK\n    }\n    MANUFACTURER only one to zero or more CAR : makes</code></pre>"},{"location":"mermaid/#gantt","title":"Gantt","text":"<pre><code>gantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :1d\n    Functionality added                 :milestone, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h</code></pre>"},{"location":"mermaid/#pie-chart","title":"Pie Chart","text":"<pre><code>%%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%%\npie showData\n    title Key elements in Product X\n    \"Calcium\" : 42.96\n    \"Potassium\" : 50.05\n    \"Magnesium\" : 10.01\n    \"Iron\" :  5</code></pre>"},{"location":"mermaid/#requirement-diagram","title":"Requirement Diagram","text":"<pre><code> requirementDiagram\n\n    requirement test_req {\n    id: 1\n    text: the test text.\n    risk: high\n    verifymethod: test\n    }\n\n    functionalRequirement test_req2 {\n    id: 1.1\n    text: the second test text.\n    risk: low\n    verifymethod: inspection\n    }\n\n    performanceRequirement test_req3 {\n    id: 1.2\n    text: the third test text.\n    risk: medium\n    verifymethod: demonstration\n    }\n\n    interfaceRequirement test_req4 {\n    id: 1.2.1\n    text: the fourth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    physicalRequirement test_req5 {\n    id: 1.2.2\n    text: the fifth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    designConstraint test_req6 {\n    id: 1.2.3\n    text: the sixth test text.\n    risk: medium\n    verifymethod: analysis\n    }\n\n    element test_entity {\n    type: simulation\n    }\n\n    element test_entity2 {\n    type: word doc\n    docRef: reqs/test_entity\n    }\n\n    element test_entity3 {\n    type: \"test suite\"\n    docRef: github.com/all_the_tests\n    }\n\n\n    test_entity - satisfies -&gt; test_req2\n    test_req - traces -&gt; test_req2\n    test_req - contains -&gt; test_req3\n    test_req3 - contains -&gt; test_req4\n    test_req4 - derives -&gt; test_req5\n    test_req5 - refines -&gt; test_req6\n    test_entity3 - verifies -&gt; test_req5\n    test_req &lt;- copies - test_entity2</code></pre>"},{"location":"mermaid/#gitgraph","title":"GitGraph","text":"<pre><code>gitGraph:\n    commit \"Ashish\"\n    branch newbranch\n    checkout newbranch\n    commit id:\"1111\"\n    commit tag:\"test\"\n    checkout main\n    commit type: HIGHLIGHT\n    commit\n    merge newbranch\n    commit\n    branch b2\n    commit</code></pre>"},{"location":"mermaid/#c4-diagrams","title":"C4 Diagrams","text":""},{"location":"mermaid/#system-context","title":"System Context","text":"<pre><code>  C4Context\n      title System Context diagram for Internet Banking System\n      Enterprise_Boundary(b0, \"BankBoundary0\") {\n        Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\")\n        Person(customerB, \"Banking Customer B\")\n        Person_Ext(customerC, \"Banking Customer C\", \"desc\")\n\n        Person(customerD, \"Banking Customer D\", \"A customer of the bank, &lt;br/&gt; with personal bank accounts.\")\n\n        System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\")\n\n        Enterprise_Boundary(b1, \"BankBoundary\") {\n\n          SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n          System_Boundary(b2, \"BankBoundary2\") {\n            System(SystemA, \"Banking System A\")\n            System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\")\n          }\n\n          System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\")\n          SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\")\n\n          Boundary(b3, \"BankBoundary3\", \"boundary\") {\n            SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\")\n            SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\")\n          }\n        }\n      }\n\n      BiRel(customerA, SystemAA, \"Uses\")\n      BiRel(SystemAA, SystemE, \"Uses\")\n      Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\")\n      Rel(SystemC, customerA, \"Sends e-mails to\")\n\n      UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\")\n      UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\")\n      UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\")\n      UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\")\n      UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\")\n\n      UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")</code></pre>"},{"location":"mermaid/#container","title":"Container","text":"<pre><code>    C4Container\n    title Container diagram for Internet Banking System\n\n    System_Ext(email_system, \"E-Mail System\", \"The internal Microsoft Exchange system\", $tags=\"v1.0\")\n    Person(customer, Customer, \"A customer of the bank, with personal bank accounts\", $tags=\"v1.0\")\n\n    Container_Boundary(c1, \"Internet Banking\") {\n        Container(spa, \"Single-Page App\", \"JavaScript, Angular\", \"Provides all the Internet banking functionality to cutomers via their web browser\")\n        Container_Ext(mobile_app, \"Mobile App\", \"C#, Xamarin\", \"Provides a limited subset of the Internet banking functionality to customers via their mobile device\")\n        Container(web_app, \"Web Application\", \"Java, Spring MVC\", \"Delivers the static content and the Internet banking SPA\")\n        ContainerDb(database, \"Database\", \"SQL Database\", \"Stores user registration information, hashed auth credentials, access logs, etc.\")\n        ContainerDb_Ext(backend_api, \"API Application\", \"Java, Docker Container\", \"Provides Internet banking functionality via API\")\n\n    }\n\n    System_Ext(banking_system, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n    Rel(customer, web_app, \"Uses\", \"HTTPS\")\n    UpdateRelStyle(customer, web_app, $offsetY=\"60\", $offsetX=\"90\")\n    Rel(customer, spa, \"Uses\", \"HTTPS\")\n    UpdateRelStyle(customer, spa, $offsetY=\"-40\")\n    Rel(customer, mobile_app, \"Uses\")\n    UpdateRelStyle(customer, mobile_app, $offsetY=\"-30\")\n\n    Rel(web_app, spa, \"Delivers\")\n    UpdateRelStyle(web_app, spa, $offsetX=\"130\")\n    Rel(spa, backend_api, \"Uses\", \"async, JSON/HTTPS\")\n    Rel(mobile_app, backend_api, \"Uses\", \"async, JSON/HTTPS\")\n    Rel_Back(database, backend_api, \"Reads from and writes to\", \"sync, JDBC\")\n\n    Rel(email_system, customer, \"Sends e-mails to\")\n    UpdateRelStyle(email_system, customer, $offsetX=\"-45\")\n    Rel(backend_api, email_system, \"Sends e-mails using\", \"sync, SMTP\")\n    UpdateRelStyle(backend_api, email_system, $offsetY=\"-60\")\n    Rel(backend_api, banking_system, \"Uses\", \"sync/async, XML/HTTPS\")\n    UpdateRelStyle(backend_api, banking_system, $offsetY=\"-50\", $offsetX=\"-140\")\n\n</code></pre>"},{"location":"mermaid/#component","title":"Component","text":"<pre><code>    C4Component\n    title Component diagram for Internet Banking System - API Application\n\n    Container(spa, \"Single Page Application\", \"javascript and angular\", \"Provides all the internet banking functionality to customers via their web browser.\")\n    Container(ma, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the internet banking functionality to customers via their mobile mobile device.\")\n    ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n    System_Ext(mbs, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")\n\n    Container_Boundary(api, \"API Application\") {\n        Component(sign, \"Sign In Controller\", \"MVC Rest Controller\", \"Allows users to sign in to the internet banking system\")\n        Component(accounts, \"Accounts Summary Controller\", \"MVC Rest Controller\", \"Provides customers with a summary of their bank accounts\")\n        Component(security, \"Security Component\", \"Spring Bean\", \"Provides functionality related to singing in, changing passwords, etc.\")\n        Component(mbsfacade, \"Mainframe Banking System Facade\", \"Spring Bean\", \"A facade onto the mainframe banking system.\")\n\n        Rel(sign, security, \"Uses\")\n        Rel(accounts, mbsfacade, \"Uses\")\n        Rel(security, db, \"Read &amp; write to\", \"JDBC\")\n        Rel(mbsfacade, mbs, \"Uses\", \"XML/HTTPS\")\n    }\n\n    Rel_Back(spa, sign, \"Uses\", \"JSON/HTTPS\")\n    Rel(spa, accounts, \"Uses\", \"JSON/HTTPS\")\n\n    Rel(ma, sign, \"Uses\", \"JSON/HTTPS\")\n    Rel(ma, accounts, \"Uses\", \"JSON/HTTPS\")\n\n    UpdateRelStyle(spa, sign, $offsetY=\"-40\")\n    UpdateRelStyle(spa, accounts, $offsetX=\"40\", $offsetY=\"40\")\n\n    UpdateRelStyle(ma, sign, $offsetX=\"-90\", $offsetY=\"40\")\n    UpdateRelStyle(ma, accounts, $offsetY=\"-40\")\n\n        UpdateRelStyle(sign, security, $offsetX=\"-160\", $offsetY=\"10\")\n        UpdateRelStyle(accounts, mbsfacade, $offsetX=\"140\", $offsetY=\"10\")\n        UpdateRelStyle(security, db, $offsetY=\"-40\")\n        UpdateRelStyle(mbsfacade, mbs, $offsetY=\"-40\")\n\n</code></pre>"},{"location":"mermaid/#dynamic","title":"Dynamic","text":"<pre><code>    C4Dynamic\n    title Dynamic diagram for Internet Banking System - API Application\n\n    ContainerDb(c4, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n    Container(c1, \"Single-Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet banking functionality to customers via their web browser.\")\n    Container_Boundary(b, \"API Application\") {\n      Component(c3, \"Security Component\", \"Spring Bean\", \"Provides functionality Related to signing in, changing passwords, etc.\")\n      Component(c2, \"Sign In Controller\", \"Spring MVC Rest Controller\", \"Allows users to sign in to the Internet Banking System.\")\n    }\n    Rel(c1, c2, \"Submits credentials to\", \"JSON/HTTPS\")\n    Rel(c2, c3, \"Calls isAuthenticated() on\")\n    Rel(c3, c4, \"select * from users where username = ?\", \"JDBC\")\n\n    UpdateRelStyle(c1, c2, $textColor=\"red\", $offsetY=\"-40\")\n    UpdateRelStyle(c2, c3, $textColor=\"red\", $offsetX=\"-40\", $offsetY=\"60\")\n    UpdateRelStyle(c3, c4, $textColor=\"red\", $offsetY=\"-40\", $offsetX=\"10\")\n</code></pre>"},{"location":"mermaid/#deployment","title":"Deployment","text":"<pre><code>    C4Deployment\n    title Deployment Diagram for Internet Banking System - Live\n\n    Deployment_Node(mob, \"Customer's mobile device\", \"Apple IOS or Android\"){\n        Container(mobile, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the Internet Banking functionality to customers via their mobile device.\")\n    }\n\n    Deployment_Node(comp, \"Customer's computer\", \"Microsoft Windows or Apple macOS\"){\n        Deployment_Node(browser, \"Web Browser\", \"Google Chrome, Mozilla Firefox,&lt;br/&gt; Apple Safari or Microsoft Edge\"){\n            Container(spa, \"Single Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet Banking functionality to customers via their web browser.\")\n        }\n    }\n\n    Deployment_Node(plc, \"Big Bank plc\", \"Big Bank plc data center\"){\n        Deployment_Node(dn, \"bigbank-api*** x8\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(apache, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){\n                Container(api, \"API Application\", \"Java and Spring MVC\", \"Provides Internet Banking functionality via a JSON/HTTPS API.\")\n            }\n        }\n        Deployment_Node(bb2, \"bigbank-web*** x4\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(apache2, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){\n                Container(web, \"Web Application\", \"Java and Spring MVC\", \"Delivers the static content and the Internet Banking single page application.\")\n            }\n        }\n        Deployment_Node(bigbankdb01, \"bigbank-db01\", \"Ubuntu 16.04 LTS\"){\n            Deployment_Node(oracle, \"Oracle - Primary\", \"Oracle 12c\"){\n                ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n            }\n        }\n        Deployment_Node(bigbankdb02, \"bigbank-db02\", \"Ubuntu 16.04 LTS\") {\n            Deployment_Node(oracle2, \"Oracle - Secondary\", \"Oracle 12c\") {\n                ContainerDb(db2, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\")\n            }\n        }\n    }\n\n    Rel(mobile, api, \"Makes API calls to\", \"json/HTTPS\")\n    Rel(spa, api, \"Makes API calls to\", \"json/HTTPS\")\n    Rel_U(web, spa, \"Delivers to the customer's web browser\")\n    Rel(api, db, \"Reads from and writes to\", \"JDBC\")\n    Rel(api, db2, \"Reads from and writes to\", \"JDBC\")\n    Rel_R(db, db2, \"Replicates data to\")\n\n    UpdateRelStyle(spa, api, $offsetY=\"-40\")\n    UpdateRelStyle(web, spa, $offsetY=\"-40\")\n    UpdateRelStyle(api, db, $offsetY=\"-20\", $offsetX=\"5\")\n    UpdateRelStyle(api, db2, $offsetX=\"-40\", $offsetY=\"-20\")\n    UpdateRelStyle(db, db2, $offsetY=\"-10\")\n\n</code></pre>"},{"location":"mermaid/#mindmaps","title":"Mindmaps","text":"<pre><code>mindmap\n  root((mindmap))\n    Origins\n      Long history\n      ::icon(fa fa-book)\n      Popularisation\n        British popular psychology author Tony Buzan\n    Research\n      On effectiveness&lt;br/&gt;and features\n      On Automatic creation\n        Uses\n            Creative techniques\n            Strategic planning\n            Argument mapping\n    Tools\n      Pen and paper\n      Mermaid\n</code></pre>"},{"location":"mermaid/#timeline","title":"Timeline","text":"<pre><code>timeline\n    title History of Social Media Platform\n    2002 : LinkedIn\n    2004 : Facebook : Google\n    2005 : Youtube\n    2006 : Twitter</code></pre>"}]}