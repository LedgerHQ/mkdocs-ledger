{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ledger theme for MkDocs This site is both a documentation and a showcase for this theme. Getting started Just follow the README steps. Those are Installation Just install mkdocs-ledger from the GemFury repository (this requires credentials). Properly chose the extra depending on what you want to document: # Basic installation pip install mkdocs-ledger # Installation with docstring support pip install mkdocs-ledger [ docstrings ] # Installation with `click` documentation support pip install mkdocs-ledger [ click ] # Installation with all features pip install mkdocs-ledger [ docstrings,click ] Configure mkdocs Just use the ledger theme in your mkdocs.yml configuration: theme : ledger For docstrings support, use the mkdocstrings plugin. For click support, use the mkdocs-click makrdown plugim. theme : ledger markdown_extensions : - mkdocs-click plugins : - mkdocstrings References This theme is based on MkDocs and some extensions so plese consult upstream documentations: MkDocs : the documentation engine Material for MkDocs : the base theme mkdocsstrings : docstrings support mkdocs-click : automatic documentation for Python Click Showcase Demo pages The following pages are just here to showcase supported features: docstrings : showcase docstrings support OpenAPI : showcase OpenAPI documetation based on redoc / RedocLy Click : showcase click automatic documentation Mermaid : showcase mermaid.js diagrams integration They are using fake or demo data, most of the time took form their feature official website. If you are hacking this theme, don't hesitarte to use those pages to see the result. If you add support for a specific feature, please add a page showcasing it. Light/Dark mode This theme comes with support for both light and dark mode so don't forget to try both. The toggle button ( / ) is in the top header on the right. Known documentations You can also take a look at some existing documentations using this theme: Vault Platform Manager","title":"Documentation"},{"location":"#ledger-theme-for-mkdocs","text":"This site is both a documentation and a showcase for this theme.","title":"Ledger theme for MkDocs"},{"location":"#getting-started","text":"Just follow the README steps. Those are","title":"Getting started"},{"location":"#installation","text":"Just install mkdocs-ledger from the GemFury repository (this requires credentials). Properly chose the extra depending on what you want to document: # Basic installation pip install mkdocs-ledger # Installation with docstring support pip install mkdocs-ledger [ docstrings ] # Installation with `click` documentation support pip install mkdocs-ledger [ click ] # Installation with all features pip install mkdocs-ledger [ docstrings,click ]","title":"Installation"},{"location":"#configure-mkdocs","text":"Just use the ledger theme in your mkdocs.yml configuration: theme : ledger For docstrings support, use the mkdocstrings plugin. For click support, use the mkdocs-click makrdown plugim. theme : ledger markdown_extensions : - mkdocs-click plugins : - mkdocstrings","title":"Configure mkdocs"},{"location":"#references","text":"This theme is based on MkDocs and some extensions so plese consult upstream documentations: MkDocs : the documentation engine Material for MkDocs : the base theme mkdocsstrings : docstrings support mkdocs-click : automatic documentation for Python Click","title":"References"},{"location":"#showcase","text":"","title":"Showcase"},{"location":"#demo-pages","text":"The following pages are just here to showcase supported features: docstrings : showcase docstrings support OpenAPI : showcase OpenAPI documetation based on redoc / RedocLy Click : showcase click automatic documentation Mermaid : showcase mermaid.js diagrams integration They are using fake or demo data, most of the time took form their feature official website. If you are hacking this theme, don't hesitarte to use those pages to see the result. If you add support for a specific feature, please add a page showcasing it. Light/Dark mode This theme comes with support for both light and dark mode so don't forget to try both. The toggle button ( / ) is in the top header on the right.","title":"Demo pages"},{"location":"#known-documentations","text":"You can also take a look at some existing documentations using this theme: Vault Platform Manager","title":"Known documentations"},{"location":"changelog/","text":"Changelog Unreleased Initial release with light and dark Ledger theme, redoc , mkdocs-click and mkdocstrings integration","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"Initial release with light and dark Ledger theme, redoc , mkdocs-click and mkdocstrings integration","title":"Unreleased"},{"location":"cli/","text":"Click This demo site shows the rendering of the MkDocs CLI itself through mkdocs-click . cli MkDocs - Project documentation with Markdown. Usage: cli [OPTIONS] COMMAND [ARGS]... Options: -V, --version Show the version and exit. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit. build Build the MkDocs documentation Usage: cli build [OPTIONS] Options: -c, --clean / --dirty Remove old files from the site_dir before building (the default). -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit. gh-deploy Deploy your documentation to GitHub Pages Usage: cli gh-deploy [OPTIONS] Options: -c, --clean / --dirty Remove old files from the site_dir before building (the default). -m, --message TEXT A commit message to use when committing to the GitHub Pages remote branch. Commit {sha} and MkDocs {version} are available as expansions -b, --remote-branch TEXT The remote branch to commit to for GitHub Pages. This overrides the value specified in config -r, --remote-name TEXT The remote name to commit to for GitHub Pages. This overrides the value specified in config --force Force the push to the repository. --no-history Replace the whole Git history with one new commit. --ignore-version Ignore check that build is not being deployed with an older version of MkDocs. --shell Use the shell when invoking Git. -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit. new Create a new MkDocs project Usage: cli new [OPTIONS] PROJECT_DIRECTORY Options: -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit. serve Run the builtin development server Usage: cli serve [OPTIONS] Options: -a, --dev-addr <IP:PORT> IP address and port to serve documentation locally (default: localhost:8000) --livereload Enable the live reloading in the development server (this is the default) --no-livereload Disable the live reloading in the development server. --dirtyreload Enable the live reloading in the development server, but only re-build files that have changed --watch-theme Include the theme in list of files to watch for live reloading. Ignored when live reload is not used. -w, --watch PATH A directory or file to watch for live reloading. Can be supplied multiple times. -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"Click"},{"location":"cli/#click","text":"This demo site shows the rendering of the MkDocs CLI itself through mkdocs-click .","title":"Click"},{"location":"cli/#cli","text":"MkDocs - Project documentation with Markdown. Usage: cli [OPTIONS] COMMAND [ARGS]... Options: -V, --version Show the version and exit. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"cli"},{"location":"cli/#build","text":"Build the MkDocs documentation Usage: cli build [OPTIONS] Options: -c, --clean / --dirty Remove old files from the site_dir before building (the default). -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"build"},{"location":"cli/#gh-deploy","text":"Deploy your documentation to GitHub Pages Usage: cli gh-deploy [OPTIONS] Options: -c, --clean / --dirty Remove old files from the site_dir before building (the default). -m, --message TEXT A commit message to use when committing to the GitHub Pages remote branch. Commit {sha} and MkDocs {version} are available as expansions -b, --remote-branch TEXT The remote branch to commit to for GitHub Pages. This overrides the value specified in config -r, --remote-name TEXT The remote name to commit to for GitHub Pages. This overrides the value specified in config --force Force the push to the repository. --no-history Replace the whole Git history with one new commit. --ignore-version Ignore check that build is not being deployed with an older version of MkDocs. --shell Use the shell when invoking Git. -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -d, --site-dir PATH The directory to output the result of the documentation build. -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"gh-deploy"},{"location":"cli/#new","text":"Create a new MkDocs project Usage: cli new [OPTIONS] PROJECT_DIRECTORY Options: -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"new"},{"location":"cli/#serve","text":"Run the builtin development server Usage: cli serve [OPTIONS] Options: -a, --dev-addr <IP:PORT> IP address and port to serve documentation locally (default: localhost:8000) --livereload Enable the live reloading in the development server (this is the default) --no-livereload Disable the live reloading in the development server. --dirtyreload Enable the live reloading in the development server, but only re-build files that have changed --watch-theme Include the theme in list of files to watch for live reloading. Ignored when live reload is not used. -w, --watch PATH A directory or file to watch for live reloading. Can be supplied multiple times. -f, --config-file FILENAME Provide a specific MkDocs config -s, --strict Enable strict mode. This will cause MkDocs to abort the build on any warnings. -t, --theme [ledger|material|mkdocs|readthedocs] The theme to use when building your documentation. --use-directory-urls / --no-directory-urls Use directory URLs when building pages (the default). -q, --quiet Silence warnings -v, --verbose Enable verbose output --help Show this message and exit.","title":"serve"},{"location":"docstrings/","text":"Docstrings This page showcase the mkdocsstrings extension with its own code. Todo Make a dedicated demo package to have just what is needed to style This module contains the \"mkdocstrings\" plugin for MkDocs. The plugin instantiates a Markdown extension ( MkdocstringsExtension ), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . Once the documentation is built, the on_post_build event hook is triggered and calls the handlers.teardown() method . This method is used to teardown the handlers that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . RENDERING_OPTS_KEY : str = 'rendering' module-attribute Deprecated. The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY : str = 'selection' module-attribute Deprecated. The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin Bases: BasePlugin An mkdocs plugin. This plugin defines the following event hooks: on_config on_env on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 class MkdocstringsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_env` - `on_post_build` - `on_serve` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" config_scheme : tuple [ tuple [ str , MkType ]] = ( ( \"watch\" , MkType ( list , default = [])), # type: ignore[assignment] ( \"handlers\" , MkType ( dict , default = {})), ( \"default_handler\" , MkType ( str , default = \"python\" )), ( \"custom_templates\" , MkType ( str , default = None )), ( \"enable_inventory\" , MkType ( bool , default = None )), ( \"enabled\" , MkType ( bool , default = True )), ) \"\"\" The configuration options of `mkdocstrings`, written in `mkdocs.yml`. Available options are: - **`watch` (deprecated)**: A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. Deprecated in favor of the now built-in `watch` feature of MkDocs. - **`default_handler`**: The default handler to use. The value is the name of the handler module. Default is \"python\". - **`enabled`**: Whether to enable the plugin. Default is true. If false, *mkdocstrings* will not collect or render anything. - **`handlers`**: Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: ```yaml plugins: - mkdocstrings: handlers: python: options: selection_opt: true rendering_opt: \"value\" rust: options: selection_opt: 2 ``` \"\"\" css_filename = \"assets/_mkdocstrings.css\" def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Handlers | None = None @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers # TODO: remove once watch feature is removed def on_serve ( self , server : LiveReloadServer , config : Config , # noqa: ARG002 builder : Callable , * args : Any , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. config: The MkDocs config object (unused). builder: The function to build the site. *args: Additional arguments passed by MkDocs. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return if self . config [ \"watch\" ]: for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: ARG002 \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" if not self . plugin_enabled : log . debug ( \"Plugin is not enabled. Skipping.\" ) return config log . debug ( \"Adding extension to the list\" ) theme_name = config [ \"theme\" ] . name or os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } # noqa: PLW2901 to_import . append (( handler_name , import_item )) extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , \"mkdocs\" : config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : future = inv_loader . submit ( self . _load_inventory , # type: ignore[misc] self . get_handler ( handler_name ) . load_inventory , ** import_item , ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) if self . config [ \"watch\" ]: self . _warn_about_watch_option () return config @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled @property def plugin_enabled ( self ) -> bool : \"\"\"Tell if the plugin is enabled or not. Returns: Whether the plugin is enabled. \"\"\" return self . config [ \"enabled\" ] def on_env ( self , env : Environment , config : Config , * args : Any , ** kwargs : Any ) -> None : # noqa: ARG002 \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if not self . plugin_enabled : return if self . _handlers : css_content = \" \\n \" . join ( handler . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] def on_post_build ( self , config : Config , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) @classmethod # lru_cache does not allow mutable arguments such lists, but that is what we load from YAML config. @list_to_tuple @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result @classmethod @functools . lru_cache ( maxsize = None ) # Warn only once def _warn_about_watch_option ( cls ) -> None : log . info ( \"DEPRECATION: mkdocstrings' watch feature is deprecated in favor of MkDocs' watch feature, \" \"see https://www.mkdocs.org/user-guide/configuration/#watch\" , ) config_scheme : tuple [ tuple [ str , MkType ]] = (( 'watch' , MkType ( list , default = [])), ( 'handlers' , MkType ( dict , default = {})), ( 'default_handler' , MkType ( str , default = 'python' )), ( 'custom_templates' , MkType ( str , default = None )), ( 'enable_inventory' , MkType ( bool , default = None )), ( 'enabled' , MkType ( bool , default = True ))) class-attribute The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch (deprecated) : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. Deprecated in favor of the now built-in watch feature of MkDocs. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". enabled : Whether to enable the plugin. Default is true. If false, mkdocstrings will not collect or render anything. handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : options : selection_opt : true rendering_opt : \"value\" rust : options : selection_opt : 2 handlers : Handlers property Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Raises: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build). inventory_enabled : bool property Tell if the inventory is enabled or not. Returns: Type Description bool Whether the inventory is enabled. plugin_enabled : bool property Tell if the plugin is enabled or not. Returns: Type Description bool Whether the plugin is enabled. __init__ () Initialize the object. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 122 123 124 125 def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Handlers | None = None get_handler ( handler_name ) Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 321 322 323 324 325 326 327 328 329 330 def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) on_config ( config , ** kwargs ) Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: ARG002 \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" if not self . plugin_enabled : log . debug ( \"Plugin is not enabled. Skipping.\" ) return config log . debug ( \"Adding extension to the list\" ) theme_name = config [ \"theme\" ] . name or os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } # noqa: PLW2901 to_import . append (( handler_name , import_item )) extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , \"mkdocs\" : config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : future = inv_loader . submit ( self . _load_inventory , # type: ignore[misc] self . get_handler ( handler_name ) . load_inventory , ** import_item , ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) if self . config [ \"watch\" ]: self . _warn_about_watch_option () return config on_env ( env , config , * args , ** kwargs ) Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the on_env event . Write mkdocstrings' extra files into the site dir. Gather results from background inventory download tasks. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def on_env ( self , env : Environment , config : Config , * args : Any , ** kwargs : Any ) -> None : # noqa: ARG002 \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if not self . plugin_enabled : return if self . _handlers : css_content = \" \\n \" . join ( handler . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] on_post_build ( config , ** kwargs ) Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's teardown method, which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def on_post_build ( self , config : Config , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () on_serve ( server , config , builder , * args , ** kwargs ) Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server LiveReloadServer The livereload server instance. required config Config The MkDocs config object (unused). required builder Callable The function to build the site. required *args Any Additional arguments passed by MkDocs. () **kwargs Any Additional arguments passed by MkDocs. {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def on_serve ( self , server : LiveReloadServer , config : Config , # noqa: ARG002 builder : Callable , * args : Any , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. config: The MkDocs config object (unused). builder: The function to build the site. *args: Additional arguments passed by MkDocs. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return if self . config [ \"watch\" ]: for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) list_to_tuple ( function ) Decorater to convert lists to tuples in the arguments. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 59 60 61 62 63 64 65 66 67 68 def list_to_tuple ( function : Callable [ P , R ]) -> Callable [ P , R ]: \"\"\"Decorater to convert lists to tuples in the arguments.\"\"\" def wrapper ( * args : P . args , ** kwargs : P . kwargs ) -> R : safe_args = [ tuple ( item ) if isinstance ( item , list ) else item for item in args ] if kwargs : kwargs = { key : tuple ( value ) if isinstance ( value , list ) else value for key , value in kwargs . items ()} # type: ignore[assignment] return function ( * safe_args , ** kwargs ) # type: ignore[arg-type] return wrapper This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor Bases: BlockProcessor Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class AutoDocProcessor ( BlockProcessor ): \"\"\"Our \"autodoc\" Markdown block processor. It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. \"\"\" regex = re . compile ( r \"^(?P<heading>#{1,6} *|)::: ?(?P<name>.+?) *$\" , flags = re . MULTILINE ) def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_envs : set = set () def test ( self , parent : Element , block : str ) -> bool : # noqa: ARG002 \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . get_headings () el . extend ( headings ) page = self . _autorefs . current_page if page : for heading in headings : anchor = heading . attrib [ \"id\" ] self . _autorefs . register_anchor ( page , anchor ) if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) global_options = handler_config . get ( \"options\" , {}) local_options = config . get ( \"options\" , {}) deprecated_global_options = ChainMap ( handler_config . get ( \"selection\" , {}), handler_config . get ( \"rendering\" , {})) deprecated_local_options = ChainMap ( config . get ( \"selection\" , {}), config . get ( \"rendering\" , {})) options = ChainMap ( local_options , deprecated_local_options , global_options , deprecated_global_options ) if deprecated_global_options or deprecated_local_options : self . _warn_about_options_key () if heading_level : options = ChainMap ( options , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collect ( identifier , options ) except CollectionError as exception : log . error ( str ( exception )) # noqa: TRY400 if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) # noqa: TRY400 raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if handler_name not in self . _updated_envs : # We haven't seen this handler before on this document. log . debug ( \"Updating renderer's env\" ) handler . _update_env ( self . md , self . _config ) self . _updated_envs . add ( handler_name ) log . debug ( \"Rendering templates\" ) try : rendered = handler . render ( data , options ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( # noqa: TRY400 f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data @classmethod @functools . lru_cache ( maxsize = None ) # Warn only once def _warn_about_options_key ( cls ) -> None : log . info ( \"DEPRECATION: 'selection' and 'rendering' are deprecated and merged into a single 'options' YAML key\" ) __init__ ( parser , md , config , handlers , autorefs ) Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_envs : set = set () run ( parent , blocks ) Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence [ str ] The rest of the blocks to be processed. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . get_headings () el . extend ( headings ) page = self . _autorefs . current_page if page : for heading in headings : anchor = heading . attrib [ \"id\" ] self . _autorefs . register_anchor ( page , anchor ) if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( parent , block ) Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 89 90 91 92 93 94 95 96 97 98 99 def test ( self , parent : Element , block : str ) -> bool : # noqa: ARG002 \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) MkdocstringsExtension Bases: Extension Our Markdown extension. It cannot work outside of mkdocstrings . Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class MkdocstringsExtension ( Extension ): \"\"\"Our Markdown extension. It cannot work outside of `mkdocstrings`. \"\"\" def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) __init__ ( config , handlers , autorefs , ** kwargs ) Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required **kwargs Any Keyword arguments used by markdown.extensions.Extension . {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs extendMarkdown ( md ) Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BaseCollector : \"\"\"The base collector class. Inherit from this class to implement a collector. You will have to implement the `collect` method. You can also implement the `teardown` method. \"\"\" def collect ( self , identifier : str , config : MutableMapping [ str , Any ]) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: The handler's configuration options. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" collect ( identifier , config ) Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config MutableMapping [ str , Any ] The handler's configuration options. required Returns: Type Description CollectorItem Anything you want, as long as you can feed it to the renderer's render method. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def collect ( self , identifier : str , config : MutableMapping [ str , Any ]) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: The handler's configuration options. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError teardown () Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 345 346 347 348 349 350 def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" BaseHandler Bases: BaseCollector , BaseRenderer The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: Name Type Description domain str The cross-documentation domain/language for this handler. enable_inventory bool Whether this handler is interested in enabling the creation of the objects.inv Sphinx inventory file. fallback_config dict The configuration used to collect item during autorefs fallback. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 class BaseHandler ( BaseCollector , BaseRenderer ): \"\"\"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: domain: The cross-documentation domain/language for this handler. enable_inventory: Whether this handler is interested in enabling the creation of the `objects.inv` Sphinx inventory file. fallback_config: The configuration used to collect item during autorefs fallback. \"\"\" domain : str = \"default\" enable_inventory : bool = False fallback_config : dict = {} # TODO: once the BaseCollector and BaseRenderer classes are removed, # stop accepting the 'handler' parameter, and instead set a 'name' attribute on the Handler class. # Then make the 'handler' parameter in 'get_templates_dir' optional, and use the class 'name' by default. def __init__ ( self , * args : str | BaseCollector | BaseRenderer , ** kwargs : str | BaseCollector | BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: *args: Collector and renderer, or handler name, theme and custom_templates. **kwargs: Same thing, but with keyword arguments. Raises: ValueError: When the given parameters are invalid. \"\"\" # The method accepts *args and **kwargs temporarily, # to support the transition period where the BaseCollector # and BaseRenderer are deprecated, and the BaseHandler # can be instantiated with both instances of collector/renderer, # or renderer parameters, as positional parameters. collector = None renderer = None # parsing positional arguments str_args = [] for arg in args : if isinstance ( arg , BaseCollector ): collector = arg elif isinstance ( arg , BaseRenderer ): renderer = arg elif isinstance ( arg , str ): str_args . append ( arg ) while len ( str_args ) != 3 : # noqa: PLR2004 str_args . append ( None ) # type: ignore[arg-type] handler , theme , custom_templates = str_args # fetching values from keyword arguments if \"collector\" in kwargs : collector = kwargs . pop ( \"collector\" ) # type: ignore[assignment] if \"renderer\" in kwargs : renderer = kwargs . pop ( \"renderer\" ) # type: ignore[assignment] if \"handler\" in kwargs : handler = kwargs . pop ( \"handler\" ) # type: ignore[assignment] if \"theme\" in kwargs : theme = kwargs . pop ( \"theme\" ) # type: ignore[assignment] if \"custom_templates\" in kwargs : custom_templates = kwargs . pop ( \"custom_templates\" ) # type: ignore[assignment] if collector is None and renderer is not None or collector is not None and renderer is None : raise ValueError ( \"both 'collector' and 'renderer' must be provided\" ) if collector is not None : warnings . warn ( DeprecationWarning ( \"The BaseCollector class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \" \"methods directly on your handler class.\" , ), stacklevel = 1 , ) self . collector = collector self . collect = collector . collect # type: ignore[method-assign] self . teardown = collector . teardown # type: ignore[method-assign] if renderer is not None : if { handler , theme , custom_templates } != { None }: raise ValueError ( \"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\" , ) warnings . warn ( DeprecationWarning ( \"The BaseRenderer class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `render` method \" \"directly on your handler class (as well as other methods and attributes like \" \"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\" , ), stacklevel = 1 , ) self . renderer = renderer self . render = renderer . render # type: ignore[method-assign] self . get_templates_dir = renderer . get_templates_dir # type: ignore[method-assign] self . get_anchors = renderer . get_anchors # type: ignore[method-assign] self . do_convert_markdown = renderer . do_convert_markdown # type: ignore[method-assign] self . do_heading = renderer . do_heading # type: ignore[method-assign] self . get_headings = renderer . get_headings # type: ignore[method-assign] self . update_env = renderer . update_env # type: ignore[method-assign] self . _update_env = renderer . _update_env # type: ignore[method-assign] self . fallback_theme = renderer . fallback_theme self . extra_css = renderer . extra_css renderer . __class__ . __init__ ( self , renderer . _handler , renderer . _theme , renderer . _custom_templates , ) else : if handler is None or theme is None : raise ValueError ( \"'handler' and 'theme' cannot be None\" ) BaseRenderer . __init__ ( self , handler , theme , custom_templates ) @classmethod def load_inventory ( cls , in_file : BinaryIO , # noqa: ARG003 url : str , # noqa: ARG003 base_url : str | None = None , # noqa: ARG003 ** kwargs : Any , # noqa: ARG003 ) -> Iterator [ tuple [ str , str ]]: \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`. Arguments: in_file: The binary file-like object to read the inventory from. url: The URL that this file is being streamed from (used to guess `base_url`). base_url: The URL that this inventory's sub-paths are relative to. **kwargs: Ignore additional arguments passed from the config. Yields: Tuples of (item identifier, item URL). \"\"\" yield from () __init__ ( * args , ** kwargs ) Initialize the object. Parameters: Name Type Description Default *args str | BaseCollector | BaseRenderer Collector and renderer, or handler name, theme and custom_templates. () **kwargs str | BaseCollector | BaseRenderer Same thing, but with keyword arguments. {} Raises: Type Description ValueError When the given parameters are invalid. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def __init__ ( self , * args : str | BaseCollector | BaseRenderer , ** kwargs : str | BaseCollector | BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: *args: Collector and renderer, or handler name, theme and custom_templates. **kwargs: Same thing, but with keyword arguments. Raises: ValueError: When the given parameters are invalid. \"\"\" # The method accepts *args and **kwargs temporarily, # to support the transition period where the BaseCollector # and BaseRenderer are deprecated, and the BaseHandler # can be instantiated with both instances of collector/renderer, # or renderer parameters, as positional parameters. collector = None renderer = None # parsing positional arguments str_args = [] for arg in args : if isinstance ( arg , BaseCollector ): collector = arg elif isinstance ( arg , BaseRenderer ): renderer = arg elif isinstance ( arg , str ): str_args . append ( arg ) while len ( str_args ) != 3 : # noqa: PLR2004 str_args . append ( None ) # type: ignore[arg-type] handler , theme , custom_templates = str_args # fetching values from keyword arguments if \"collector\" in kwargs : collector = kwargs . pop ( \"collector\" ) # type: ignore[assignment] if \"renderer\" in kwargs : renderer = kwargs . pop ( \"renderer\" ) # type: ignore[assignment] if \"handler\" in kwargs : handler = kwargs . pop ( \"handler\" ) # type: ignore[assignment] if \"theme\" in kwargs : theme = kwargs . pop ( \"theme\" ) # type: ignore[assignment] if \"custom_templates\" in kwargs : custom_templates = kwargs . pop ( \"custom_templates\" ) # type: ignore[assignment] if collector is None and renderer is not None or collector is not None and renderer is None : raise ValueError ( \"both 'collector' and 'renderer' must be provided\" ) if collector is not None : warnings . warn ( DeprecationWarning ( \"The BaseCollector class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \" \"methods directly on your handler class.\" , ), stacklevel = 1 , ) self . collector = collector self . collect = collector . collect # type: ignore[method-assign] self . teardown = collector . teardown # type: ignore[method-assign] if renderer is not None : if { handler , theme , custom_templates } != { None }: raise ValueError ( \"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\" , ) warnings . warn ( DeprecationWarning ( \"The BaseRenderer class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `render` method \" \"directly on your handler class (as well as other methods and attributes like \" \"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\" , ), stacklevel = 1 , ) self . renderer = renderer self . render = renderer . render # type: ignore[method-assign] self . get_templates_dir = renderer . get_templates_dir # type: ignore[method-assign] self . get_anchors = renderer . get_anchors # type: ignore[method-assign] self . do_convert_markdown = renderer . do_convert_markdown # type: ignore[method-assign] self . do_heading = renderer . do_heading # type: ignore[method-assign] self . get_headings = renderer . get_headings # type: ignore[method-assign] self . update_env = renderer . update_env # type: ignore[method-assign] self . _update_env = renderer . _update_env # type: ignore[method-assign] self . fallback_theme = renderer . fallback_theme self . extra_css = renderer . extra_css renderer . __class__ . __init__ ( self , renderer . _handler , renderer . _theme , renderer . _custom_templates , ) else : if handler is None or theme is None : raise ValueError ( \"'handler' and 'theme' cannot be None\" ) BaseRenderer . __init__ ( self , handler , theme , custom_templates ) load_inventory ( in_file , url , base_url = None , ** kwargs ) classmethod Yield items and their URLs from an inventory file streamed from in_file . Parameters: Name Type Description Default in_file BinaryIO The binary file-like object to read the inventory from. required url str The URL that this file is being streamed from (used to guess base_url ). required base_url str | None The URL that this inventory's sub-paths are relative to. None **kwargs Any Ignore additional arguments passed from the config. {} Yields: Type Description Iterator [ tuple [ str , str ]] Tuples of (item identifier, item URL). Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 @classmethod def load_inventory ( cls , in_file : BinaryIO , # noqa: ARG003 url : str , # noqa: ARG003 base_url : str | None = None , # noqa: ARG003 ** kwargs : Any , # noqa: ARG003 ) -> Iterator [ tuple [ str , str ]]: \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`. Arguments: in_file: The binary file-like object to read the inventory from. url: The URL that this file is being streamed from (used to guess `base_url`). base_url: The URL that this inventory's sub-paths are relative to. **kwargs: Ignore additional arguments passed from the config. Yields: Tuples of (item identifier, item URL). \"\"\" yield from () BaseRenderer The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class BaseRenderer : \"\"\"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the `render` method. You can also override the `update_env` method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a `fallback_theme` class-variable. To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates. \"\"\" fallback_theme : str = \"\" extra_css = \"\" def __init__ ( self , handler : str , theme : str , custom_templates : str | None = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] # TODO: remove once BaseRenderer is merged into BaseHandler self . _handler = handler self . _theme = theme self . _custom_templates = custom_templates themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : list [ Element ] = [] self . _md : Markdown = None # type: ignore[assignment] # To be populated in `update_env`. def render ( self , data : CollectorItem , config : Mapping [ str , Any ]) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The handler's configuration options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , stacklevel = 1 , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) def get_anchors ( self , data : CollectorItem ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore[attr-defined] except AttributeError : return () def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False , ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () def do_heading ( self , content : Markup , heading_level : int , * , role : str | None = None , hidden : bool = False , toc_label : str | None = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( content , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( # noqa: S101 html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: ARG002 \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading def _update_env ( self , md : Markdown , config : dict ) -> None : \"\"\"Update our handler to point to our configured Markdown instance, grabbing some of the config from `md`.\"\"\" extensions = config [ \"mdx\" ] + [ MkdocstringsInnerExtension ( self . _headings )] new_md = Markdown ( extensions = extensions , extension_configs = config [ \"mdx_configs\" ]) # MkDocs adds its own (required) extension that's not part of the config. Propagate it. if \"relpath\" in md . treeprocessors : new_md . treeprocessors . register ( md . treeprocessors [ \"relpath\" ], \"relpath\" , priority = 0 ) self . update_env ( new_md , config ) __init__ ( handler , theme , custom_templates = None ) Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default handler str The name of the handler. required theme str The name of theme to use. required custom_templates str | None Directory containing custom templates. None Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , handler : str , theme : str , custom_templates : str | None = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] # TODO: remove once BaseRenderer is merged into BaseHandler self . _handler = handler self . _theme = theme self . _custom_templates = custom_templates themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : list [ Element ] = [] self . _md : Markdown = None # type: ignore[assignment] # To be populated in `update_env`. do_convert_markdown ( text , heading_level , html_id = '' , * , strip_paragraph = False ) Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' strip_paragraph bool Whether to exclude the tag from around the whole output. False Returns: Type Description Markup An HTML string. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False , ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () do_heading ( content , heading_level , * , role = None , hidden = False , toc_label = None , ** attributes ) Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content Markup The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required role str | None An optional role for the object bound to this heading. None hidden bool If True, only register it for the table of contents, don't render anything. False toc_label str | None The title to use in the table of contents ('data-toc-label' attribute). None **attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def do_heading ( self , content : Markup , heading_level : int , * , role : str | None = None , hidden : bool = False , toc_label : str | None = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( content , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( # noqa: S101 html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) get_anchors ( data ) Return the possible identifiers (HTML anchors) for a collected item. Parameters: Name Type Description Default data CollectorItem The collected data. required Returns: Type Description tuple [ str , ...] | set [ str ] The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def get_anchors ( self , data : CollectorItem ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore[attr-defined] except AttributeError : return () get_headings () Return and clear the headings gathered so far. Returns: Type Description Sequence [ Element ] A list of HTML elements. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 284 285 286 287 288 289 290 291 292 def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result get_templates_dir ( handler ) Return the path to the handler's templates directory. Override to customize how the templates directory is found. Parameters: Name Type Description Default handler str The name of the handler to get the templates directory of. required Raises: Type Description FileNotFoundError When the templates directory cannot be found. Returns: Type Description Path The templates directory path. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , stacklevel = 1 , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) render ( data , config ) Render a template using provided data and configuration options. Parameters: Name Type Description Default data CollectorItem The collected data to render. required config Mapping [ str , Any ] The handler's configuration options. required Returns: Type Description str The rendered template as HTML. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 122 123 124 125 126 127 128 129 130 131 132 def render ( self , data : CollectorItem , config : Mapping [ str , Any ]) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The handler's configuration options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError update_env ( md , config ) Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 294 295 296 297 298 299 300 301 302 303 304 305 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: ARG002 \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading CollectionError Bases: Exception An exception raised when some collection of data failed. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 37 38 class CollectionError ( Exception ): \"\"\"An exception raised when some collection of data failed.\"\"\" Handlers A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 class Handlers : \"\"\"A collection of handlers. Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access. \"\"\" def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"mkdocs\" ][ \"site_name\" ]) def get_anchors ( self , identifier : str ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler , \"fallback_config\" , {}) try : anchors = handler . get_anchors ( handler . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} def get_handler ( self , name : str , handler_config : dict | None = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) handler_config . update ( self . _config ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" , ), stacklevel = 1 , ) self . _handlers [ name ] = module . get_handler ( theme = self . _config [ \"theme_name\" ], custom_templates = self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], config_file_path = self . _config [ \"mkdocs\" ][ \"config_file_path\" ], ** handler_config , ) return self . _handlers [ name ] @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values () def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . teardown () self . _handlers . clear () seen_handlers : Iterable [ BaseHandler ] property Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable [ BaseHandler ] An iterable of instances of BaseHandler Iterable [ BaseHandler ] (usable only to loop through it). __init__ ( config ) Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 501 502 503 504 505 506 507 508 509 510 def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"mkdocs\" ][ \"site_name\" ]) get_anchors ( identifier ) Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description tuple [ str , ...] | set [ str ] A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def get_anchors ( self , identifier : str ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler , \"fallback_config\" , {}) try : anchors = handler . get_anchors ( handler . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () get_handler ( name , handler_config = None ) Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config dict | None Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , as instantiated by the get_handler method of the handler's module. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def get_handler ( self , name : str , handler_config : dict | None = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) handler_config . update ( self . _config ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" , ), stacklevel = 1 , ) self . _handlers [ name ] = module . get_handler ( theme = self . _config [ \"theme_name\" ], custom_templates = self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], config_file_path = self . _config [ \"mkdocs\" ][ \"config_file_path\" ], ** handler_config , ) return self . _handlers [ name ] get_handler_config ( name ) Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 545 546 547 548 549 550 551 552 553 554 555 556 557 def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} get_handler_name ( config ) Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] teardown () Teardown all cached handlers and clear the cache. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 609 610 611 612 613 def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . teardown () self . _handlers . clear () ThemeNotSupported Bases: Exception An exception raised to tell a theme is not supported. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 41 42 class ThemeNotSupported ( Exception ): # noqa: N818 \"\"\"An exception raised to tell a theme is not supported.\"\"\" do_any ( seq , attribute = None ) Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str | None The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def do_any ( seq : Sequence , attribute : str | None = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"Docstrings"},{"location":"docstrings/#docstrings","text":"This page showcase the mkdocsstrings extension with its own code. Todo Make a dedicated demo package to have just what is needed to style This module contains the \"mkdocstrings\" plugin for MkDocs. The plugin instantiates a Markdown extension ( MkdocstringsExtension ), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . Once the documentation is built, the on_post_build event hook is triggered and calls the handlers.teardown() method . This method is used to teardown the handlers that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook .","title":"Docstrings"},{"location":"docstrings/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"Deprecated. The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"docstrings/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"Deprecated. The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin","text":"Bases: BasePlugin An mkdocs plugin. This plugin defines the following event hooks: on_config on_env on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 class MkdocstringsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_env` - `on_post_build` - `on_serve` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" config_scheme : tuple [ tuple [ str , MkType ]] = ( ( \"watch\" , MkType ( list , default = [])), # type: ignore[assignment] ( \"handlers\" , MkType ( dict , default = {})), ( \"default_handler\" , MkType ( str , default = \"python\" )), ( \"custom_templates\" , MkType ( str , default = None )), ( \"enable_inventory\" , MkType ( bool , default = None )), ( \"enabled\" , MkType ( bool , default = True )), ) \"\"\" The configuration options of `mkdocstrings`, written in `mkdocs.yml`. Available options are: - **`watch` (deprecated)**: A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. Deprecated in favor of the now built-in `watch` feature of MkDocs. - **`default_handler`**: The default handler to use. The value is the name of the handler module. Default is \"python\". - **`enabled`**: Whether to enable the plugin. Default is true. If false, *mkdocstrings* will not collect or render anything. - **`handlers`**: Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: ```yaml plugins: - mkdocstrings: handlers: python: options: selection_opt: true rendering_opt: \"value\" rust: options: selection_opt: 2 ``` \"\"\" css_filename = \"assets/_mkdocstrings.css\" def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Handlers | None = None @property def handlers ( self ) -> Handlers : \"\"\"Get the instance of [mkdocstrings.handlers.base.Handlers][] for this plugin/build. Raises: RuntimeError: If the plugin hasn't been initialized with a config. Returns: An instance of [mkdocstrings.handlers.base.Handlers][] (the same throughout the build). \"\"\" if not self . _handlers : raise RuntimeError ( \"The plugin hasn't been initialized with a config yet\" ) return self . _handlers # TODO: remove once watch feature is removed def on_serve ( self , server : LiveReloadServer , config : Config , # noqa: ARG002 builder : Callable , * args : Any , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. config: The MkDocs config object (unused). builder: The function to build the site. *args: Additional arguments passed by MkDocs. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return if self . config [ \"watch\" ]: for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: ARG002 \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" if not self . plugin_enabled : log . debug ( \"Plugin is not enabled. Skipping.\" ) return config log . debug ( \"Adding extension to the list\" ) theme_name = config [ \"theme\" ] . name or os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } # noqa: PLW2901 to_import . append (( handler_name , import_item )) extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , \"mkdocs\" : config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : future = inv_loader . submit ( self . _load_inventory , # type: ignore[misc] self . get_handler ( handler_name ) . load_inventory , ** import_item , ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) if self . config [ \"watch\" ]: self . _warn_about_watch_option () return config @property def inventory_enabled ( self ) -> bool : \"\"\"Tell if the inventory is enabled or not. Returns: Whether the inventory is enabled. \"\"\" inventory_enabled = self . config [ \"enable_inventory\" ] if inventory_enabled is None : inventory_enabled = any ( handler . enable_inventory for handler in self . handlers . seen_handlers ) return inventory_enabled @property def plugin_enabled ( self ) -> bool : \"\"\"Tell if the plugin is enabled or not. Returns: Whether the plugin is enabled. \"\"\" return self . config [ \"enabled\" ] def on_env ( self , env : Environment , config : Config , * args : Any , ** kwargs : Any ) -> None : # noqa: ARG002 \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if not self . plugin_enabled : return if self . _handlers : css_content = \" \\n \" . join ( handler . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = [] def on_post_build ( self , config : Config , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown () def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name ) @classmethod # lru_cache does not allow mutable arguments such lists, but that is what we load from YAML config. @list_to_tuple @functools . lru_cache ( maxsize = None ) def _load_inventory ( cls , loader : InventoryLoaderType , url : str , ** kwargs : Any ) -> Mapping [ str , str ]: \"\"\"Download and process inventory files using a handler. Arguments: loader: A function returning a sequence of pairs (identifier, url). url: The URL to download and process. **kwargs: Extra arguments to pass to the loader. Returns: A mapping from identifier to absolute URL. \"\"\" log . debug ( f \"Downloading inventory from { url !r} \" ) req = request . Request ( url , headers = { \"Accept-Encoding\" : \"gzip\" , \"User-Agent\" : \"mkdocstrings/0.15.0\" }) with request . urlopen ( req ) as resp : # noqa: S310 (URL audit OK: comes from a checked-in config) content : BinaryIO = resp if \"gzip\" in resp . headers . get ( \"content-encoding\" , \"\" ): content = gzip . GzipFile ( fileobj = resp ) # type: ignore[assignment] result = dict ( loader ( content , url = url , ** kwargs )) log . debug ( f \"Loaded inventory from { url !r} : { len ( result ) } items\" ) return result @classmethod @functools . lru_cache ( maxsize = None ) # Warn only once def _warn_about_watch_option ( cls ) -> None : log . info ( \"DEPRECATION: mkdocstrings' watch feature is deprecated in favor of MkDocs' watch feature, \" \"see https://www.mkdocs.org/user-guide/configuration/#watch\" , )","title":"MkdocstringsPlugin"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch (deprecated) : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. Deprecated in favor of the now built-in watch feature of MkDocs. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". enabled : Whether to enable the plugin. Default is true. If false, mkdocstrings will not collect or render anything. handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : options : selection_opt : true rendering_opt : \"value\" rust : options : selection_opt : 2","title":"config_scheme"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.handlers","text":"Get the instance of mkdocstrings.handlers.base.Handlers for this plugin/build. Raises: Type Description RuntimeError If the plugin hasn't been initialized with a config. Returns: Type Description Handlers An instance of mkdocstrings.handlers.base.Handlers (the same throughout the build).","title":"handlers"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.inventory_enabled","text":"Tell if the inventory is enabled or not. Returns: Type Description bool Whether the inventory is enabled.","title":"inventory_enabled"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.plugin_enabled","text":"Tell if the plugin is enabled or not. Returns: Type Description bool Whether the plugin is enabled.","title":"plugin_enabled"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Initialize the object. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 122 123 124 125 def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _handlers : Handlers | None = None","title":"__init__()"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.get_handler","text":"Get a handler by its name. See mkdocstrings.handlers.base.Handlers.get_handler . Parameters: Name Type Description Default handler_name str The name of the handler. required Returns: Type Description BaseHandler An instance of a subclass of BaseHandler . Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 321 322 323 324 325 326 327 328 329 330 def get_handler ( self , handler_name : str ) -> BaseHandler : \"\"\"Get a handler by its name. See [mkdocstrings.handlers.base.Handlers.get_handler][]. Arguments: handler_name: The name of the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler]. \"\"\" return self . handlers . get_handler ( handler_name )","title":"get_handler()"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our MkdocstringsExtension and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def on_config ( self , config : Config , ** kwargs : Any ) -> Config : # noqa: ARG002 \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" if not self . plugin_enabled : log . debug ( \"Plugin is not enabled. Skipping.\" ) return config log . debug ( \"Adding extension to the list\" ) theme_name = config [ \"theme\" ] . name or os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) to_import : InventoryImportType = [] for handler_name , conf in self . config [ \"handlers\" ] . items (): for import_item in conf . pop ( \"import\" , ()): if isinstance ( import_item , str ): import_item = { \"url\" : import_item } # noqa: PLW2901 to_import . append (( handler_name , import_item )) extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , \"mkdocs\" : config , } self . _handlers = Handlers ( extension_config ) try : # If autorefs plugin is explicitly enabled, just use it. autorefs = config [ \"plugins\" ][ \"autorefs\" ] log . debug ( f \"Picked up existing autorefs instance { autorefs !r} \" ) except KeyError : # Otherwise, add a limited instance of it that acts only on what's added through `register_anchor`. autorefs = AutorefsPlugin () autorefs . scan_toc = False config [ \"plugins\" ][ \"autorefs\" ] = autorefs log . debug ( f \"Added a subdued autorefs instance { autorefs !r} \" ) # Add collector-based fallback in either case. autorefs . get_fallback_anchor = self . handlers . get_anchors mkdocstrings_extension = MkdocstringsExtension ( extension_config , self . handlers , autorefs ) config [ \"markdown_extensions\" ] . append ( mkdocstrings_extension ) config [ \"extra_css\" ] . insert ( 0 , self . css_filename ) # So that it has lower priority than user files. self . _inv_futures = [] if to_import : inv_loader = futures . ThreadPoolExecutor ( 4 ) for handler_name , import_item in to_import : future = inv_loader . submit ( self . _load_inventory , # type: ignore[misc] self . get_handler ( handler_name ) . load_inventory , ** import_item , ) self . _inv_futures . append ( future ) inv_loader . shutdown ( wait = False ) if self . config [ \"watch\" ]: self . _warn_about_watch_option () return config","title":"on_config()"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_env","text":"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the on_env event . Write mkdocstrings' extra files into the site dir. Gather results from background inventory download tasks. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def on_env ( self , env : Environment , config : Config , * args : Any , ** kwargs : Any ) -> None : # noqa: ARG002 \"\"\"Extra actions that need to happen after all Markdown rendering and before HTML rendering. Hook for the [`on_env` event](https://www.mkdocs.org/user-guide/plugins/#on_env). - Write mkdocstrings' extra files into the site dir. - Gather results from background inventory download tasks. \"\"\" if not self . plugin_enabled : return if self . _handlers : css_content = \" \\n \" . join ( handler . extra_css for handler in self . handlers . seen_handlers ) write_file ( css_content . encode ( \"utf-8\" ), os . path . join ( config [ \"site_dir\" ], self . css_filename )) if self . inventory_enabled : log . debug ( \"Creating inventory file objects.inv\" ) inv_contents = self . handlers . inventory . format_sphinx () write_file ( inv_contents , os . path . join ( config [ \"site_dir\" ], \"objects.inv\" )) if self . _inv_futures : log . debug ( f \"Waiting for { len ( self . _inv_futures ) } inventory download(s)\" ) futures . wait ( self . _inv_futures , timeout = 30 ) for page , identifier in collections . ChainMap ( * ( fut . result () for fut in self . _inv_futures )) . items (): config [ \"plugins\" ][ \"autorefs\" ] . register_url ( page , identifier ) self . _inv_futures = []","title":"on_env()"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's teardown method, which is indirectly called by this hook. Parameters: Name Type Description Default config Config The MkDocs config object. required **kwargs Any Additional arguments passed by MkDocs. {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def on_post_build ( self , config : Config , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, a handler could open a subprocess in the background and keep it open to feed it \"autodoc\" instructions and get back JSON data. If so, it should then close the subprocess at some point: the proper place to do this is in the collector's `teardown` method, which is indirectly called by this hook. Arguments: config: The MkDocs config object. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return for future in self . _inv_futures : future . cancel () if self . _handlers : log . debug ( \"Tearing handlers down\" ) self . handlers . teardown ()","title":"on_post_build()"},{"location":"docstrings/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server LiveReloadServer The livereload server instance. required config Config The MkDocs config object (unused). required builder Callable The function to build the site. required *args Any Additional arguments passed by MkDocs. () **kwargs Any Additional arguments passed by MkDocs. {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def on_serve ( self , server : LiveReloadServer , config : Config , # noqa: ARG002 builder : Callable , * args : Any , # noqa: ARG002 ** kwargs : Any , # noqa: ARG002 ) -> None : \"\"\"Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. config: The MkDocs config object (unused). builder: The function to build the site. *args: Additional arguments passed by MkDocs. **kwargs: Additional arguments passed by MkDocs. \"\"\" if not self . plugin_enabled : return if self . config [ \"watch\" ]: for element in self . config [ \"watch\" ]: log . debug ( f \"Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder )","title":"on_serve()"},{"location":"docstrings/#mkdocstrings.plugin.list_to_tuple","text":"Decorater to convert lists to tuples in the arguments. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/plugin.py 59 60 61 62 63 64 65 66 67 68 def list_to_tuple ( function : Callable [ P , R ]) -> Callable [ P , R ]: \"\"\"Decorater to convert lists to tuples in the arguments.\"\"\" def wrapper ( * args : P . args , ** kwargs : P . kwargs ) -> R : safe_args = [ tuple ( item ) if isinstance ( item , list ) else item for item in args ] if kwargs : kwargs = { key : tuple ( value ) if isinstance ( value , list ) else value for key , value in kwargs . items ()} # type: ignore[assignment] return function ( * safe_args , ** kwargs ) # type: ignore[arg-type] return wrapper This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a handler to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc","title":"list_to_tuple()"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor","text":"Bases: BlockProcessor Our \"autodoc\" Markdown block processor. It has a test method that tells if a block matches a criterion, and a run method that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class AutoDocProcessor ( BlockProcessor ): \"\"\"Our \"autodoc\" Markdown block processor. It has a [`test` method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [`run` method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. \"\"\" regex = re . compile ( r \"^(?P<heading>#{1,6} *|)::: ?(?P<name>.+?) *$\" , flags = re . MULTILINE ) def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_envs : set = set () def test ( self , parent : Element , block : str ) -> bool : # noqa: ARG002 \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block )) def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . get_headings () el . extend ( headings ) page = self . _autorefs . current_page if page : for heading in headings : anchor = heading . attrib [ \"id\" ] self . _autorefs . register_anchor ( page , anchor ) if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) def _process_block ( self , identifier : str , yaml_block : str , heading_level : int = 0 , ) -> tuple [ str , BaseHandler , CollectorItem ]: \"\"\"Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. heading_level: Suggested level of the heading to insert (0 to ignore). Raises: PluginError: When something wrong happened during collection. TemplateNotFound: When a template used for rendering could not be found. Returns: Rendered HTML, the handler that was used, and the collected item. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . _handlers . get_handler_name ( config ) log . debug ( f \"Using handler ' { handler_name } '\" ) handler_config = self . _handlers . get_handler_config ( handler_name ) handler = self . _handlers . get_handler ( handler_name , handler_config ) global_options = handler_config . get ( \"options\" , {}) local_options = config . get ( \"options\" , {}) deprecated_global_options = ChainMap ( handler_config . get ( \"selection\" , {}), handler_config . get ( \"rendering\" , {})) deprecated_local_options = ChainMap ( config . get ( \"selection\" , {}), config . get ( \"rendering\" , {})) options = ChainMap ( local_options , deprecated_local_options , global_options , deprecated_global_options ) if deprecated_global_options or deprecated_local_options : self . _warn_about_options_key () if heading_level : options = ChainMap ( options , { \"heading_level\" : heading_level }) # like setdefault log . debug ( \"Collecting data\" ) try : data : CollectorItem = handler . collect ( identifier , options ) except CollectionError as exception : log . error ( str ( exception )) # noqa: TRY400 if PluginError is SystemExit : # When MkDocs 1.2 is sufficiently common, this can be dropped. log . error ( f \"Error reading page ' { self . _autorefs . current_page } ':\" ) # noqa: TRY400 raise PluginError ( f \"Could not collect ' { identifier } '\" ) from exception if handler_name not in self . _updated_envs : # We haven't seen this handler before on this document. log . debug ( \"Updating renderer's env\" ) handler . _update_env ( self . md , self . _config ) self . _updated_envs . add ( handler_name ) log . debug ( \"Rendering templates\" ) try : rendered = handler . render ( data , options ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( # noqa: TRY400 f \"Template ' { exc . name } ' not found for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise return rendered , handler , data @classmethod @functools . lru_cache ( maxsize = None ) # Warn only once def _warn_about_options_key ( cls ) -> None : log . info ( \"DEPRECATION: 'selection' and 'rendering' are deprecated and merged into a single 'options' YAML key\" )","title":"AutoDocProcessor"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The configuration of the mkdocstrings plugin. required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ) -> None : \"\"\"Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. handlers: The handlers container. autorefs: The autorefs plugin instance. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config self . _handlers = handlers self . _autorefs = autorefs self . _updated_envs : set = set ()","title":"__init__()"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.run","text":"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks MutableSequence [ str ] The rest of the blocks to be processed. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def run ( self , parent : Element , blocks : MutableSequence [ str ]) -> None : \"\"\"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( block ) if match : if match . start () > 0 : self . parser . parseBlocks ( parent , [ block [: match . start ()]]) # removes the first line block = block [ match . end () :] block , the_rest = self . detab ( block ) if match : identifier = match [ \"name\" ] heading_level = match [ \"heading\" ] . count ( \"#\" ) log . debug ( f \"Matched '::: { identifier } '\" ) html , handler , data = self . _process_block ( identifier , block , heading_level ) el = Element ( \"div\" , { \"class\" : \"mkdocstrings\" }) # The final HTML is inserted as opaque to subsequent processing, and only revealed at the end. el . text = self . md . htmlStash . store ( html ) # So we need to duplicate the headings directly (and delete later), just so 'toc' can pick them up. headings = handler . get_headings () el . extend ( headings ) page = self . _autorefs . current_page if page : for heading in headings : anchor = heading . attrib [ \"id\" ] self . _autorefs . register_anchor ( page , anchor ) if \"data-role\" in heading . attrib : self . _handlers . inventory . register ( name = anchor , domain = handler . domain , role = heading . attrib [ \"data-role\" ], uri = f \" { page } # { anchor } \" , ) parent . append ( el ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"docstrings/#mkdocstrings.extension.AutoDocProcessor.test","text":"Match our autodoc instructions. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required block str The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 89 90 91 92 93 94 95 96 97 98 99 def test ( self , parent : Element , block : str ) -> bool : # noqa: ARG002 \"\"\"Match our autodoc instructions. Arguments: parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" return bool ( self . regex . search ( block ))","title":"test()"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension","text":"Bases: Extension Our Markdown extension. It cannot work outside of mkdocstrings . Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 class MkdocstringsExtension ( Extension ): \"\"\"Our Markdown extension. It cannot work outside of `mkdocstrings`. \"\"\" def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. )","title":"MkdocstringsExtension"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in extendMarkdown . required handlers Handlers The handlers container. required autorefs AutorefsPlugin The autorefs plugin instance. required **kwargs Any Keyword arguments used by markdown.extensions.Extension . {} Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , config : dict , handlers : Handlers , autorefs : AutorefsPlugin , ** kwargs : Any ) -> None : \"\"\"Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. handlers: The handlers container. autorefs: The autorefs plugin instance. **kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config self . _handlers = handlers self . _autorefs = autorefs","title":"__init__()"},{"location":"docstrings/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoDocProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/extension.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . parser . blockprocessors . register ( AutoDocProcessor ( md . parser , md , self . _config , self . _handlers , self . _autorefs ), \"mkdocstrings\" , priority = 75 , # Right before markdown.blockprocessors.HashHeaderProcessor ) md . treeprocessors . register ( _PostProcessor ( md ), \"mkdocstrings_post\" , priority = 4 , # Right after 'toc'. ) Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache.","title":"extendMarkdown()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BaseCollector : \"\"\"The base collector class. Inherit from this class to implement a collector. You will have to implement the `collect` method. You can also implement the `teardown` method. \"\"\" def collect ( self , identifier : str , config : MutableMapping [ str , Any ]) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: The handler's configuration options. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"BaseCollector"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config MutableMapping [ str , Any ] The handler's configuration options. required Returns: Type Description CollectorItem Anything you want, as long as you can feed it to the renderer's render method. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def collect ( self , identifier : str , config : MutableMapping [ str , Any ]) -> CollectorItem : \"\"\"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: The handler's configuration options. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError","title":"collect()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseCollector.teardown","text":"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 345 346 347 348 349 350 def teardown ( self ) -> None : \"\"\"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"teardown()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler","text":"Bases: BaseCollector , BaseRenderer The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: Name Type Description domain str The cross-documentation domain/language for this handler. enable_inventory bool Whether this handler is interested in enabling the creation of the objects.inv Sphinx inventory file. fallback_config dict The configuration used to collect item during autorefs fallback. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 class BaseHandler ( BaseCollector , BaseRenderer ): \"\"\"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. Attributes: domain: The cross-documentation domain/language for this handler. enable_inventory: Whether this handler is interested in enabling the creation of the `objects.inv` Sphinx inventory file. fallback_config: The configuration used to collect item during autorefs fallback. \"\"\" domain : str = \"default\" enable_inventory : bool = False fallback_config : dict = {} # TODO: once the BaseCollector and BaseRenderer classes are removed, # stop accepting the 'handler' parameter, and instead set a 'name' attribute on the Handler class. # Then make the 'handler' parameter in 'get_templates_dir' optional, and use the class 'name' by default. def __init__ ( self , * args : str | BaseCollector | BaseRenderer , ** kwargs : str | BaseCollector | BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: *args: Collector and renderer, or handler name, theme and custom_templates. **kwargs: Same thing, but with keyword arguments. Raises: ValueError: When the given parameters are invalid. \"\"\" # The method accepts *args and **kwargs temporarily, # to support the transition period where the BaseCollector # and BaseRenderer are deprecated, and the BaseHandler # can be instantiated with both instances of collector/renderer, # or renderer parameters, as positional parameters. collector = None renderer = None # parsing positional arguments str_args = [] for arg in args : if isinstance ( arg , BaseCollector ): collector = arg elif isinstance ( arg , BaseRenderer ): renderer = arg elif isinstance ( arg , str ): str_args . append ( arg ) while len ( str_args ) != 3 : # noqa: PLR2004 str_args . append ( None ) # type: ignore[arg-type] handler , theme , custom_templates = str_args # fetching values from keyword arguments if \"collector\" in kwargs : collector = kwargs . pop ( \"collector\" ) # type: ignore[assignment] if \"renderer\" in kwargs : renderer = kwargs . pop ( \"renderer\" ) # type: ignore[assignment] if \"handler\" in kwargs : handler = kwargs . pop ( \"handler\" ) # type: ignore[assignment] if \"theme\" in kwargs : theme = kwargs . pop ( \"theme\" ) # type: ignore[assignment] if \"custom_templates\" in kwargs : custom_templates = kwargs . pop ( \"custom_templates\" ) # type: ignore[assignment] if collector is None and renderer is not None or collector is not None and renderer is None : raise ValueError ( \"both 'collector' and 'renderer' must be provided\" ) if collector is not None : warnings . warn ( DeprecationWarning ( \"The BaseCollector class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \" \"methods directly on your handler class.\" , ), stacklevel = 1 , ) self . collector = collector self . collect = collector . collect # type: ignore[method-assign] self . teardown = collector . teardown # type: ignore[method-assign] if renderer is not None : if { handler , theme , custom_templates } != { None }: raise ValueError ( \"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\" , ) warnings . warn ( DeprecationWarning ( \"The BaseRenderer class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `render` method \" \"directly on your handler class (as well as other methods and attributes like \" \"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\" , ), stacklevel = 1 , ) self . renderer = renderer self . render = renderer . render # type: ignore[method-assign] self . get_templates_dir = renderer . get_templates_dir # type: ignore[method-assign] self . get_anchors = renderer . get_anchors # type: ignore[method-assign] self . do_convert_markdown = renderer . do_convert_markdown # type: ignore[method-assign] self . do_heading = renderer . do_heading # type: ignore[method-assign] self . get_headings = renderer . get_headings # type: ignore[method-assign] self . update_env = renderer . update_env # type: ignore[method-assign] self . _update_env = renderer . _update_env # type: ignore[method-assign] self . fallback_theme = renderer . fallback_theme self . extra_css = renderer . extra_css renderer . __class__ . __init__ ( self , renderer . _handler , renderer . _theme , renderer . _custom_templates , ) else : if handler is None or theme is None : raise ValueError ( \"'handler' and 'theme' cannot be None\" ) BaseRenderer . __init__ ( self , handler , theme , custom_templates ) @classmethod def load_inventory ( cls , in_file : BinaryIO , # noqa: ARG003 url : str , # noqa: ARG003 base_url : str | None = None , # noqa: ARG003 ** kwargs : Any , # noqa: ARG003 ) -> Iterator [ tuple [ str , str ]]: \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`. Arguments: in_file: The binary file-like object to read the inventory from. url: The URL that this file is being streamed from (used to guess `base_url`). base_url: The URL that this inventory's sub-paths are relative to. **kwargs: Ignore additional arguments passed from the config. Yields: Tuples of (item identifier, item URL). \"\"\" yield from ()","title":"BaseHandler"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.__init__","text":"Initialize the object. Parameters: Name Type Description Default *args str | BaseCollector | BaseRenderer Collector and renderer, or handler name, theme and custom_templates. () **kwargs str | BaseCollector | BaseRenderer Same thing, but with keyword arguments. {} Raises: Type Description ValueError When the given parameters are invalid. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def __init__ ( self , * args : str | BaseCollector | BaseRenderer , ** kwargs : str | BaseCollector | BaseRenderer ) -> None : \"\"\"Initialize the object. Arguments: *args: Collector and renderer, or handler name, theme and custom_templates. **kwargs: Same thing, but with keyword arguments. Raises: ValueError: When the given parameters are invalid. \"\"\" # The method accepts *args and **kwargs temporarily, # to support the transition period where the BaseCollector # and BaseRenderer are deprecated, and the BaseHandler # can be instantiated with both instances of collector/renderer, # or renderer parameters, as positional parameters. collector = None renderer = None # parsing positional arguments str_args = [] for arg in args : if isinstance ( arg , BaseCollector ): collector = arg elif isinstance ( arg , BaseRenderer ): renderer = arg elif isinstance ( arg , str ): str_args . append ( arg ) while len ( str_args ) != 3 : # noqa: PLR2004 str_args . append ( None ) # type: ignore[arg-type] handler , theme , custom_templates = str_args # fetching values from keyword arguments if \"collector\" in kwargs : collector = kwargs . pop ( \"collector\" ) # type: ignore[assignment] if \"renderer\" in kwargs : renderer = kwargs . pop ( \"renderer\" ) # type: ignore[assignment] if \"handler\" in kwargs : handler = kwargs . pop ( \"handler\" ) # type: ignore[assignment] if \"theme\" in kwargs : theme = kwargs . pop ( \"theme\" ) # type: ignore[assignment] if \"custom_templates\" in kwargs : custom_templates = kwargs . pop ( \"custom_templates\" ) # type: ignore[assignment] if collector is None and renderer is not None or collector is not None and renderer is None : raise ValueError ( \"both 'collector' and 'renderer' must be provided\" ) if collector is not None : warnings . warn ( DeprecationWarning ( \"The BaseCollector class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `collect` and `teardown` \" \"methods directly on your handler class.\" , ), stacklevel = 1 , ) self . collector = collector self . collect = collector . collect # type: ignore[method-assign] self . teardown = collector . teardown # type: ignore[method-assign] if renderer is not None : if { handler , theme , custom_templates } != { None }: raise ValueError ( \"'handler', 'theme' and 'custom_templates' must all be None when providing a renderer instance\" , ) warnings . warn ( DeprecationWarning ( \"The BaseRenderer class is deprecated, and passing an instance of it \" \"to your handler is deprecated as well. Instead, define the `render` method \" \"directly on your handler class (as well as other methods and attributes like \" \"`get_templates_dir`, `get_anchors`, `update_env` and `fallback_theme`, `extra_css`).\" , ), stacklevel = 1 , ) self . renderer = renderer self . render = renderer . render # type: ignore[method-assign] self . get_templates_dir = renderer . get_templates_dir # type: ignore[method-assign] self . get_anchors = renderer . get_anchors # type: ignore[method-assign] self . do_convert_markdown = renderer . do_convert_markdown # type: ignore[method-assign] self . do_heading = renderer . do_heading # type: ignore[method-assign] self . get_headings = renderer . get_headings # type: ignore[method-assign] self . update_env = renderer . update_env # type: ignore[method-assign] self . _update_env = renderer . _update_env # type: ignore[method-assign] self . fallback_theme = renderer . fallback_theme self . extra_css = renderer . extra_css renderer . __class__ . __init__ ( self , renderer . _handler , renderer . _theme , renderer . _custom_templates , ) else : if handler is None or theme is None : raise ValueError ( \"'handler' and 'theme' cannot be None\" ) BaseRenderer . __init__ ( self , handler , theme , custom_templates )","title":"__init__()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseHandler.load_inventory","text":"Yield items and their URLs from an inventory file streamed from in_file . Parameters: Name Type Description Default in_file BinaryIO The binary file-like object to read the inventory from. required url str The URL that this file is being streamed from (used to guess base_url ). required base_url str | None The URL that this inventory's sub-paths are relative to. None **kwargs Any Ignore additional arguments passed from the config. {} Yields: Type Description Iterator [ tuple [ str , str ]] Tuples of (item identifier, item URL). Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 @classmethod def load_inventory ( cls , in_file : BinaryIO , # noqa: ARG003 url : str , # noqa: ARG003 base_url : str | None = None , # noqa: ARG003 ** kwargs : Any , # noqa: ARG003 ) -> Iterator [ tuple [ str , str ]]: \"\"\"Yield items and their URLs from an inventory file streamed from `in_file`. Arguments: in_file: The binary file-like object to read the inventory from. url: The URL that this file is being streamed from (used to guess `base_url`). base_url: The URL that this inventory's sub-paths are relative to. **kwargs: Ignore additional arguments passed from the config. Yields: Tuples of (item identifier, item URL). \"\"\" yield from ()","title":"load_inventory()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a fallback_theme class-variable. To add custom CSS, add an extra_css variable or create an 'style.css' file beside the templates. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class BaseRenderer : \"\"\"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the `render` method. You can also override the `update_env` method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a `fallback_theme` class-variable. To add custom CSS, add an `extra_css` variable or create an 'style.css' file beside the templates. \"\"\" fallback_theme : str = \"\" extra_css = \"\" def __init__ ( self , handler : str , theme : str , custom_templates : str | None = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] # TODO: remove once BaseRenderer is merged into BaseHandler self . _handler = handler self . _theme = theme self . _custom_templates = custom_templates themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : list [ Element ] = [] self . _md : Markdown = None # type: ignore[assignment] # To be populated in `update_env`. def render ( self , data : CollectorItem , config : Mapping [ str , Any ]) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The handler's configuration options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , stacklevel = 1 , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" ) def get_anchors ( self , data : CollectorItem ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore[attr-defined] except AttributeError : return () def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False , ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset () def do_heading ( self , content : Markup , heading_level : int , * , role : str | None = None , hidden : bool = False , toc_label : str | None = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( content , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( # noqa: S101 html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html ) def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: ARG002 \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading def _update_env ( self , md : Markdown , config : dict ) -> None : \"\"\"Update our handler to point to our configured Markdown instance, grabbing some of the config from `md`.\"\"\" extensions = config [ \"mdx\" ] + [ MkdocstringsInnerExtension ( self . _headings )] new_md = Markdown ( extensions = extensions , extension_configs = config [ \"mdx_configs\" ]) # MkDocs adds its own (required) extension that's not part of the config. Propagate it. if \"relpath\" in md . treeprocessors : new_md . treeprocessors . register ( md . treeprocessors [ \"relpath\" ], \"relpath\" , priority = 0 ) self . update_env ( new_md , config )","title":"BaseRenderer"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.__init__","text":"Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default handler str The name of the handler. required theme str The name of theme to use. required custom_templates str | None Directory containing custom templates. None Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , handler : str , theme : str , custom_templates : str | None = None ) -> None : \"\"\"Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: handler: The name of the handler. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] # TODO: remove once BaseRenderer is merged into BaseHandler self . _handler = handler self . _theme = theme self . _custom_templates = custom_templates themes_dir = self . get_templates_dir ( handler ) paths . append ( themes_dir / theme ) if self . fallback_theme and self . fallback_theme != theme : paths . append ( themes_dir / self . fallback_theme ) for path in paths : css_path = path / \"style.css\" if css_path . is_file (): self . extra_css += \" \\n \" + css_path . read_text ( encoding = \"utf-8\" ) break if custom_templates is not None : paths . insert ( 0 , Path ( custom_templates ) / handler / theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths ), auto_reload = False , # Editing a template in the middle of a build is not useful. ) self . env . filters [ \"any\" ] = do_any self . env . globals [ \"log\" ] = get_template_logger () self . _headings : list [ Element ] = [] self . _md : Markdown = None # type: ignore[assignment] # To be populated in `update_env`.","title":"__init__()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.do_convert_markdown","text":"Render Markdown text; for use inside templates. Parameters: Name Type Description Default text str The text to convert. required heading_level int The base heading level to start all Markdown headings from. required html_id str The HTML id of the element that's considered the parent of this element. '' strip_paragraph bool Whether to exclude the tag from around the whole output. False Returns: Type Description Markup An HTML string. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def do_convert_markdown ( self , text : str , heading_level : int , html_id : str = \"\" , * , strip_paragraph : bool = False , ) -> Markup : \"\"\"Render Markdown text; for use inside templates. Arguments: text: The text to convert. heading_level: The base heading level to start all Markdown headings from. html_id: The HTML id of the element that's considered the parent of this element. strip_paragraph: Whether to exclude the <p> tag from around the whole output. Returns: An HTML string. \"\"\" treeprocessors = self . _md . treeprocessors treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = heading_level treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = html_id and html_id + \"--\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = strip_paragraph try : return Markup ( self . _md . convert ( text )) finally : treeprocessors [ HeadingShiftingTreeprocessor . name ] . shift_by = 0 treeprocessors [ IdPrependingTreeprocessor . name ] . id_prefix = \"\" treeprocessors [ ParagraphStrippingTreeprocessor . name ] . strip = False self . _md . reset ()","title":"do_convert_markdown()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.do_heading","text":"Render an HTML heading and register it for the table of contents. For use inside templates. Parameters: Name Type Description Default content Markup The HTML within the heading. required heading_level int The level of heading (e.g. 3 -> h3 ). required role str | None An optional role for the object bound to this heading. None hidden bool If True, only register it for the table of contents, don't render anything. False toc_label str | None The title to use in the table of contents ('data-toc-label' attribute). None **attributes str Any extra HTML attributes of the heading. {} Returns: Type Description Markup An HTML string. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def do_heading ( self , content : Markup , heading_level : int , * , role : str | None = None , hidden : bool = False , toc_label : str | None = None , ** attributes : str , ) -> Markup : \"\"\"Render an HTML heading and register it for the table of contents. For use inside templates. Arguments: content: The HTML within the heading. heading_level: The level of heading (e.g. 3 -> `h3`). role: An optional role for the object bound to this heading. hidden: If True, only register it for the table of contents, don't render anything. toc_label: The title to use in the table of contents ('data-toc-label' attribute). **attributes: Any extra HTML attributes of the heading. Returns: An HTML string. \"\"\" # First, produce the \"fake\" heading, for ToC only. el = Element ( f \"h { heading_level } \" , attributes ) if toc_label is None : toc_label = content . unescape () if isinstance ( content , Markup ) else content el . set ( \"data-toc-label\" , toc_label ) if role : el . set ( \"data-role\" , role ) self . _headings . append ( el ) if hidden : return Markup ( '<a id=\" {0} \"></a>' ) . format ( attributes [ \"id\" ]) # Now produce the actual HTML to be rendered. The goal is to wrap the HTML content into a heading. # Start with a heading that has just attributes (no text), and add a placeholder into it. el = Element ( f \"h { heading_level } \" , attributes ) el . append ( Element ( \"mkdocstrings-placeholder\" )) # Tell the 'toc' extension to make its additions if configured so. toc = self . _md . treeprocessors [ \"toc\" ] if toc . use_anchors : toc . add_anchor ( el , attributes [ \"id\" ]) if toc . use_permalinks : toc . add_permalink ( el , attributes [ \"id\" ]) # The content we received is HTML, so it can't just be inserted into the tree. We had marked the middle # of the heading with a placeholder that can never occur (text can't directly contain angle brackets). # Now this HTML wrapper can be \"filled\" by replacing the placeholder. html_with_placeholder = tostring ( el , encoding = \"unicode\" ) assert ( # noqa: S101 html_with_placeholder . count ( \"<mkdocstrings-placeholder />\" ) == 1 ), f \"Bug in mkdocstrings: failed to replace in { html_with_placeholder !r} \" html = html_with_placeholder . replace ( \"<mkdocstrings-placeholder />\" , content ) return Markup ( html )","title":"do_heading()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_anchors","text":"Return the possible identifiers (HTML anchors) for a collected item. Parameters: Name Type Description Default data CollectorItem The collected data. required Returns: Type Description tuple [ str , ...] | set [ str ] The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def get_anchors ( self , data : CollectorItem ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the possible identifiers (HTML anchors) for a collected item. Arguments: data: The collected data. Returns: The HTML anchors (without '#'), or an empty tuple if this item doesn't have an anchor. \"\"\" # TODO: remove this at some point try : return ( self . get_anchor ( data ),) # type: ignore[attr-defined] except AttributeError : return ()","title":"get_anchors()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_headings","text":"Return and clear the headings gathered so far. Returns: Type Description Sequence [ Element ] A list of HTML elements. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 284 285 286 287 288 289 290 291 292 def get_headings ( self ) -> Sequence [ Element ]: \"\"\"Return and clear the headings gathered so far. Returns: A list of HTML elements. \"\"\" result = list ( self . _headings ) self . _headings . clear () return result","title":"get_headings()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.get_templates_dir","text":"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Parameters: Name Type Description Default handler str The name of the handler to get the templates directory of. required Raises: Type Description FileNotFoundError When the templates directory cannot be found. Returns: Type Description Path The templates directory path. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def get_templates_dir ( self , handler : str ) -> Path : \"\"\"Return the path to the handler's templates directory. Override to customize how the templates directory is found. Arguments: handler: The name of the handler to get the templates directory of. Raises: FileNotFoundError: When the templates directory cannot be found. Returns: The templates directory path. \"\"\" # Templates can be found in 2 different logical locations: # - in mkdocstrings_handlers/HANDLER/templates: our new migration target # - in mkdocstrings/templates/HANDLER: current situation, this should be avoided # These two other locations are forbidden: # - in mkdocstrings_handlers/templates/HANDLER: sub-namespace packages are too annoying to deal with # - in mkdocstrings/handlers/HANDLER/templates: not currently supported, # and mkdocstrings will stop being a namespace with suppress ( ModuleNotFoundError ): # TODO: catch at some point to warn about missing handlers import mkdocstrings_handlers for path in mkdocstrings_handlers . __path__ : theme_path = Path ( path , handler , \"templates\" ) if theme_path . exists (): return theme_path # TODO: remove import and loop at some point, # as mkdocstrings will stop being a namespace package import mkdocstrings for path in mkdocstrings . __path__ : theme_path = Path ( path , \"templates\" , handler ) if theme_path . exists (): if handler != \"python\" : warnings . warn ( \"Exposing templates in the mkdocstrings.templates namespace is deprecated. \" \"Put them in a templates folder inside your handler package instead.\" , DeprecationWarning , stacklevel = 1 , ) return theme_path raise FileNotFoundError ( f \"Can't find 'templates' folder for handler ' { handler } '\" )","title":"get_templates_dir()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data CollectorItem The collected data to render. required config Mapping [ str , Any ] The handler's configuration options. required Returns: Type Description str The rendered template as HTML. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 122 123 124 125 126 127 128 129 130 131 132 def render ( self , data : CollectorItem , config : Mapping [ str , Any ]) -> str : \"\"\"Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The handler's configuration options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError","title":"render()"},{"location":"docstrings/#mkdocstrings.handlers.base.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 294 295 296 297 298 299 300 301 302 303 304 305 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: ARG002 \"\"\"Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _md = md self . env . filters [ \"highlight\" ] = Highlighter ( md ) . highlight self . env . filters [ \"convert_markdown\" ] = self . do_convert_markdown self . env . filters [ \"heading\" ] = self . do_heading","title":"update_env()"},{"location":"docstrings/#mkdocstrings.handlers.base.CollectionError","text":"Bases: Exception An exception raised when some collection of data failed. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 37 38 class CollectionError ( Exception ): \"\"\"An exception raised when some collection of data failed.\"\"\"","title":"CollectionError"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers","text":"A collection of handlers. Do not instantiate this directly. The plugin will keep one instance of this for the purpose of caching. Use mkdocstrings.plugin.MkdocstringsPlugin.get_handler for convenient access. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 class Handlers : \"\"\"A collection of handlers. Do not instantiate this directly. [The plugin][mkdocstrings.plugin.MkdocstringsPlugin] will keep one instance of this for the purpose of caching. Use [mkdocstrings.plugin.MkdocstringsPlugin.get_handler][] for convenient access. \"\"\" def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"mkdocs\" ][ \"site_name\" ]) def get_anchors ( self , identifier : str ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler , \"fallback_config\" , {}) try : anchors = handler . get_anchors ( handler . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return () def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ] def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {} def get_handler ( self , name : str , handler_config : dict | None = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) handler_config . update ( self . _config ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" , ), stacklevel = 1 , ) self . _handlers [ name ] = module . get_handler ( theme = self . _config [ \"theme_name\" ], custom_templates = self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], config_file_path = self . _config [ \"mkdocs\" ][ \"config_file_path\" ], ** handler_config , ) return self . _handlers [ name ] @property def seen_handlers ( self ) -> Iterable [ BaseHandler ]: \"\"\"Get the handlers that were encountered so far throughout the build. Returns: An iterable of instances of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler] (usable only to loop through it). \"\"\" return self . _handlers . values () def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . teardown () self . _handlers . clear ()","title":"Handlers"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.seen_handlers","text":"Get the handlers that were encountered so far throughout the build. Returns: Type Description Iterable [ BaseHandler ] An iterable of instances of BaseHandler Iterable [ BaseHandler ] (usable only to loop through it).","title":"seen_handlers"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of mkdocstrings.plugin.MkdocstringsPlugin.on_config to see what's in this dictionary. required Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 501 502 503 504 505 506 507 508 509 510 def __init__ ( self , config : dict ) -> None : \"\"\"Initialize the object. Arguments: config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" self . _config = config self . _handlers : dict [ str , BaseHandler ] = {} self . inventory : Inventory = Inventory ( project = self . _config [ \"mkdocs\" ][ \"site_name\" ])","title":"__init__()"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_anchors","text":"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Parameters: Name Type Description Default identifier str The identifier (one that collect can accept). required Returns: Type Description tuple [ str , ...] | set [ str ] A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 def get_anchors ( self , identifier : str ) -> tuple [ str , ... ] | set [ str ]: \"\"\"Return the canonical HTML anchor for the identifier, if any of the seen handlers can collect it. Arguments: identifier: The identifier (one that [collect][mkdocstrings.handlers.base.BaseCollector.collect] can accept). Returns: A tuple of strings - anchors without '#', or an empty tuple if there isn't any identifier familiar with it. \"\"\" for handler in self . _handlers . values (): fallback_config = getattr ( handler , \"fallback_config\" , {}) try : anchors = handler . get_anchors ( handler . collect ( identifier , fallback_config )) except CollectionError : continue if anchors : return anchors return ()","title":"get_anchors()"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required handler_config dict | None Configuration passed to the handler. None Returns: Type Description BaseHandler An instance of a subclass of BaseHandler , as instantiated by the get_handler method of the handler's module. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def get_handler ( self , name : str , handler_config : dict | None = None ) -> BaseHandler : \"\"\"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. handler_config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.base.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in self . _handlers : if handler_config is None : handler_config = self . get_handler_config ( name ) handler_config . update ( self . _config ) try : module = importlib . import_module ( f \"mkdocstrings_handlers. { name } \" ) except ModuleNotFoundError : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) if name != \"python\" : warnings . warn ( DeprecationWarning ( \"Using the mkdocstrings.handlers namespace is deprecated. \" \"Handlers must now use the mkdocstrings_handlers namespace.\" , ), stacklevel = 1 , ) self . _handlers [ name ] = module . get_handler ( theme = self . _config [ \"theme_name\" ], custom_templates = self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], config_file_path = self . _config [ \"mkdocs\" ][ \"config_file_path\" ], ** handler_config , ) return self . _handlers [ name ]","title":"get_handler()"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 545 546 547 548 549 550 551 552 553 554 555 556 557 def get_handler_config ( self , name : str ) -> dict : \"\"\"Return the global configuration of the given handler. Arguments: name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( name , {}) return {}","title":"get_handler_config()"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_handler_name ( self , config : dict ) -> str : \"\"\"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" global_config = self . _config [ \"mkdocstrings\" ] if \"handler\" in config : return config [ \"handler\" ] return global_config [ \"default_handler\" ]","title":"get_handler_name()"},{"location":"docstrings/#mkdocstrings.handlers.base.Handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 609 610 611 612 613 def teardown ( self ) -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in self . seen_handlers : handler . teardown () self . _handlers . clear ()","title":"teardown()"},{"location":"docstrings/#mkdocstrings.handlers.base.ThemeNotSupported","text":"Bases: Exception An exception raised to tell a theme is not supported. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 41 42 class ThemeNotSupported ( Exception ): # noqa: N818 \"\"\"An exception raised to tell a theme is not supported.\"\"\"","title":"ThemeNotSupported"},{"location":"docstrings/#mkdocstrings.handlers.base.do_any","text":"Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str | None The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in .venv/lib/python3.11/site-packages/mkdocstrings/handlers/base.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def do_any ( seq : Sequence , attribute : str | None = None ) -> bool : \"\"\"Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"do_any()"},{"location":"mermaid/","text":"Mermaid See Meterial for MkDocs diagrams documentation for a complete reference. Those examples are extracted from the Mermaid documentation and are the most complexes found to showcase all styles and possibilities. Some have a Syntax error in graph instead of the diagram: it means that mkdocs-material 's mermaid.js version does not support them yet. Flowchart flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] Sequence diagram sequenceDiagram par Alice to Bob Alice->>Bob: Go help John and Alice to John Alice->>John: I want this done today par John to Charlie John->>Charlie: Can we do this today? and John to Diana John->>Diana: Can you help us today? end end Class diagram --- title: Animal example --- classDiagram note \"From Duck till Zebra\" Animal <|-- Duck note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\" Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } State diagram stateDiagram-v2 [*] --> Active state Active { [*] --> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvScrollLockPressed ScrollLockOn --> ScrollLockOff : EvScrollLockPressed } Entity Relationship diagram erDiagram CAR ||--o{ NAMED-DRIVER : allows CAR { string registrationNumber PK string make string model string[] parts } PERSON ||--o{ NAMED-DRIVER : is PERSON { string driversLicense PK \"The license #\" string(99) firstName \"Only 99 characters are allowed\" string lastName string phone UK int age } NAMED-DRIVER { string carRegistrationNumber PK, FK string driverLicence PK, FK } MANUFACTURER only one to zero or more CAR : makes Gantt gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Functionality added :milestone, 2014-01-25, 0d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h Pie Chart %%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%% pie showData title Key elements in Product X \"Calcium\" : 42.96 \"Potassium\" : 50.05 \"Magnesium\" : 10.01 \"Iron\" : 5 Requirement Diagram requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \"test suite\" docRef: github.com/all_the_tests } test_entity - satisfies -> test_req2 test_req - traces -> test_req2 test_req - contains -> test_req3 test_req3 - contains -> test_req4 test_req4 - derives -> test_req5 test_req5 - refines -> test_req6 test_entity3 - verifies -> test_req5 test_req <- copies - test_entity2 GitGraph gitGraph: commit \"Ashish\" branch newbranch checkout newbranch commit id:\"1111\" commit tag:\"test\" checkout main commit type: HIGHLIGHT commit merge newbranch commit branch b2 commit C4 Diagrams System Context C4Context title System Context diagram for Internet Banking System Enterprise_Boundary(b0, \"BankBoundary0\") { Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\", \"desc\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, <br/> with personal bank accounts.\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\") UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\") UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\") UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\") UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\") UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\") Container C4Container title Container diagram for Internet Banking System System_Ext(email_system, \"E-Mail System\", \"The internal Microsoft Exchange system\", $tags=\"v1.0\") Person(customer, Customer, \"A customer of the bank, with personal bank accounts\", $tags=\"v1.0\") Container_Boundary(c1, \"Internet Banking\") { Container(spa, \"Single-Page App\", \"JavaScript, Angular\", \"Provides all the Internet banking functionality to cutomers via their web browser\") Container_Ext(mobile_app, \"Mobile App\", \"C#, Xamarin\", \"Provides a limited subset of the Internet banking functionality to customers via their mobile device\") Container(web_app, \"Web Application\", \"Java, Spring MVC\", \"Delivers the static content and the Internet banking SPA\") ContainerDb(database, \"Database\", \"SQL Database\", \"Stores user registration information, hashed auth credentials, access logs, etc.\") ContainerDb_Ext(backend_api, \"API Application\", \"Java, Docker Container\", \"Provides Internet banking functionality via API\") } System_Ext(banking_system, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") Rel(customer, web_app, \"Uses\", \"HTTPS\") UpdateRelStyle(customer, web_app, $offsetY=\"60\", $offsetX=\"90\") Rel(customer, spa, \"Uses\", \"HTTPS\") UpdateRelStyle(customer, spa, $offsetY=\"-40\") Rel(customer, mobile_app, \"Uses\") UpdateRelStyle(customer, mobile_app, $offsetY=\"-30\") Rel(web_app, spa, \"Delivers\") UpdateRelStyle(web_app, spa, $offsetX=\"130\") Rel(spa, backend_api, \"Uses\", \"async, JSON/HTTPS\") Rel(mobile_app, backend_api, \"Uses\", \"async, JSON/HTTPS\") Rel_Back(database, backend_api, \"Reads from and writes to\", \"sync, JDBC\") Rel(email_system, customer, \"Sends e-mails to\") UpdateRelStyle(email_system, customer, $offsetX=\"-45\") Rel(backend_api, email_system, \"Sends e-mails using\", \"sync, SMTP\") UpdateRelStyle(backend_api, email_system, $offsetY=\"-60\") Rel(backend_api, banking_system, \"Uses\", \"sync/async, XML/HTTPS\") UpdateRelStyle(backend_api, banking_system, $offsetY=\"-50\", $offsetX=\"-140\") Component C4Component title Component diagram for Internet Banking System - API Application Container(spa, \"Single Page Application\", \"javascript and angular\", \"Provides all the internet banking functionality to customers via their web browser.\") Container(ma, \"Mobile App\", \"Xamarin\", \"Provides a limited subset ot the internet banking functionality to customers via their mobile mobile device.\") ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") System_Ext(mbs, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") Container_Boundary(api, \"API Application\") { Component(sign, \"Sign In Controller\", \"MVC Rest Controller\", \"Allows users to sign in to the internet banking system\") Component(accounts, \"Accounts Summary Controller\", \"MVC Rest Controller\", \"Provides customers with a summary of their bank accounts\") Component(security, \"Security Component\", \"Spring Bean\", \"Provides functionality related to singing in, changing passwords, etc.\") Component(mbsfacade, \"Mainframe Banking System Facade\", \"Spring Bean\", \"A facade onto the mainframe banking system.\") Rel(sign, security, \"Uses\") Rel(accounts, mbsfacade, \"Uses\") Rel(security, db, \"Read & write to\", \"JDBC\") Rel(mbsfacade, mbs, \"Uses\", \"XML/HTTPS\") } Rel_Back(spa, sign, \"Uses\", \"JSON/HTTPS\") Rel(spa, accounts, \"Uses\", \"JSON/HTTPS\") Rel(ma, sign, \"Uses\", \"JSON/HTTPS\") Rel(ma, accounts, \"Uses\", \"JSON/HTTPS\") UpdateRelStyle(spa, sign, $offsetY=\"-40\") UpdateRelStyle(spa, accounts, $offsetX=\"40\", $offsetY=\"40\") UpdateRelStyle(ma, sign, $offsetX=\"-90\", $offsetY=\"40\") UpdateRelStyle(ma, accounts, $offsetY=\"-40\") UpdateRelStyle(sign, security, $offsetX=\"-160\", $offsetY=\"10\") UpdateRelStyle(accounts, mbsfacade, $offsetX=\"140\", $offsetY=\"10\") UpdateRelStyle(security, db, $offsetY=\"-40\") UpdateRelStyle(mbsfacade, mbs, $offsetY=\"-40\") Dynamic C4Dynamic title Dynamic diagram for Internet Banking System - API Application ContainerDb(c4, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") Container(c1, \"Single-Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet banking functionality to customers via their web browser.\") Container_Boundary(b, \"API Application\") { Component(c3, \"Security Component\", \"Spring Bean\", \"Provides functionality Related to signing in, changing passwords, etc.\") Component(c2, \"Sign In Controller\", \"Spring MVC Rest Controller\", \"Allows users to sign in to the Internet Banking System.\") } Rel(c1, c2, \"Submits credentials to\", \"JSON/HTTPS\") Rel(c2, c3, \"Calls isAuthenticated() on\") Rel(c3, c4, \"select * from users where username = ?\", \"JDBC\") UpdateRelStyle(c1, c2, $textColor=\"red\", $offsetY=\"-40\") UpdateRelStyle(c2, c3, $textColor=\"red\", $offsetX=\"-40\", $offsetY=\"60\") UpdateRelStyle(c3, c4, $textColor=\"red\", $offsetY=\"-40\", $offsetX=\"10\") Deployment C4Deployment title Deployment Diagram for Internet Banking System - Live Deployment_Node(mob, \"Customer's mobile device\", \"Apple IOS or Android\"){ Container(mobile, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the Internet Banking functionality to customers via their mobile device.\") } Deployment_Node(comp, \"Customer's computer\", \"Microsoft Windows or Apple macOS\"){ Deployment_Node(browser, \"Web Browser\", \"Google Chrome, Mozilla Firefox,<br/> Apple Safari or Microsoft Edge\"){ Container(spa, \"Single Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet Banking functionality to customers via their web browser.\") } } Deployment_Node(plc, \"Big Bank plc\", \"Big Bank plc data center\"){ Deployment_Node(dn, \"bigbank-api*** x8\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(apache, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){ Container(api, \"API Application\", \"Java and Spring MVC\", \"Provides Internet Banking functionality via a JSON/HTTPS API.\") } } Deployment_Node(bb2, \"bigbank-web*** x4\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(apache2, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){ Container(web, \"Web Application\", \"Java and Spring MVC\", \"Delivers the static content and the Internet Banking single page application.\") } } Deployment_Node(bigbankdb01, \"bigbank-db01\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(oracle, \"Oracle - Primary\", \"Oracle 12c\"){ ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") } } Deployment_Node(bigbankdb02, \"bigbank-db02\", \"Ubuntu 16.04 LTS\") { Deployment_Node(oracle2, \"Oracle - Secondary\", \"Oracle 12c\") { ContainerDb(db2, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") } } } Rel(mobile, api, \"Makes API calls to\", \"json/HTTPS\") Rel(spa, api, \"Makes API calls to\", \"json/HTTPS\") Rel_U(web, spa, \"Delivers to the customer's web browser\") Rel(api, db, \"Reads from and writes to\", \"JDBC\") Rel(api, db2, \"Reads from and writes to\", \"JDBC\") Rel_R(db, db2, \"Replicates data to\") UpdateRelStyle(spa, api, $offsetY=\"-40\") UpdateRelStyle(web, spa, $offsetY=\"-40\") UpdateRelStyle(api, db, $offsetY=\"-20\", $offsetX=\"5\") UpdateRelStyle(api, db2, $offsetX=\"-40\", $offsetY=\"-20\") UpdateRelStyle(db, db2, $offsetY=\"-10\") Mindmaps mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectiveness<br/>and features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid Timeline timeline title History of Social Media Platform 2002 : LinkedIn 2004 : Facebook : Google 2005 : Youtube 2006 : Twitter","title":"Mermaid"},{"location":"mermaid/#mermaid","text":"See Meterial for MkDocs diagrams documentation for a complete reference. Those examples are extracted from the Mermaid documentation and are the most complexes found to showcase all styles and possibilities. Some have a Syntax error in graph instead of the diagram: it means that mkdocs-material 's mermaid.js version does not support them yet.","title":"Mermaid"},{"location":"mermaid/#flowchart","text":"flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two]","title":"Flowchart"},{"location":"mermaid/#sequence-diagram","text":"sequenceDiagram par Alice to Bob Alice->>Bob: Go help John and Alice to John Alice->>John: I want this done today par John to Charlie John->>Charlie: Can we do this today? and John to Diana John->>Diana: Can you help us today? end end","title":"Sequence diagram"},{"location":"mermaid/#class-diagram","text":"--- title: Animal example --- classDiagram note \"From Duck till Zebra\" Animal <|-- Duck note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\" Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() }","title":"Class diagram"},{"location":"mermaid/#state-diagram","text":"stateDiagram-v2 [*] --> Active state Active { [*] --> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvScrollLockPressed ScrollLockOn --> ScrollLockOff : EvScrollLockPressed }","title":"State diagram"},{"location":"mermaid/#entity-relationship-diagram","text":"erDiagram CAR ||--o{ NAMED-DRIVER : allows CAR { string registrationNumber PK string make string model string[] parts } PERSON ||--o{ NAMED-DRIVER : is PERSON { string driversLicense PK \"The license #\" string(99) firstName \"Only 99 characters are allowed\" string lastName string phone UK int age } NAMED-DRIVER { string carRegistrationNumber PK, FK string driverLicence PK, FK } MANUFACTURER only one to zero or more CAR : makes","title":"Entity Relationship diagram"},{"location":"mermaid/#gantt","text":"gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Functionality added :milestone, 2014-01-25, 0d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h","title":"Gantt"},{"location":"mermaid/#pie-chart","text":"%%{init: {\"pie\": {\"textPosition\": 0.5}, \"themeVariables\": {\"pieOuterStrokeWidth\": \"5px\"}} }%% pie showData title Key elements in Product X \"Calcium\" : 42.96 \"Potassium\" : 50.05 \"Magnesium\" : 10.01 \"Iron\" : 5","title":"Pie Chart"},{"location":"mermaid/#requirement-diagram","text":"requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \"test suite\" docRef: github.com/all_the_tests } test_entity - satisfies -> test_req2 test_req - traces -> test_req2 test_req - contains -> test_req3 test_req3 - contains -> test_req4 test_req4 - derives -> test_req5 test_req5 - refines -> test_req6 test_entity3 - verifies -> test_req5 test_req <- copies - test_entity2","title":"Requirement Diagram"},{"location":"mermaid/#gitgraph","text":"gitGraph: commit \"Ashish\" branch newbranch checkout newbranch commit id:\"1111\" commit tag:\"test\" checkout main commit type: HIGHLIGHT commit merge newbranch commit branch b2 commit","title":"GitGraph"},{"location":"mermaid/#c4-diagrams","text":"","title":"C4 Diagrams"},{"location":"mermaid/#system-context","text":"C4Context title System Context diagram for Internet Banking System Enterprise_Boundary(b0, \"BankBoundary0\") { Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\", \"desc\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, <br/> with personal bank accounts.\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\") UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\") UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\") UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\") UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\") UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\")","title":"System Context"},{"location":"mermaid/#container","text":"C4Container title Container diagram for Internet Banking System System_Ext(email_system, \"E-Mail System\", \"The internal Microsoft Exchange system\", $tags=\"v1.0\") Person(customer, Customer, \"A customer of the bank, with personal bank accounts\", $tags=\"v1.0\") Container_Boundary(c1, \"Internet Banking\") { Container(spa, \"Single-Page App\", \"JavaScript, Angular\", \"Provides all the Internet banking functionality to cutomers via their web browser\") Container_Ext(mobile_app, \"Mobile App\", \"C#, Xamarin\", \"Provides a limited subset of the Internet banking functionality to customers via their mobile device\") Container(web_app, \"Web Application\", \"Java, Spring MVC\", \"Delivers the static content and the Internet banking SPA\") ContainerDb(database, \"Database\", \"SQL Database\", \"Stores user registration information, hashed auth credentials, access logs, etc.\") ContainerDb_Ext(backend_api, \"API Application\", \"Java, Docker Container\", \"Provides Internet banking functionality via API\") } System_Ext(banking_system, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") Rel(customer, web_app, \"Uses\", \"HTTPS\") UpdateRelStyle(customer, web_app, $offsetY=\"60\", $offsetX=\"90\") Rel(customer, spa, \"Uses\", \"HTTPS\") UpdateRelStyle(customer, spa, $offsetY=\"-40\") Rel(customer, mobile_app, \"Uses\") UpdateRelStyle(customer, mobile_app, $offsetY=\"-30\") Rel(web_app, spa, \"Delivers\") UpdateRelStyle(web_app, spa, $offsetX=\"130\") Rel(spa, backend_api, \"Uses\", \"async, JSON/HTTPS\") Rel(mobile_app, backend_api, \"Uses\", \"async, JSON/HTTPS\") Rel_Back(database, backend_api, \"Reads from and writes to\", \"sync, JDBC\") Rel(email_system, customer, \"Sends e-mails to\") UpdateRelStyle(email_system, customer, $offsetX=\"-45\") Rel(backend_api, email_system, \"Sends e-mails using\", \"sync, SMTP\") UpdateRelStyle(backend_api, email_system, $offsetY=\"-60\") Rel(backend_api, banking_system, \"Uses\", \"sync/async, XML/HTTPS\") UpdateRelStyle(backend_api, banking_system, $offsetY=\"-50\", $offsetX=\"-140\")","title":"Container"},{"location":"mermaid/#component","text":"C4Component title Component diagram for Internet Banking System - API Application Container(spa, \"Single Page Application\", \"javascript and angular\", \"Provides all the internet banking functionality to customers via their web browser.\") Container(ma, \"Mobile App\", \"Xamarin\", \"Provides a limited subset ot the internet banking functionality to customers via their mobile mobile device.\") ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") System_Ext(mbs, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") Container_Boundary(api, \"API Application\") { Component(sign, \"Sign In Controller\", \"MVC Rest Controller\", \"Allows users to sign in to the internet banking system\") Component(accounts, \"Accounts Summary Controller\", \"MVC Rest Controller\", \"Provides customers with a summary of their bank accounts\") Component(security, \"Security Component\", \"Spring Bean\", \"Provides functionality related to singing in, changing passwords, etc.\") Component(mbsfacade, \"Mainframe Banking System Facade\", \"Spring Bean\", \"A facade onto the mainframe banking system.\") Rel(sign, security, \"Uses\") Rel(accounts, mbsfacade, \"Uses\") Rel(security, db, \"Read & write to\", \"JDBC\") Rel(mbsfacade, mbs, \"Uses\", \"XML/HTTPS\") } Rel_Back(spa, sign, \"Uses\", \"JSON/HTTPS\") Rel(spa, accounts, \"Uses\", \"JSON/HTTPS\") Rel(ma, sign, \"Uses\", \"JSON/HTTPS\") Rel(ma, accounts, \"Uses\", \"JSON/HTTPS\") UpdateRelStyle(spa, sign, $offsetY=\"-40\") UpdateRelStyle(spa, accounts, $offsetX=\"40\", $offsetY=\"40\") UpdateRelStyle(ma, sign, $offsetX=\"-90\", $offsetY=\"40\") UpdateRelStyle(ma, accounts, $offsetY=\"-40\") UpdateRelStyle(sign, security, $offsetX=\"-160\", $offsetY=\"10\") UpdateRelStyle(accounts, mbsfacade, $offsetX=\"140\", $offsetY=\"10\") UpdateRelStyle(security, db, $offsetY=\"-40\") UpdateRelStyle(mbsfacade, mbs, $offsetY=\"-40\")","title":"Component"},{"location":"mermaid/#dynamic","text":"C4Dynamic title Dynamic diagram for Internet Banking System - API Application ContainerDb(c4, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") Container(c1, \"Single-Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet banking functionality to customers via their web browser.\") Container_Boundary(b, \"API Application\") { Component(c3, \"Security Component\", \"Spring Bean\", \"Provides functionality Related to signing in, changing passwords, etc.\") Component(c2, \"Sign In Controller\", \"Spring MVC Rest Controller\", \"Allows users to sign in to the Internet Banking System.\") } Rel(c1, c2, \"Submits credentials to\", \"JSON/HTTPS\") Rel(c2, c3, \"Calls isAuthenticated() on\") Rel(c3, c4, \"select * from users where username = ?\", \"JDBC\") UpdateRelStyle(c1, c2, $textColor=\"red\", $offsetY=\"-40\") UpdateRelStyle(c2, c3, $textColor=\"red\", $offsetX=\"-40\", $offsetY=\"60\") UpdateRelStyle(c3, c4, $textColor=\"red\", $offsetY=\"-40\", $offsetX=\"10\")","title":"Dynamic"},{"location":"mermaid/#deployment","text":"C4Deployment title Deployment Diagram for Internet Banking System - Live Deployment_Node(mob, \"Customer's mobile device\", \"Apple IOS or Android\"){ Container(mobile, \"Mobile App\", \"Xamarin\", \"Provides a limited subset of the Internet Banking functionality to customers via their mobile device.\") } Deployment_Node(comp, \"Customer's computer\", \"Microsoft Windows or Apple macOS\"){ Deployment_Node(browser, \"Web Browser\", \"Google Chrome, Mozilla Firefox,<br/> Apple Safari or Microsoft Edge\"){ Container(spa, \"Single Page Application\", \"JavaScript and Angular\", \"Provides all of the Internet Banking functionality to customers via their web browser.\") } } Deployment_Node(plc, \"Big Bank plc\", \"Big Bank plc data center\"){ Deployment_Node(dn, \"bigbank-api*** x8\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(apache, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){ Container(api, \"API Application\", \"Java and Spring MVC\", \"Provides Internet Banking functionality via a JSON/HTTPS API.\") } } Deployment_Node(bb2, \"bigbank-web*** x4\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(apache2, \"Apache Tomcat\", \"Apache Tomcat 8.x\"){ Container(web, \"Web Application\", \"Java and Spring MVC\", \"Delivers the static content and the Internet Banking single page application.\") } } Deployment_Node(bigbankdb01, \"bigbank-db01\", \"Ubuntu 16.04 LTS\"){ Deployment_Node(oracle, \"Oracle - Primary\", \"Oracle 12c\"){ ContainerDb(db, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") } } Deployment_Node(bigbankdb02, \"bigbank-db02\", \"Ubuntu 16.04 LTS\") { Deployment_Node(oracle2, \"Oracle - Secondary\", \"Oracle 12c\") { ContainerDb(db2, \"Database\", \"Relational Database Schema\", \"Stores user registration information, hashed authentication credentials, access logs, etc.\") } } } Rel(mobile, api, \"Makes API calls to\", \"json/HTTPS\") Rel(spa, api, \"Makes API calls to\", \"json/HTTPS\") Rel_U(web, spa, \"Delivers to the customer's web browser\") Rel(api, db, \"Reads from and writes to\", \"JDBC\") Rel(api, db2, \"Reads from and writes to\", \"JDBC\") Rel_R(db, db2, \"Replicates data to\") UpdateRelStyle(spa, api, $offsetY=\"-40\") UpdateRelStyle(web, spa, $offsetY=\"-40\") UpdateRelStyle(api, db, $offsetY=\"-20\", $offsetX=\"5\") UpdateRelStyle(api, db2, $offsetX=\"-40\", $offsetY=\"-20\") UpdateRelStyle(db, db2, $offsetY=\"-10\")","title":"Deployment"},{"location":"mermaid/#mindmaps","text":"mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectiveness<br/>and features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid","title":"Mindmaps"},{"location":"mermaid/#timeline","text":"timeline title History of Social Media Platform 2002 : LinkedIn 2004 : Facebook : Google 2005 : Youtube 2006 : Twitter","title":"Timeline"},{"location":"openapi/","text":"","title":"OpenAPI"}]}